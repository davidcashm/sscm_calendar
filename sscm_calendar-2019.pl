#!perl.exe -w

# sscm_calendar_2018.pl
# Copyright (C) 2007-2018 David Cashman and Ari Meir Brodsky
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

# A version of this program is at:
# http://www.jspiro.com/files/sw/shulcalendar/shulcalendar-0002
# and at
# http://individual.utoronto.ca/aribrodsky/
# (These should be updated to the most recent.)

# Generate a calendar based on specifications from Ari Brodsky.
# Reads in a generic Jewish calendar for a given period, and computes
# the SSCM-specific times and dates.

# This program generates an annual calendar, including zmanim,
# in Microsoft Excel format,
# for Shomrai Shabbos Chevra Mishnayos shul (synagogue), which is located
# in Toronto, Canada,
# based on specifications from Ari Brodsky.
# Reads in a generic Jewish calendar generated by a modification of the hebcal program
# ( http://www.sadinoff.com/hebcal/ )
# for a given period, and computes
# the SSCM-specific times and dates.

# David Cashman wrote most of the code.
# He says, "I don't think that it would be of any use
# to anybody who's not writing a calendar program for Shomrai
# Shabbos Chevra Mishnayos".
# David added,
# "I compiled on Linux.  The command line option that I used was
# hebcal -a -c -d -o -r -s -w <year>
# I ran it for a bunch of years, and then concatenated the outputs together."
### THIS DESCRIPTION IS NOT QUITE CORRECT AND NEEDS TO BE FIXED
# Ari Meir Brodsky <ari.brodsky _at_ utoronto.ca> contributed specifications
# and some of the code.

# We would love to hear from you if you make use of this.  Patches welcome.

use strict;
use Carp;
use Date::Calc qw(:all);

use Math::Trig;
use Math::Trig ':pi';


#### Check all places where $renovation is used!!!

# Set to 1 to print extra info to the calendar output.
my $debug_info = 0; # Don't know whether this works any more as it hasn't been tested since many changes were made

# Dumping extra stuff to Excel
my $full_debug = 0; #NOTE this may not work any more as it hasn't been tested since changes were made

# Set to 1 to make adjustments to Shabbos Mincha and related times during renovation:
my $renovation = 0;

# Set each flag to 1 to construct the corresponding output type; 0 to omit that output
# (text file output will always be created)
my $output_excel = 0;
my $output_ical = 1;
my $output_csv = 1; # for the Michael Mann website thing
my $output_csvtable = 1; # csv with headings and filtered columns

my $with_730 = 0;   # whether or not there is a 7:30 Shabbos morning minyan; uncertainty in fall 5780
my $YMM_is_uncertain = 1; # in 5780 the time is being tested

# Shmuel wanted us to just put bold around all of the categories and none of the
# times, but then he changed his mind.
my $bold_everything_in_ical = 0;

#   Here we set the year and months to output to Excel
   # TODO: HACK: I should make this data driven
my $curr_year = 2019;
my $next_year = $curr_year + 1;
# Un-comment whichever months are to be printed.
my @months_to_print = (
            "$curr_year,9",
            "$curr_year,10",
            "$curr_year,11",
            "$curr_year,12",
            "$next_year,1",
            "$next_year,2",
            "$next_year,3",
            "$next_year,4",
            "$next_year,5",
            "$next_year,6",
            "$next_year,7",
            "$next_year,8",
            "$next_year,9",
            "$next_year,10"
);


# Do we want to print half or the entire month to each excel sheet.
# I set this where I set the specific months to print.
my $full_month_per_page = 0;

# Do we want to start in the third week of September (this is a hack; may work only for 2009)
my $sept_start_third_week_2009 = 0;

# Default input filename; can be overridden by command-line argument.
my $default_hebcal_file = "dates.txt";
    # "c:/Documents and Settings/Ari-user/My Documents/Activism/SSCM/Bulletin automation/all_calendar_years.txt";
    # "c:/sscm_calendar/hebcal2007.txt";


#  This needs to be inserted on the Excel page for months from March through September.  -AB
my $kindly_note = #"** Kindly Note:  ". chr(10).         # [Decimal value - chr(10) is Line Feed]
                        "The time for Candle Lighting listed in the calendar is to be regarded ".#chr(10).
                        "where the household commences the observance of Shabbos at the regular hour.".chr(10).
                        "In the household where the observance of Shabbos commences earlier, ".#chr(10).
                        "the candles should not be lit before Plag HaMincha.";

my $YMM_note = "* Young Members' Minyan time subject to change;"  . chr(10) . " please consult an updated electronic version of calendar to confirm.";

# AB:
# Set to 1 to generate output for a calendar date on a single line with comma-separated fields.
# Set to 0 to generate output for a calendar date with fields on separate lines,
# to make it easier for Rob to import it into the printed calendar.
# my $output_format_compact = 0;
my $output_format_compact;

# Arbitrary constant to use when there is no time to print
# (e.g. Eiruv Tavshilin)
my $NOTIME = "NO_TIME_DEFINED";

# Global variables.
# Store a hash that points to the array entry for the first of
# the month.  Allows me to quickly find civil holidays, etc.
my %index_of_first_day_of_the_month;
my %index_of_first_day_of_the_hebrew_month;
# List of all days, and associated info.
my @list_of_days;
# All of the data to be printed for each day, in a reasonable
# format and ordering.
my @print_data_for_day;

my $output_filename = "";

# A hash of all years in the calendar.  Value of each hash entry is 1.
my %english_years;
my %hebrew_years;

# I should really just build this map in code from the hebrew_months array.
# Adar I/II messes things up, though.
## NOTE The months are spelled here (and in the hebrew_months array) the way Hebcal spells them.
## Don't "fix" these spellings because it will mess up the processing, unless you change the spelling when reading from the data file.
## The spellings aren't used in output anyway - except now in the Rosh Chodesh labels.
##  Easier just to fix the Rosh Chodesh labels in modify_rosh_chodesh().
####### Actually they are used now in the website output version
####### so created function get_output_month_name($) to be called whenever necessary
my %hebrew_month_index = (
      Tishrei => 1,
      Cheshvan => 2,
      Kislev => 3,
      Tevet => 4,
      "Sh'vat" => 5,
      Adar => 6,
      "Adar I" => 6,
      "Adar II" => 6,
      Nisan => 7,
      Iyyar => 8,
      Sivan => 9,
      Tamuz => 10,
      Av => 11,
      Elul => 12,
);
my @hebrew_months = (
      undef,
      "Tishrei",
      "Cheshvan",
      "Kislev",
      "Tevet",
      "Sh'vat",
      "Adar",
      "Nisan",
      "Iyyar",
      "Sivan",
      "Tamuz",
      "Av",
      "Elul",
);

my @english_months = (
      undef,
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
);

my %index_of_english_months;
for (my $i = 0; $i <= $#english_months; $i++)
{
   my $month = $english_months[$i];
   if (defined ($month))
   {
        $index_of_english_months{$month} = $i;
   }
}

my %day_of_week_index = (
   Sun => 1,
   Mon => 2,
   Tue => 3,
   Wed => 4,
   Thu => 5,
   Fri => 6,
   Sat => 7,
);

my %holidays_found;

# Main Excel application object.
my $Excel;

# darwin is osx.  I should probably be checking if the OS is Windows, not if it
# isn't osx, but I'm on a Mac right now, and I'm not sure what Windows reports
# as the OS
if ($^O ne "darwin") {
# For some reason, the following two lines are needed for writing unicode
# (e.g. Hebrew characters) to Excel.
  eval 'use Win32::OLE qw(CP_UTF8)';
  eval '$Win32::OLE::CP = CP_UTF8';
  eval 'use Win32::OLE;';
  eval "use Win32::OLE::Const 'Microsoft Excel';";
  eval 'use Win32::OLE qw(in with);';
  eval 'use Win32::OLE::Variant;';
}
else {
  # Dummy functions to avoid bareword warnings on Mac
  sub xlCenter {croak "Should not be called";}
  sub xlLeft {croak "Should not be called";}
  sub xlTop {croak "Should not be called";}
  sub VT_BOOL {croak "Should not be called";}
  sub VT_I4 {croak "Should not be called";}
  sub xlPortrait {croak "Should not be called";}
  sub xlLandscape {croak "Should not be called";}
  sub xlThin {croak "Should not be called";}
  sub xlEdgeLeft {croak "Should not be called";}
  sub xlEdgeTop {croak "Should not be called";}
  sub xlEdgeBottom {croak "Should not be called";}
  sub xlEdgeRight {croak "Should not be called";}
}

my $alef = chr(0x05d0);     # 0x indicates hexadecimal values
my $bet = chr(0x05d1);
my $gimel = chr(0x05d2);
my $dalet = chr(0x05d3);
my $heh = chr(0x05d4);
my $vav = chr(0x05d5);
my $zayin = chr(0x05d6);
my $chet = chr(0x05d7);
my $tet = chr(0x05d8);
my $yud = chr(0x05d9);
my $end_kaf = chr(0x05da);
my $kaf = chr(0x05db);
my $lamed = chr(0x05dc);
my $end_mem = chr(0x05dd);
my $mem = chr(0x05de);
my $end_nun = chr(0x05df);
my $nun = chr(0x05e0);
my $samech = chr(0x05e1);
my $ayin = chr(0x05e2);
my $end_pe = chr(0x05e3);
my $pe = chr(0x05e4);
my $end_tzadi = chr(0x05e5);
my $tzadi = chr(0x05e6);
my $kuf = chr(0x05e7);
my $resh = chr(0x05e8);
my $shin = chr(0x05e9);
my $tav = chr(0x05ea);

my $geresh = chr(0x05f3);
my $gershayim = chr(0x05f4);


my $bullet = chr(0x2022);       # for the Excel file
my $text_bullet = chr(0x00b7);  # for printing to text output
## choices for bullet are:
# chr(0x002a)   "asterisk"
# chr(0x00b7)   "middle dot"
# chr(0x2022)   "bullet"
# chr(0x2023)   "triangular bullet"

# 00a0 is non-breaking space; this is safe even for text output to the .txt file (but does not show up correctly in Command Prompt window).
my $nbsp = chr(0x00a0);
my $only = $nbsp . "only";
# probably best NOT to use separator when there are four times, because it may make the line too long.
my $separator = $nbsp . "/" . $nbsp;

# Arbitrary strings to represent special functions.
# Just need to make sure that these strings will never
# appear in actual output.

# Don't put a bullet before the item.
my $NOBULLET = "<<NOBULLET>>";
# Bold the item
my $BOLD = "<<BOLD>>";
# Italics the item
my $ITALIC = "<<ITALIC>>";
my $FONT14 = "<<FONT14>>";
# Don't use the title.  E.g. for Parasha, we don't actually
# want it to write the word "Parasha".
my $NOTITLE = "<<NOTITLE>>";

my $START_BOLD = "<<START_PARTIAL_BOLD>>";
my $END_BOLD = "<<END_PARTIAL_BOLD>>";


######### AMB  These codes might not work any more.
#########  Bold works, and so does Nobullet,
#########  but I'm pretty sure I broke italic (which we weren't using anyway) and font14 (which we did use in 5769)
#########  when I changed to each calendar box being one cell with chr(10) between rows.
# Note to Ari:
# There are two ways to treat something with any of the above four
# special items.  Either put them in the list below, in which case
# they will apply to all things of that type.  Each item should
# be separated by a dot.
#
# Alternatively, put them into the string at any point in the code.
# For example, if you want to highlight when Maariv is at 9:37, you
# could go to the line where it says:
# $late_maariv = "9:37";
# and change that to
# $late_maariv = $BOLD . "9:37";
#
# It doesn't really matter if you put the "$BOLD" before, after
# or in the middle of a string.
#
# START_BOLD and END_BOLD are sensitive to where they are placed.
# Only the text between these two flags will be bolded.  (Note that
# you should probably not use START_BOLD and END_BOLD in conjunction
# with any other format flags, including regular BOLD.  Check their
# results over carefully to make sure that they're not broken.)
#### ALSO now you should not use $START_BOLD without $END_BOLD, even if it goes
#### to the end of the line - AMB.
##  Also, NOTITLE works only when placed in the list below, not in the time string.
my %special_functions_map =
(
#   Parasha => $NOTITLE . $NOBULLET . $FONT14 . $BOLD,  # This field is not used
   "Slichos" => $BOLD,
#   SpecialShabbos => $NOTITLE . $NOBULLET . $BOLD,
   "***K'vasikin" => $NOBULLET . $BOLD,
   "Megillas Esther " => $BOLD,
   "Siyum & Breakfast" => $BOLD,
   "Shofar" => $BOLD,
   "Zachor" => $BOLD,
   "Hataras Nedarim" => $BOLD,
   "May Eat Chometz Until" => $BOLD,
   "Burn Chometz Before" => $BOLD,
   "Dispose of Chometz Before" => $BOLD,
   "Yizkor" => $BOLD,
   "Eiruv Tavshilin" => $BOLD,
   "Drasha" => $BOLD,
   "Kol Nidrei" => $BOLD,
   "Sisterhood Tea" => $BOLD,
   "Seuda Hamafsekes" => $BOLD,
   "Neilas Hachag" => $BOLD,
#   "Candle Lighting after" => $BOLD,
   "Megillas Esther" => $BOLD,
   "Tickets" => $BOLD,
);

my %hebrew_month_unicode = (
      Tishrei => "$tav$shin$resh$yud",
      Cheshvan => "$mem$resh$chet$shin$vav$end_nun", # AMB changed to Marcheshvan
      Kislev => "$kaf$samech$lamed$vav",
      Tevet => "$tet$bet$tav",
      "Sh'vat" => "$shin$bet$tet",
      Adar => "$alef$dalet$resh",
      "Adar I" => "$alef$dalet$resh$nbsp$alef$geresh",
      "Adar II" => "$alef$dalet$resh$nbsp$bet$geresh",
      Nisan => "$nun$yud$samech$end_nun",
      Iyyar => "$alef$yud$yud$resh",
      Sivan => "$samech$yud$vav$end_nun",
      Tamuz => "$tav$mem$vav$zayin",
      Av => "$mem$nun$chet$end_mem$nbsp$alef$bet", # AMB changed to Menachem Av
      Elul => "$alef$lamed$vav$lamed",
);

my %gematria_vals =
(
   1 => "$alef",
   2 => "$bet",
   3 => "$gimel",
   4 => "$dalet",
   5 => "$heh",
   6 => "$vav",
   7 => "$zayin",
   8 => "$chet",
   9 => "$tet",
   10 => "$yud",
   20 => "$kaf",
   30 => "$lamed",
   40 => "$mem",
   50 => "$nun",
   60 => "$samech",
   70 => "$ayin",
   80 => "$pe",
   90 => "$tzadi",
   100 => "$kuf",
   200 => "$resh",
   300 => "$shin",
   400 => "$tav"
);

my %gematria_end_vals =
(
   1 => "$alef",
   2 => "$bet",
   3 => "$gimel",
   4 => "$dalet",
   5 => "$heh",
   6 => "$vav",
   7 => "$zayin",
   8 => "$chet",
   9 => "$tet",
   10 => "$yud",
   20 => $end_kaf,
   30 => "$lamed",
   40 => $end_mem,
   50 => $end_nun,
   60 => "$samech",
   70 => "$ayin",
   80 => $end_pe,
   90 => $end_tzadi,
   100 => "$kuf",
   200 => "$resh",
   300 => "$shin",
   400 => "$tav"
);

# Maps from day to shacharis times.
my $early_shacharis = "6:45" . $separator . "6:50" . $separator . "7:30";
my $late_shacharis = "6:45" . $separator . "6:50" . $separator . "7:30";  # used to be 6:55 instead of 6:50, until November 2008
#my $no_middle_minyan_shacharis = "6:45" . $separator . "7:30";
my $isru_chag_shacharis = "6:45" . $separator . "7:30" . $separator . "8:30" . $BOLD;
my $sunday_shacharis = "7:30" . $separator . "8:00" . $separator . "8:30";
#my $holiday_shacharis = $BOLD . $sunday_shacharis;  # for public holidays
# in 2012 decided to remove 8:00 Shacharis from public holidays because there wasn't a minyan
my $holiday_shacharis = $BOLD . "7:30" . $separator . "8:30";
my $shabbos_shacharis_5779 = "8:00" . $separator . "8:55" . $separator . "9:00"; # changed in 2018
my $shabbos_shacharis_with_730 = "7:30" . $separator . "8:30" . $separator . "9:00" . $separator . "9:15";
my $shabbos_shacharis_without_730  = "8:30" . $separator . "8:55" . $separator . "9:00";
my $shabbos_shacharis_compromise  = "8:30" . $separator . "9:00" . $separator . "9:15*";
# my $shabbos_shacharis = $with_730 ? $shabbos_shacharis_with_730 : $shabbos_shacharis_without_730;
my $shabbos_shacharis = $shabbos_shacharis_compromise;
#my $shabbos_shacharis = "8:00" . $separator . "9:00" . $separator . "9:15"; # Young Members' Minyan at 9:00 added summer of 2011;
# For 5774 switched to using $separator here; this makes the entry 29 characters long so it will wrap unless we widen the Shabbos column
#my $shabbos_shacharis = "8:00/9:00/9:15"; # not using $separator bcs this sets the width at 25 characters without it
my $chumash_shiur = "8:00";  # used to be "8:15" when Shacharis was at 9:15 until 2018
#my $yom_tov_shacharis = $BOLD . "9:00 only"; # removed hashkama for 5771 but this was criticized so reinstated it.
my $yom_tov_shacharis = "8:00" . $separator . $START_BOLD . "9:00$END_BOLD";  # no YMM on yom tov or Shab.ChM
#my $shabbos_shacharis_with_hallel = $yom_tov_shacharis;     # implementing this rule for 5772, but it ignores the YMM - why?  No longer need it from 2018
#my $chumash_shiur_special = $START_BOLD . "8:00$END_BOLD"; # for Shabbatot when Shacharis is at 9:00 rather than 9:15
my $chumash_shiur_pesach = $BOLD . "8:15";	# when first day Pesach falls on Shabbos and Shacharis is 9:15
my $rosh_chodesh_shacharis = $START_BOLD . "6:30" . $separator . "6:45" . $END_BOLD . $separator . "7:30";
                                            # "$START_BOLD" . "6:35/6:45$END_BOLD/7:30";
my $earliest_shacharis_before_sunrise = 69; # for Rosh Chodesh and fast days - can't make Shacharis too early
my $fast_day_shacharis = $START_BOLD . "6:30" . $END_BOLD . $separator . "6:50" . $separator . "7:30";
		# "6:45" . $separator . "6:50" . $separator . "7:30";
my $chanuka_shacharis = "6:45" . $separator . "6:50" . $separator . "7:30";
                # don't need any bold for Chanuka Shacharis any more because it's the same as every day!
                # NOTE this used to be the same as fast days, until fast days were changed in 5778
my $tisha_bav_weekday_shacharis = $BOLD . "6:30" . $separator . "7:30" . $separator . "8:30";
my $tisha_bav_sunday_shacharis = $BOLD . "7:30" . $separator . "8:30";
my $shavuos_shacharis = $BOLD . "9:00"; # also add vasikin
#my $shavuos_shacharis = $BOLD . "5:00***/9:00";
# Rosh Hashana.
my $rh_shacharis = $START_BOLD . "8:00$only". $END_BOLD;
my $yk_shacharis = $rh_shacharis;
my $simchas_torah_shacharis = $BOLD . "8:00";  # but add also Vasikin later. It used to be 8:30, but changed to 8:00 in 5767
#my $shabbos_chol_hamoed_succos_shacharis = $BOLD . "8:00/9:00"; # for Shabbos Chol HaMoed Succos and Shabbos Chanuka Rosh Chodesh
my $pesach_shacharis = $START_BOLD . "9:15$only".$END_BOLD; # $START_BOLD . "8:30/9:15".$END_BOLD;
                                        # hashkama added in 2009 NO! it happened on Pesach 2009 but then decided not to continue.
# For Chol Hamoed
# my $moed_shacharis = $BOLD . "6:30/7:30/8:30";
my $chol_hamoed_succos_5771_shacharis = $BOLD . "6:30/7:00/7:30/8:30";   # adding 7:00 for Succos starting in 5771 by request of Steven Tenenbaum
                                                                # Maybe it will have to be later in years when sunrise is late  # NOT CONTINUING
my $chol_hamoed_shacharis = $BOLD . "6:30" . $separator . "7:30" . $separator . "8:30";
my %shacharis_time = (
    Sun => $sunday_shacharis,
    Mon => $early_shacharis,
    Tue => $late_shacharis,
    Wed => $late_shacharis,
    Thu => $early_shacharis,
    Fri => $late_shacharis,
    Sat => $shabbos_shacharis,
);

my $womens_avos = "5:30";
my $teshuva_shiur = "12 midnight"; # was 11:45 originally; changed to 12:00 in 2018, though the e-bulletin said 12:15
my $first_slichos = "1:00 a.m.";
my $slichos_erev_RH_sunday = "6:30$only";   # includes public holiday
my $slichos_erev_RH_weekday = "5:30$only";
my $slichos_erev_YK_weekday = "6:30" . $separator . "6:30" . $separator . "7:15";
my $slichos_erev_YK_sunday = "7:15" . $separator . "7:45" . $separator . "8:15";
my $slichos_sunday = "7:00" . $separator . "7:30" . $separator . "8:00";
my $slichos_public_holiday = "7:00" . $separator . "8:00";
my $slichos_before_RH = "6:15" . $separator . "6:25" . $separator . "7:00";
my $slichos_after_RH = "6:05" . $separator . "6:15" . $separator . "7:00"; # updated 2018


my $early_weekday_mincha = "8:15";
my $even_earlier_weekday_mincha = "6:00";
my $early_sunday_mincha_winter = "1:00";

my $early_shabbos_mincha = "6:00";
my $early_shabbos_mincha_difference = 30;   # minimum time between early Mincha and regular Mincha
my $early_shabbos_mincha_length = 30;       # length to allow for early Shabbos Mincha before Drasha;
                                            # was too short at 20, and want extra-long Kel Malei on Shabbos Shuva

# how long before sunset should Mincha on yom tov be?
my $yom_tov_mincha_length = 12;         # regular yom tov when there's no neilas hachag
                        #  This was originally set to 20 minutes before sunset, but in 5769 we realized it was way too early.
my $rosh_hashana_mincha_length = 25;    # it's longer than other holidays
my $shabbos_rh_mincha_length = 35;      # when Rosh HaShana is on Shabbos
my $friday_rh_mincha_length = 20;       # for Mincha before Plag (no Avinu Malkeinu anyway; don't want to have to wait for Kabbolas Shabbos)
my $neilas_hachag_mincha_length = 20;   # need time to wash and start eating neilas hachag
my $shabbos_no_ss_mincha_length = 25;   # for a Shabbos when there's no Shalosh Seudos, such as erev yom tov or the first day of yom tov
my $shabbos_no_ss_early_mincha = "2:30";    # early Mincha so people can eat SS at home afterward on erev yom tov or first day of YT (or erev Tisha b'Av?)
my $shemini_atzeres_mincha_earlier = 15;  # in 2015 moved Mincha earlier on Shemini Atzeres to allow more time for auction

my $shavuos_early_mincha = "6:00";	# added this in 2016

my $likras_shabbos_length = 30;


# Yom Tov times
my $mishnayos_time = "8:00";
my $yizkor_time = "9:30" . $separator . "10:30 (approx.)";    # for the 3 regalim, not Yom Kippur (first time is hashkama)
my $shavuos_learning_program = "11:45";
my $shofar = "10:40 (approx.)";		# changed to 11:00 by Rabbi Felder's request in 2015, then to 10:40 in 2019 (was 10:30 in 2018 by e-mail notice)
my $hamelech_RH = "8:35";  # for yamim noraim
my $hamelech_YK = "8:40";   # takes a bit longer on YK because start with Anim Zmiros
my $mincha_erev_YK = $BOLD . "3:00" . $separator . "3:30";
my $yizkor_YK = "11:30 (approx.)";

my $zachor_time_with_730 = "(approx.) 8:55" . $separator . "9:55" . $separator . "10:25" . $separator . "10:40" . $separator . "11:20";
my $zachor_time_without_730 = "(approx.) 9:55" . $separator . "10:20" . $separator . "10:25" . $separator . "11:20";
my $zachor_time_compromise = "(approx.) 9:55" . $separator . "10:25" . $separator . "10:40" . $separator . "11:20";
# my $zachor_time = $with_730 ? $zachor_time_with_730 : $zachor_time_without_730;
my $zachor_time = $zachor_time_compromise;
# my $zachor_time = "(approx.) 9:25" . $separator . "10:25" . $separator . "10:25" . $separator . "11:20";   # OLD VERSION TILL 5779: hashkama / YMM / main / afterwards

my $purim_mincha = $BOLD . "4:00" . $separator . "5:00";
my $purim_mincha_standard = "1:00" . $separator . $purim_mincha;
my $motz_purim_maariv = $BOLD . "8:45" . $separator . "9:30";

# minimum lengths before sunrise for Vasikin
my %vasikin_length = (
    "14,Adar" => 23,
    "14,Adar II" => 23,
    "21,Tishrei" => 34,  # long pesukei dezimra but no Nishmas (added 5 minutes in 2016)
    "23,Tishrei" => 35,  # in 2014 they said it was too early so adjusting in 2016 (delayed reaction, sorry)
    "6,Sivan" => 45,          # a bit more than Simchas Torah because have to say Brachos carefully
);

# Date in Nisan to start 8:30 Shacharis, based on Yeshiva Darchei Torah's Pesach Recess (per Aaron Wagschal's decision for 5774):
my %pesach_recess_start_date = (
	5774 => 9,
	5775 => 9,
	5776 => 11,
	5777 => 8,
	5778 => 11,
	5779 => 11,
  5780 => 8,
);

# siyum times for erev Pesach
# Why is it spelled with only one y, rather than siyyum?
my $siyum_shacharis = $isru_chag_shacharis;
my $siyum_shacharis_public_holiday = $siyum_shacharis;  # CHECK THIS for 2015!!!!!
###  Best way to list the siyum is "after each minyan" rather than a specific time!
my $siyum_time = "after each minyan";
## The originally stated times for the siyum are no longer used.
my $siyum_mon_thurs = $siyum_time;	# "7:25" . $separator . "8:15";
my $siyum_wed_fri = $siyum_time;	# "7:15" . $separator . "8:00";
my $siyum_public_holiday = $siyum_time;
			# "7:15" . $separator . "8:00" . $separator . "9:00";  # This was a problem in 2012; revisit for 2015!

# Just give a list of all entries that we ever print
# (i.e. anything that appears in the to_print structure
# for a given day).  The order in which they appear
# in this array is the order in which they will be printed.
# If any entry is missing from the array, we will produce an error.
my @print_order = (
"Fast begins",
"Earliest Tefillin",
"Slichos",
# "SpecialShabbos", # now inserted in prenotes
# Parasha is now inserted in prenotes
# "Parasha",
"Sunrise",
"Latest Sh'ma",
"Mishnayos",
"Chumash Shiur",
"Shacharis",
"***K'vasikin",  # this will indicate that a time listed above for Shacharis is k'vasikin
# See comment where I use this on purim.
"Megillas Esther ",
"Yeshivas Mordechai HaTzaddik",
"Siyum & Breakfast",
"HaMelech",
"Shofar",
"Zachor",
"Hataras Nedarim",
"May Eat Chometz Until",
"Burn Chometz Before",
"Dispose of Chometz Before",
"Chatzos",
"Yizkor",
"Sisterhood Tea",
"Avos UBanim ", # when it's Shabbos afternoon.  Extra space is similar to the Megillas Esther hack.
"Women's Avos",
"Sisterhood Shiur & Shalosh Seudos",
"Eiruv Tavshilin",
"Likras Shabbos for Boys", # this should sometimes be after Plag HaMincha - need to fix this
"Plag HaMincha",
"Drasha",
"Kol Nidrei",
"Shiurim",
"Navi Shiur",
"Tehillim", # for Rosh HaShana and Yom Kippur
"Candle Lighting",
"Mincha",
"Seuda Hamafsekes",
"Neilas Hachag",
"Fast begins at sunset",    # for erev Tisha B'av
"Sunset",
"Avos",
"Shiur",   # This used to be a Nach shiur until 5768, so references in the variable names and comments are still to Nach,
            # but the display is changed to Shiur in 5770.
"Candle Lighting $START_BOLD" . "after$END_BOLD",
"Motzoai Shabbos",
"Motzoai Shabbos & Y.T.",
"Motzoai Shabbos & Maariv",
"Motzoai Yom Tov",
"Motzoai Shabbos & Yom Kippur",
"Motzoai Yom Kippur",
"Maariv",
"Fast ends",
"Megillas Esther",
"Avos UBanim", # this is for when Avos UBanim is on Motzai Shabbos.
"Learning Program",
"Learning Program for Boys",
"Tickets",
"Teshuva Shiur",
);


main();

exit(0);

sub main
{
   my $hebcal_file = undef;

   while (my $opt = shift @ARGV) {
     if ($opt eq "-excel") {
       $output_excel = 1;
     }
     elsif ($opt eq "-csv") {
       $output_csv = 1;
     }
     elsif ($opt eq "-csvtable") {
       $output_csvtable = 1;
     }
     elsif ($opt eq "-ical") {
       $output_ical = 1;
     }
     elsif (!defined($hebcal_file)) {
       $hebcal_file = $opt;
     }
     else {
       croak "Unexpected option $opt\n";
     }
   }

   if (!($output_excel || $output_csv || $output_ical || $output_csvtable)) {
   	warn "No output format specified (-csv, -excel, -ical) so producing only .txt file for testing.\n";
#     croak "Must specify output format (-csv, -excel, -ical)\n";
   }


   if (!$hebcal_file)
   {
        $hebcal_file = $default_hebcal_file;
        warn "No file input argument supplied.\n".
                "Using default filename  $hebcal_file \n\n";
   }
   chomp $hebcal_file;

   read_basic_calendar($hebcal_file);
   print "Finished reading Hebcal info: $#list_of_days days found\n";
#   read_usno_data("usno_data_2010_2011.csv");
#   print "Finished reading USNO times for 2010-2011.\n";

   compute_sunrise_sunset();
   print "Finished calculating sunrise/sunset times\n";

   apply_basic_rules();
   print "Finished applying basic rules\n";
   apply_advanced_rules();
   prepare_print_order();

   foreach my $format (0,1)
   {
      my $thingy;
      $output_format_compact = $format;
      if ($output_format_compact)
      {
        next;  # AB This version is obsolete
         $thingy = ".csv";
      }
      else
      {
         $thingy = ".txt";
         print "Producing text file output.\n";
      }
      $output_filename = "sscm_" . $hebcal_file . $thingy;
      $output_filename =~ s/\.txt//;
      print "Dumping with output format $output_format_compact to $output_filename\n";
      dump_calendar();
   }

   if ($output_excel)
   {
        dump_excel_calendar();
        # warn "The following note needs to be inserted in every month from April through August:\n$kindly_note";
   }

   if ($output_ical)
   {
        dump_ical_calendar();
   }

   if ($output_csv)
   {
        dump_csv();
   }

   if ($output_csvtable)
   {
        dump_csvtable();
   }
}

sub read_basic_calendar($)
{
   my ($filename) = @_;
   open (IN, "<$filename") || croak "Error: Could not open $filename for read access\n";

   my $current_date_string = "open";
   my $current_date_info;

   # Make day 0 a fake day, so that we can return 0 for any undefined day.
   ### Actually we should return undef for any undefined day.
   ### But keeping 0 a fake day allows us to write if(idx) to check for a valid day,
   ### as the number 0 is considered false in a boolean context (as is the undef value).
   $current_date_info = {};
   push @list_of_days, $current_date_info;
   $current_date_info->{idx} = $#list_of_days;


   while (<IN>)
   {
      my $line = $_;
      chomp $line;
      if ($line =~ /(\d+)\/(\d+)\/(\d+)\s+(\S\S\S),\s+(\d+)[^\d\s]+\sof\s([^,]+),\s(\d+)\s*$/)
      {
         # Regular date line
         my $eng_mon = $1;
         my $eng_day = $2;
         my $eng_year = $3;
         my $day_of_week = $4;
         my $heb_day = $5;
         my $heb_mon = $6;
         my $heb_year = $7;
         my $munged_date = $eng_year . "," . $eng_mon . "," . $eng_day;

         $english_years{$eng_year} = 1;
         $hebrew_years{$heb_year} = 1;

         if ($munged_date ne $current_date_string)
         {
            $current_date_info = {};
            push @list_of_days, $current_date_info;
            # I store the index in case I'm passing
            # the reference around rather than the array.
            $current_date_info->{idx} = $#list_of_days;
            $current_date_string = $munged_date;
            $current_date_info->{Emon} = $eng_mon;
            $current_date_info->{Eday} = $eng_day;
            $current_date_info->{Eyear} = $eng_year;
            $current_date_info->{day_of_week} = $day_of_week;
            if ($eng_day == 1)
            {
               $index_of_first_day_of_the_month{"$eng_year,$eng_mon"} =
                  $#list_of_days;
            }
         }

         $current_date_info->{Hmon} = $heb_mon;
         $current_date_info->{Hday} = $heb_day;
         $current_date_info->{Hyear} = $heb_year;
         if ($heb_day == 1)
         {
            $index_of_first_day_of_the_hebrew_month{"$heb_year,$heb_mon"} =
               $#list_of_days;
         }
      }
      elsif ($line =~ /(\d+)\/(\d+)\/(\d+)\s+(\S\S\S),\s+Sunrise:\s+(\S+)\s+Sunset:\s+(\S+)\s*$/)
      {
         my $eng_mon = $1;
         my $eng_day = $2;
         my $eng_year = $3;
         my $day_of_week = $4;
         my $sunrise = $5;
         my $sunset = $6;
         my $munged_date = $eng_year . "," . $eng_mon . "," . $eng_day;

         if ($munged_date ne $current_date_string)
         {
            $current_date_info = {};
            push @list_of_days, $current_date_info;
            $current_date_info->{idx} = $#list_of_days;
            $current_date_string = $munged_date;
            $current_date_info->{Emon} = $eng_mon;
            $current_date_info->{Eday} = $eng_day;
            $current_date_info->{Eyear} = $eng_year;
            $current_date_info->{day_of_week} = $day_of_week;
            if ($eng_day == 1)
            {
               $index_of_first_day_of_the_month{"$eng_year,$eng_mon"} =
                  $#list_of_days;
            }
         }

         $current_date_info->{sunrise} = $sunrise;
         $current_date_info->{sunset} = $sunset;
      }
      elsif ($line =~ /(Candle lighting)|(Havdalah)/)
      {
         # I don't bother storing these, because I have
         # a rule to compute them based on sunset.
         ;
      }
      elsif ($line =~ /(\d+)\/(\d+)\/(\d+)\s+(\S\S\S),\s+(Parashat|Parshas)\s+(\S+.*)$/)
      {
         my $eng_mon = $1;
         my $eng_day = $2;
         my $eng_year = $3;
         my $day_of_week = $4;
         my $parasha = $6;
         my $munged_date = $eng_year . "," . $eng_mon . "," . $eng_day;

         if ($munged_date ne $current_date_string)
         {
            $current_date_info = {};
            push @list_of_days, $current_date_info;
            $current_date_info->{idx} = $#list_of_days;
            $current_date_string = $munged_date;
            $current_date_info->{Emon} = $eng_mon;
            $current_date_info->{Eday} = $eng_day;
            $current_date_info->{Eyear} = $eng_year;
            $current_date_info->{day_of_week} = $day_of_week;
            if ($eng_day == 1)
            {
               $index_of_first_day_of_the_month{"$eng_year,$eng_mon"} =
                  $#list_of_days;
            }
         }
         # bug in Hebcal's ashkenazi pronunciation:
         # the parasha name should be Tazria even though in context the phrase is "ki sazria"
         # just like there is a parasha named Pekudei when the phrase in context is "Eile fekudei"
         $parasha =~ s/Sazria/Tazria/;
         $parasha =~ s/Beshalach/Beshalach - Shira/;    # adding Shira starting for 5773
         $parasha = $parasha . $BOLD . $FONT14;
         $current_date_info->{parasha} = $parasha;
      }
      elsif ($line =~ /(\d+)\/(\d+)\/(\d+)\s+(\S\S\S),\s+Shabbos\s+(\S+.*)$/)
      {
         my $eng_mon = $1;
         my $eng_day = $2;
         my $eng_year = $3;
         my $day_of_week = $4;
         my $special_shabbos = $5;
         my $munged_date = $eng_year . "," . $eng_mon . "," . $eng_day;

         if ($special_shabbos =~ /Nachamu/i ||
             $special_shabbos =~ /HaGadol/i ||
             $special_shabbos =~ /Shuva/i ||
             $special_shabbos =~ /Hazon/i)
         {
            # I handle these explicitly in the code.
            next;
         }

         # The remaining ones are the 4 parshiyos (Shekalim etc.) and we will use these dates

         if ($munged_date ne $current_date_string)
         {
            $current_date_info = {};
            push @list_of_days, $current_date_info;
            $current_date_info->{idx} = $#list_of_days;
            $current_date_string = $munged_date;
            $current_date_info->{Emon} = $eng_mon;
            $current_date_info->{Eday} = $eng_day;
            $current_date_info->{Eyear} = $eng_year;
            $current_date_info->{day_of_week} = $day_of_week;
            if ($eng_day == 1)
            {
               $index_of_first_day_of_the_month{"$eng_year,$eng_mon"} =
                  $#list_of_days;
            }
         }

         $current_date_info->{special_shabbos} = $special_shabbos;
      }
      elsif ($line =~ /(\d+)\/(\d+)\/(\d+)\s+(\S\S\S),\s+(.*)$/)
      {
         # Just lump anything else into a special list,
         # and mark this day as special.
         my $eng_mon = $1;
         my $eng_day = $2;
         my $eng_year = $3;
         my $day_of_week = $4;
         my $extra_info = $5;
         my $munged_date = $eng_year . "," . $eng_mon . "," . $eng_day;
         if ($munged_date ne $current_date_string)
         {
            # No good reason to croak, but I don't like
            # copying the same code too many times.
            croak "Error: Special date info should always come after basic info: $munged_date\n";
         }
         if (!defined $current_date_info->{other_info})
         {
            $current_date_info->{other_info} = "";
         }
         $current_date_info->{other_info} =
            $current_date_info->{other_info} . ",$extra_info";

         # For now, I'm adding sunrise and sunset specially
         # on Yomim Tovim and fast days.
         # Don't need, since I added real date info.
         #if ($extra_info =~ /(Kippur|Hashana|Purim)/ ||
         #    $extra_info =~ /(Esther|Tzom|Asara|Tish\'a)/)
         #{
         #   $current_date_info->{incl_sun} = $1;
         #}
      }
   }
   close IN || croak "Error: Problem closing file $filename \n";
}

sub read_usno_data ($)
{
   # OBSOLETE.  We now calculate sunrise/sunset from scratch.
   # Read sunrise/sunset times from USNO, which may be more accurate.
   # Assumes a very specific format for each line:
   # Year,day of month, followed by sunrise,sunset for each month
   # from Jan to Dec.
   # To get this format, you need to import the USNO data into Excel and
   # massage it a bit, then dump as CSV file.

   my ($filename) = @_;
   open (IN, "<$filename") || croak "Error: Could not open $filename for read access\n";

   while (<IN>)
   {
      my $line = $_;
      chomp $line;
      my @data = split /,/, $line;

      my $year = shift @data;
      my $day_of_month = shift @data;

      my $imonth;

      for ($imonth = 1; $imonth <= 12; $imonth++)
      {
         my $sunrise = shift @data;
         my $sunset = shift @data;
         if ($sunrise eq "")
         {
            croak if $sunset ne "";
         }
         else
         {
            # Figure out the appropriate date index, and
            # convert the sunrise and sunset times.
            my $idx = $index_of_first_day_of_the_month{"$year,$imonth"};
            croak if (!defined($idx) || $idx <= 0);
            $idx += $day_of_month - 1;
            croak if ($idx <= 0 || $idx > $#list_of_days);

            my $day = $list_of_days[$idx];

            if ($sunrise =~ /^(\d+)(\d\d)$/)
            {
               my $hour = $1;
               my $minute = $2;
               if ($hour > 12)
               {
                    croak "Sunrise shouldn't be in the afternoon\n";
                    $hour -= 12;
               }
               my $time = "$hour:$minute";

               #my $prev_sunrise = get_sunrise($day);
               # Now adjust for daylight savings time if necessary.
               #  AMB changing this so it no longer depends on old (Hebcal) time
               if (is_during_DST($day))
               # I do this by adding 30 minutes, and seeing if I'm still
               # earlier than the known time.  If so, I need to add an
               # hour.
               #if (is_earlier(add_minutes($time,30),$prev_sunrise))
               {
                  $time = add_minutes($time,60);
               }
               # Fix single digit minutes.  Probably not really necessary
               # at this point, but what the hey.
               $time =~ s/:(\d[^\d])/:0$1/g;
               $time =~ s/:(\d)$/:0$1/;
               $day->{sunrise} = $time;
               #print "$year/$imonth/$day_of_month: $time\t$prev_sunrise\n";
            }
            else
            {
               croak "$sunrise not a recognized time in USNO data.\n";
            }

            if ($sunset =~ /^(\d+)(\d\d)$/)
            {
               my $hour = $1;
               my $minute = $2;
               if ($hour > 12)
               {
                    $hour -= 12;
               }
               my $time = "$hour:$minute";

               #my $prev_sunset = get_sunset($day);
               # Now adjust for daylight savings time if necessary.
               #  AMB changing this so it no longer depends on old (Hebcal) time
               if (is_during_DST($day))
               # I do this by adding 30 minutes, and seeing if I'm still
               # earlier than the known time.  If so, I need to add an
               # hour.
               #if (is_earlier(add_minutes($time,30),$prev_sunset))
               {
                  $time = add_minutes($time,60);
               }
               $time =~ s/:(\d[^\d])/:0$1/g;
               $time =~ s/:(\d)$/:0$1/;
               $day->{sunset} = $time;
               #print "$year/$imonth/$day_of_month: $time\t$prev_sunset\n";
            }
            else
            {
               croak "$sunset not a recognized time in USNO data.\n";
            }
         }
      }
   }
   close IN || croak "Error: Problem closing file $filename \n";
}


sub apply_basic_rules()
{
   # This is (I hope) the relatively simple part of the calendar
   # calculations.  I assume that every day is a normal day,
   # and figure out davening times.
   # For Shabbos, I figure out the Parsha, candle lighting,
   # Havdala, etc.

   my $mincha = "UNKNOWN";
   my $maariv = "UNKNOWN";

   # First, set up a hash of info to print for each day.
   foreach my $day (@list_of_days)
   {
      $day->{to_print} = {};
      # I never do this anymore, but just in case
      # I want to at some point.
      if (defined($day->{incl_sun}))
      {
         add_notes($day,"yom tov or fast or purim");
         $day->{to_print}->{Sunrise} = get_sunrise($day);
         $day->{to_print}->{Sunset} = get_sunset($day);
      }


#   }

#   foreach my $day (@list_of_days)
#   {
      if ($day->{idx} == 0)
      {
         next;
      }
      # First do Shacharis.  It's pretty easy, because it just
      # depends on the day of the week.
      my $shacharis = $shacharis_time{$day->{day_of_week}};
      $day->{to_print}->{Shacharis} = $shacharis;

      # print tefillin times if Shacharis is too early; may have to run this again later on Rosh Chodesh
      check_tefillin_time($day, 0);

      # Next mincha.
      if ($day->{day_of_week} eq "Fri")
      {
         $mincha = get_friday_mincha($day, 0);
      }
      elsif ($day->{day_of_week} eq "Sat")
      {
         $mincha = get_shabbos_mincha($day);
      }
      # Could be open if this is the first day in our list.
      ### But if the list starts in the middle of the week we cannot schedule Mincha for that week
      elsif (   ## $mincha eq "open" ||
                $day->{day_of_week} eq "Sun")
      {
#         $mincha = get_normal_mincha($day);
#         $maariv = get_normal_maariv($day, $mincha);
         ($mincha, $maariv) = set_mincha_maariv_for_week($day);
      }
      elsif ($mincha eq "UNKNOWN")
      {
            warn "Mincha and Maariv not scheduled for partial week, including " . print_date($day) . "\n";
      }

      $day->{to_print}->{Mincha} = $mincha;

      if ($day->{day_of_week} eq "Sun" && !is_during_DST($day))
      {
      	$day->{to_print}->{Mincha} = $early_sunday_mincha_winter . $separator . $mincha;
      }

      # Maariv.  We appear to print a Maariv time only on weekdays.
      if ($day->{day_of_week} ne "Fri" &&
          $day->{day_of_week} ne "Sat")
      {
         $day->{to_print}->{Maariv} = $maariv;

         if ($day->{day_of_week} eq "Thu")
         {
            # Several years ago this was on Wednesdays.
            # Tehillim re-instituted in summer 2011 in Thursdays
            # but then it was moved to Sunday morning; no point trying to predict it for the whole year
#            add_notes($day, "Tehillim after late Maariv");
         }
      }

      # Handle typical Friday.
      if ($day->{day_of_week} eq "Fri")
      {
         my $sunset = get_sunset($day);
         my $sunrise = get_sunrise($day);
         $day->{to_print}->{"Candle Lighting"} = subtract_minutes($sunset,18);
         # Add an asterisk when mincha is early.
         if ($mincha =~ /7:15|\/|$separator/)
         {
            $day->{to_print}->{"Candle Lighting"} =
               $day->{to_print}->{"Candle Lighting"} . "**";
         }

         $day->{to_print}->{Sunset} = $sunset;
         $day->{to_print}->{"Plag HaMincha"} = compute_plag($sunrise,$sunset);
	if (! ($day->{Emon} == "8"))	# doesn't run in August
	{
#		$day ->{to_print}->{"Likras Shabbos for Boys"} = subtract_minutes($mincha, $likras_shabbos_length);
			# Likras Shabbos will count from early Mincha when there is one,
			# but we will also need to make adjustments for special days.
      ##### Likras Shabbos is NO LONGER RUNNING as of 2019.
	}

	## Friday night learning program for boys grades 6 through high school
	if (!is_during_DST($day))
	{
		$day->{to_print}->{"Learning Program for Boys"} = "8:30-9:30";
	}
      }

      # Handle typical Shabbos
      if ($day->{day_of_week} eq "Sat")
      {
         my $sunrise = get_sunrise($day);
         my $sunset = get_sunset($day);
         $day->{to_print}->{Sunrise} = $sunrise;
         $day->{to_print}->{Sunset} = $sunset;

         $day->{to_print}->{"Latest Sh'ma"} = compute_shma($sunrise,$sunset);
         $day->{to_print}->{"Chumash Shiur"} = $chumash_shiur;
         # Make sure to reschedule (or cancel) the Chumash Shiur any time Shacharis is rescheduled!

#         if (!$renovation)   ## In fact this is unchanged by the renovation
#         {
            # Shiur is never earlier than 3:40.
            my $shiurim = subtract_minutes($day->{to_print}->{Mincha},60);
            if (is_earlier($shiurim,"3:40"))
            {
                $shiurim = "3:40";
            }
            $day->{to_print}->{Shiurim} = $shiurim;
#         }

	#  Navi shiur started in summer 5774.  Adding in calendar for 5775:
            if (!yom_tov_season($day))
            {
            	my $navi = subtract_minutes($day->{to_print}->{Mincha}, get_Navi_length($day));
            	if (is_earlier($navi,"3:40"))
            	{
            	    $navi = "3:40";
            	}
            	$day->{to_print}->{"Navi Shiur"} = $navi;
            }

         if ($renovation)   ## No Shalosh Seudos during winter 5769 because of renovation, so Mincha has to be adjusted
         {
            my $hyear = $day->{Hyear};
            my $heb_month = $day->{Hmon};
            my $hday = $day->{Hday};
            my $hmon_idx = $hebrew_month_index{$heb_month};
            if ($hyear == 5769 && ($hmon_idx <7 || ($hmon_idx == 7 && $hday <22) ))
            {
                $mincha = subtract_minutes($mincha,5);
                $day->{to_print}->{Mincha} = $mincha;
                my $shiurim = subtract_minutes($mincha,60);
                if (is_earlier($shiurim,"3:40"))
                {
                    $shiurim = "3:40";
                }
                $day->{to_print}->{Shiurim} = $shiurim;
            }
            if ($hyear == 5768 && $hmon_idx == 12)
            {
                if ($hday == 20)
                {
                    $mincha = $BOLD. "5:30/6:55";
                    $shiurim = "5:50";
                }
                elsif ($hday == 27)
                {
                    $mincha = $BOLD. "5:30/6:45";
                    $shiurim = "5:50";
                }
                $day->{to_print}->{Mincha} = $mincha;
                $day->{to_print}->{Shiurim} = $shiurim;
            }

         }

         {

            if (during_avos_season($day))
            {
                my $avos = add_minutes($day->{to_print}->{Mincha},60);
                $day->{to_print}->{Avos} = $avos;

                ## Women's shiur started in 2011.
                #  For 2012, we scheduled it manually, but also included the Perek number.
                #  Now doing it programmatically starting for 5773.  Need to figure out how to program the perek number.
                #$day->{to_print}->{"Women's Avos"} = $womens_avos;
                #### This is done now in a separate routine handle_pirkei_avos()
            }
            elsif (!$renovation)   # No Nach shiur during winter 5769 because no Shalosh Seudos in shul
            {
                # Cancel Avos during Elul (not any more), before Succos,
                # and after Pesach.
                my $heb_month = $day->{Hmon};
                my $hday = $day->{Hday};
                my $hmon_idx = $hebrew_month_index{$heb_month};
                if ($hmon_idx == 12 ||
                    ($hmon_idx == 1 && $hday <= 22) ||
                    ($hmon_idx == 7 && $hday >= 14) )
                {
                    # No nach shiur
                    ;
                }
                else
                {
                    # TODO: Note that I still need to cancel on
                    # special shabbosim.
                    my $nach = add_minutes($day->{to_print}->{Mincha},60);
                    $day->{to_print}->{Shiur} = $nach;
                }
            }
         }

         ## Adding early Mincha for summer months.
         add_early_shabbos_mincha_if_applicable($day);



         # Motzai Shabbos is always 45 minutes after sunset.
#         my $sunset = get_sunset($day);
         my $motz = add_minutes($sunset,45);
         $day->{to_print}->{"Motzoai Shabbos"} = $motz;

         if (!$renovation)   ## Once the renovation is over we will have to determine a new schedule for Avos UBanim.
         {
#            if (($day->{Emon} == 11 && $day->{Eday} >= 7) ||     # first possible date for Saturday after clock change
#                 $day->{Emon} == 12  ||
#                 $day->{Emon} <  3   ||
#                ($day->{Emon} == 3 && $day->{Eday} < 14))        # until March clock change
            if (!is_during_DST($day))
            {
                # From e-mails with Elli Schochet in 2011, settled on always at least one hour after the end of Shabbos
                # But then after the season ended in 2012 he said it should be discontinued when the start time would get later than 7:45.
                # Then in 2013 decided that latest start time should be 7:30.
		# Then in 2014 it continued all the way to the clock change, and Ittamar gave me the times for 2015
		# In 2017 Elli Schochet said "Avos Ubanim should stop once Shabbos comes out past 6:30."
		#  I think that means we're reverting to the rules from 2013.

      #my $aub_start = is_earlier($motz, "6:01") ?
		#				"7:00" :
		#			is_earlier ($motz, "6:11") ?
		#				"7:15" :
		#				"7:30";
		##  Notice that Shabbos may end as late as 7:06 on the eve of the clock change - will AUB still start 7:30?
      #if (is_earlier ("7:00", $motz))
		#{
		#	warn "Check Avos UBanim on " . print_date ($day) . " less than half an hour after Motzoai Shabbos.\n";
		#}

		# RULES FROM 2013, sort of:
                my $aub_start = add_minutes (round_up_to_n_minutes ($motz, 15), 60);
                if (is_earlier($aub_start, "7:00"))
                {
                    $aub_start = "7:00";
                }

                my $aub_end = add_minutes ($aub_start, 60);
                if (is_earlier($aub_start, "7:31"))
                {
                    $day->{to_print}->{"Avos UBanim"} = $aub_start . "-" . $aub_end;
                }

                # OLD RULES UNTIL 2011 (sort of - weren't exactly followed)
                ## It should start no sooner than 45 minutes after shabbos
                #if (is_earlier($motz,"6:16"))
                #{
                #    $day->{to_print}->{"Avos UBanim"} = "7:00-8:00";
                #}
                #elsif (is_earlier($motz,"6:31"))
                #{
                #    $day->{to_print}->{"Avos UBanim"} = "7:15-8:15";
                #}
                #elsif (is_earlier($motz,"6:46"))
                #{
                #    $day->{to_print}->{"Avos UBanim"} = "7:30-8:30";
                #}
                #else
                #{
                #    # Never start later than 7:30
                #    # $day->{to_print}->{"Avos UBanim"} = "7:45";
                #}
            }

		###  DAYTIME AVOS UBANIM IN SUMMER MONTHS
            # It will not continue in Spring 2012.
            # Started again in summer 2013.  Rule for 2014 is from after Shavuos until Shabbos Chazon.

		# For 2015, Ittamar said "starting May 30 until and including Aug. 1 no breaks".
		#  I'll program this from Shavuos to Shabbos Nachamu, and we can reevaluate next year.
		#  Also, it's been starting at 5:00, not 5:15.

            # Decide on correct conditions here!  Some possibilities are:
            if (between_shavuos_and_nachamu($day))  # possible induction from 5775 dates
            # if (between_shavuos_and_chazon($day))  # new rule for 5774
            # elsif ($day->{Emon} =~ /[56]/)
            # elsif (between_pesach_and_elul($day) || between_shavuos_and_rosh_hashana($day))  # neat hack!
            # elsif (between_pesach_and_august($day))     # From after Pesach until the end of August
            # elsif ($day->{Hyear}%10 == $day->{Eyear}%10)    # neat way to say until Rosh HaShana
            # if (between_shavuos_and_rosh_hashana($day))  # this was the old rule from 5767
            {
#                if (!defined($early_mincha))
                if ($day->{to_print}->{Mincha} !~ /\/|$separator/)
                {
                    croak "Need to program Avos UBanim when there is no early Mincha!\n";
                }
                $day->{to_print}->{"Avos UBanim "} = "5:00-6:00";
#                $day->{to_print}->{"Avos UBanim "} = subtract_minutes($early_mincha,60);
#                if (is_earlier($shiurim,"6:15"))
#                {
#                    $day->{to_print}->{"Avos UBanim "} = "5:00"; # Will this interfere with early Mincha?
#                }
#                else
#                {
#                    $day->{to_print}->{"Avos UBanim "} = "5:15";
#                }
            }
         }

         ## If it is one of the 4 parshiyos (Shekalim, etc.) we want to combine this with the parasha as one entry in the prenotes.
         #  These used to be separate, but the words are short and take up too many lines, especially around Purim when March is crowded.
         my $special_shabbos = $day->{special_shabbos};
         my $parasha = $day->{parasha};

         if (defined($special_shabbos))
         {
            if (!defined($parasha))
            {
                croak "Can't have a special Shabbos (maftir) with no parasha!\n";
            }
            $parasha .= " - $special_shabbos";

            # No longer using ->{to_print}->{SpecialShabbos} because we need this in the prenotes,
            # so that it appears before Birkas HaChodesh
            #$day->{to_print}->{SpecialShabbos} = $special_shabbos;
            #add_prenotes($day, $BOLD . $special_shabbos);
            if ($special_shabbos =~ /Zachor/)
            {
                $day->{to_print}->{Zachor} = $zachor_time;
            }
         }

         # Dump the parasha, if available.
         if (defined($parasha))
         {
            # This means that ->{to_print}->{Parasha} is no longer used!
#            $day->{to_print}->{Parasha} = $day->{parasha};
            add_prenotes($day, $parasha);    # Now this will include the Special Shabbos listing (maftir)
         }
         else
         {
            # I no longer print anything if there's no clear Parasha.
            # $day->{to_print}->{Parasha} = "NO PARASHA (PROBABLY A YOM TOV)";
         }


      }
   }
}

sub add_early_shabbos_mincha_if_applicable($)
{
    #### Moving this into a separate subroutine so that it can be called again if Mincha is rescheduled, such as on erev Tisha B'Av
    my ($day) = @_;

    ## Adding early Mincha for summer months.
    ## It has to be done after calculating shiurim.
    ## See whether this crashes anything else.

    ## early Mincha always at 6:00, provided this is at least 30 minutes before the main Mincha,
    ## otherwise it doesn't exist.
    ## Note we will have to schedule this separately for the Drasha days.
    if (!is_earlier(subtract_minutes($day->{to_print}->{Mincha}, $early_shabbos_mincha_difference), $early_shabbos_mincha))
    # if (!is_earlier(subtract_minutes($day->{to_print}->{Shiurim}, $early_shabbos_mincha_length), $early_shabbos_mincha))
    {
        $day->{to_print}->{Mincha} = $early_shabbos_mincha . $separator . $day->{to_print}->{Mincha};
    }

#         my $early_mincha;
#         if (between_pesach_and_elul($day) || between_shavuos_and_rosh_hashana($day))  # neat hack!
#         {
#            $early_mincha = subtract_minutes($day->{to_print}->{Shiurim}, $early_shabbos_mincha_length);
#            if (is_earlier($early_shabbos_mincha, $early_mincha))
#            {
#                $early_mincha = $early_shabbos_mincha;
#            }
#            $day->{to_print}->{Mincha} = "$early_mincha/$day->{to_print}->{Mincha}";
#         }


}


sub apply_advanced_rules()
{
   # modified by Ari on Friday, 26 Av, 5767:

   # There's a problem whenever a particular calendar day contains two (or more) events that prescribe conflicting rules for davening times.
   # One solution would be to include explicit condition-checking in every case.
   # But the easier solution is to ensure that the events are handled in the correct sequence, so that the LAST rule applied is the correct one.

   handle_chanukah();

   # Rosh Chodesh must be handled AFTER Chanukka, so that the Shacharis time on Rosh Chodesh Tevet ends up being the Rosh Chodesh time.
   modify_rosh_chodesh();  # Includes Birkas HaChodesh (AB)

   # Public holidays must be handled after Chanukka, Rosh Chodesh (and fast days - not any more),
   # so that the public holiday Shacharis time overrides the other Shacharis times.
   # (Actually it doesn't matter any more because those special days check for sunday_shacharis time rather than day of the week.)
   #  Yes it does matter now again because public holiday times are NOT the same as Sunday times! (2012)
   modify_public_holidays();

   # Most other events are correctly handled after public holidays,
   # either because they correctly override the public holiday time (such as yamim tovim)
   # or because they explicitly handle interaction with Sundays and public holidays as a special case (Slichos and Purim),
   # or because they can never fall on a public holiday (Tisha B'Av - never on a Monday, and never as early as July 1).
   # Chol HaMoed should logically be handled before public holidays,
   # but it's part of the yom tov routines and you already correctly check for public holidays in the Chol HaMoed code so it's fine.
   # I see you correctly included a warning for when Erev Pesach falls on Good Friday
   # (next in 2012, hasn't happened since 1998 so I don't know the precedent).

   # Fast days now correctly handle public holidays by checking for sunday_shacharis time rather than day of the week,
   # so we handle fast days after public holidays
   handle_fast_days();

   # Pesach routine also handles Omer, including Lag B'omer.  # I corrected a spelling error in this comment.
   handle_pesach();
   handle_shavuos();
   handle_succos();

   # Slichos must be handled AFTER fast days, otherwise Tzom Gedalia gets messed up.
   handle_rosh_hashana_and_slichos();
   handle_yom_kippur();

   # Purim must be handled after fast days so that Maariv time is correct (although maybe reevaluate Maariv for fast days in general?)
   handle_purim();
   handle_tisha_bav();
   # Lists Yahrzeits of 2 former rabbis, Tu Bishvat,
   # Pesach Sheni, Lag B'Omer, Tu B'Av.
   # and a few other things - see the comments in the function. (AB)
   list_misc_days();
   list_vsain_tal_umotor();  # AB did this.
   list_clock_change_days(); # List it on the Saturday night. # AB did this.
   birkat_hachamma();        # AB did this.
   handle_kiddush_levana(); # Ari can do this if he wants (done!)
   handle_pirkei_avos();    # to list the perek number each week; currently applies to the women's shiur

   apply_special_quirks();
}


sub prepare_print_order()
{
    #  This prepares the data for output, including setting up the print order within in day's cell.
    #  This data is used both for the text output and the Excel output, but the algorithm only needs to run once.
    #  Previously, this algorithm was copied into both dump_calendar() and dump_excel_calendar().
    #  Now it is separated and called from main() before calling dump_calendar().

    #  Maybe %print_order_hash should be a global variable, since @print_order is global already.
   my %print_order_hash;
   my $i;
   for ($i = 0; $i <= $#print_order; $i++)
   {
      if (defined ($print_order_hash{$print_order[$i]}))
      {
         croak "Error: " . $print_order[$i] . " is defined twice in print_order array\n";
      }
      $print_order_hash{$print_order[$i]} = $i;
   }
   foreach my $day (@list_of_days)
   {
      my $idx = $day->{idx};
      if ($idx == 0)
      {
         next;
      }

      my $main_mincha = $day->{main_mincha};
      if (defined($main_mincha))     ## This is never yet defined but eventually we hope to recode some sections to use it
      {
            $day->{to_print}->{Mincha} =
                    defined($day->{early_mincha}) ?
                        $day->{early_mincha} . $separator . $main_mincha :
                        $main_mincha;
      }

      foreach my $item (keys(%{$day->{to_print}}))
      {
         defined ($print_order_hash{$item}) ||
                croak "Unknown item: $item \n";
      }

      my @print_list = sort {$print_order_hash{$a} <=> $print_order_hash{$b}; }
                            (keys (%{$day->{to_print}}));


      # There are two things that can get messed up in this ordering:
      #
      # Mincha, which is sometimes before and sometimes after Candle
      # Lighting and/or Plag.  On Yom Kippur, it is also before Kol
      # Nidrei.  I rely on the fact that on any day where Mincha
      # moves around, there is a candle lighting.  NOT ANY MORE - it might move before Shiurim on Shabbos afternoon.
      #
      # The other exception is Slichos at 1:00 a.m.,
      # which is at the end of Saturday,
      # but at the beginning of Sunday.  I handle that in
      # the actual dumping.
      my $i;
      for ($i = $#print_list; $i >= 0; $i--)
      {
         if ($print_list[$i] eq "Mincha" &&
             $day->{to_print}->{Mincha} # &&
             # $day->{to_print}->{"Candle Lighting"}
             )
         {
            if ($i > 0 &&
                  $print_list[$i-1] eq "Candle Lighting" ||
                  $print_list[$i-1] eq "Plag HaMincha" ||
                  $print_list[$i-1] eq "Kol Nidrei"   ||
                  $print_list[$i-1] eq "Shiurim"     ||
                  $print_list[$i-1] eq "Navi Shiur"     ||
                  $print_list[$i-1] eq "Drasha")
            {
               my $cl_string = $print_list[$i-1];
               my $mincha = $day->{to_print}->{Mincha};
               my $cl = $day->{to_print}->{$cl_string};
               if (!$cl)
               {
                  # Nothing defined for this item.  Just swap
                  # them, since it shouldn't make a difference.
                  $print_list[$i] = $cl_string;
                  $print_list[$i-1] = "Mincha";
               }
               elsif (is_earlier($mincha,$cl))
               {
                  $print_list[$i] = $cl_string;
                  $print_list[$i-1] = "Mincha";
               }
            }
         }
      }

      if (defined($day->{to_print}->{"Kol Nidrei"}))
      {
            for ($i = $#print_list; $i >= 0; $i--)
            {
                if ($print_list[$i] eq "Candle Lighting" &&
                        $i > 0 &&
                        $print_list[$i-1] eq "Kol Nidrei" &&
                        is_earlier($day->{to_print}->{"Candle Lighting"}, $day->{to_print}->{"Kol Nidrei"}))
                {
                        $print_list[$i] = "Kol Nidrei";
                        $print_list[$i-1] = "Candle Lighting";
                }
            }
      }

      if (defined($day->{to_print}->{Slichos}) &&
          $day->{to_print}->{Slichos} eq "1:00 a.m." &&
          $day->{day_of_week} eq "Sat")
      {
         # Then Slichos gets printed at the end of the day.
         my $first_item = shift @print_list;
         if ($first_item ne "Slichos")
         {
            print "$first_item\n";
            croak "Oops, shift didn't work, or Slichos isn't first item in list.\n";
         }
         push @print_list, "Slichos";
      }

      $print_data_for_day[$idx] = [];

      # Print out any comments that are supposed to precede
      # other times.
      if (defined ($day->{prenotes}))
      {
         my @notes = split /,/, $day->{prenotes};
         foreach my $note (@notes)
         {
            push @{$print_data_for_day[$idx]}, $note;
         }
      }


      foreach my $item (@print_list)
      {
         if (!defined($print_order_hash{$item}))
         {
            croak "Error: Couldn't find $item in print order!\n";
         }
         my $time = $day->{to_print}->{$item};
         # We may have created and then deleted this item,
         # so check that it's still defined
         ### Well, we should have deleted it properly, not just undefined its value!
         if (!defined($time))
         {
            croak "should have deleted hash element rather than set to undef: " .print_date($day).$item."!\n";
         }

         {
            # Usually print a space between the item name (title) and the time
            # This will be false if there is no title or there is no time.
            my $need_space = 1;

            my $string_to_print = "";

            # Start by adding codes for this item as appropriate.
            my $codes = $special_functions_map{$item};
            if (defined ($codes))
            {
                $string_to_print .= $codes;
            }

            if ($string_to_print =~ s/$NOTITLE//g)
            {
               # Don't insert whitespace before the value.
               $need_space = 0;
            }
            elsif ($bold_everything_in_ical) {
               # Just use html bold tags.  We'll remove all of the other
               # formatting tags when we're ready to print to ical.
               $string_to_print = $string_to_print . "<b>$item</b>";
            }
            else
            {
               # Start off with the item's name.
               $string_to_print = $string_to_print . $item;
            }


            # Make sure that if there are minutes, they are
            # two digits long.  The first version misses
            # the case where the time is the end of the line.
            #
            # Also, delete any decimal number of minutes, which
            # occasionally happens when I use precise shaot
            # zmaniot.
            if ($time ne $NOTIME)
            {
               $time = clean_time($time);

               if ($need_space)
               {
                    $string_to_print .= " ";
               }

               $string_to_print .= $time;
            }


            # Stick a bullet in front of each entry.
            # If the category or the particular item do not
            # want a bullet, don't put one.
            if ($string_to_print =~ s/$NOBULLET//g)
            {
               # Don't make any changes.
               ;
            }
            else
            {
               $string_to_print = $bullet . $string_to_print;
            }
            push @{$print_data_for_day[$idx]}, $string_to_print;
         }
      }

      if (defined ($day->{comments}))
      {
         my @notes = split /,/, $day->{comments};
         foreach my $note (@notes)
         {
            push @{$print_data_for_day[$idx]}, $note;
         }
      }
   }
}

sub dump_csvtable()
{
   for my $cal ("weekday", "shabbos", "friday") {
      warn "Producing .csv file output in table format .\n";
      my $print_weekday = $cal eq "weekday";
      my $print_friday = $cal eq "friday";
      my $print_saturday = $cal eq "shabbos";
      $output_filename = "sscm_calendar_table_$cal.csv";
      open (UTFOUT, ">$output_filename") || croak "Error: couldn't open $output_filename\n";
      # Michael Mann wants the date in Hebrew
      binmode(UTFOUT, ":utf8");

      my @weekday_headings = ("Shacharis", "Mincha", "Maariv");
      my @shabbos_headings = ("Chumash Shiur", "Shacharis", "Shiurim", "Mincha",
        "Shiur", "Motzoai Shabbos");
      my @friday_headings = ("Shacharis", # "Likras Shabbos for Boys",
        "Plag HaMincha", "Candle Lighting", "Mincha", "Sunset", "Learning Program for Boys");
      my @headings = $print_weekday ? @weekday_headings :
                     $print_friday ? @friday_headings :
                     @shabbos_headings;
      # Header
      print UTFOUT "Date";
      for my $h (@headings) {
        print UTFOUT ",$h";
      }
      print UTFOUT "\n";

      foreach my $day (@list_of_days)
      {
         my $idx = $day->{idx};
         if ($idx == 0)
         {
            next;
         }

         # FIX THIS - NEED TO SET THE MONTHS TO OUTPUT - should probably be the same as used for the Excel output
         if ($idx < index_of_date($curr_year,9,1) || $idx > index_of_date($next_year,10,31))
         {
               next;
         }

         if ($day->{day_of_week} eq "Fri") {
           if (!$print_friday) {
            next;
          }
         }
         elsif ($day->{day_of_week} eq "Sat") {
          if (!$print_saturday) {
            next;
          }
         }
         elsif (!$print_weekday) {
           next;
         }

         my $eng_date = $day->{Eyear} . "/" . $day->{Emon} . "/" . $day->{Eday};

         print UTFOUT "$eng_date";

         for my $h (@headings) {
           my $rawtime = $day->{to_print}->{$h};
           if (defined($rawtime)) {
             $rawtime = clean_time($rawtime);

             my ($time, $bold, $italic, $partial_bold, $size)  = identify_special_codes($rawtime);

             $time =~ s/$START_BOLD/<b>/g;
             $time =~ s/$END_BOLD/<\/b>/g;
             if ($bold) {
               $time = "<b>$time</b>";
             }
             if ($italic) {
               $time = "<em>$time</em>";
             }

             print UTFOUT ",$time";
           }
           else {
             print UTFOUT ",";
           }
         }
         print UTFOUT "\n";
      }
   }
}


sub dump_csv()
{
   # Dump calendar as csv with specs from website guy Michael Mann (as amended from trials with Raffaele Care).
   # Remind them that the data must be imported with the following settings:
   #    Record separator:   Newline
   #    Field separator:    Pipe (|)
   #    Text delimiter:     None
   #    Escape character:   None
   warn "Producing .csv file output; tell them the fields are pipe-separated with no text delimiter.\n";
   $output_filename = "sscm_calendar.csv";
   open (UTFOUT, ">$output_filename") || croak "Error: couldn't open $output_filename\n";
   # Michael Mann wants the date in Hebrew
   binmode(UTFOUT, ":utf8");

   # Header
   print UTFOUT "Event Name|Gregorian Calendar Date|Event Times|Event Order\n";

   foreach my $day (@list_of_days)
   {
      my $idx = $day->{idx};
      if ($idx == 0)
      {
         next;
      }

        # FIX THIS - NEED TO SET THE MONTHS TO OUTPUT - should probably be the same as used for the Excel output
      if ($idx < index_of_date($curr_year,9,1) || $idx > index_of_date($next_year,10,31))
      {
            next;
      }

      my $heb_date = $day->{Hday} . " - " . get_output_month_name($day->{Hmon}) . ", " . $day->{Hyear};
      my $eng_date = $day->{Eday} . "/" . $day->{Emon} . "/" . $day->{Eyear};
      my $heb_date_in_hebrew = convert_number_to_hebrew($day->{Hday}, undef) . " " .
                $hebrew_month_unicode{$day->{Hmon}} . " " .
                            get_hebrew_year_string($day);

      # For some reason, the ' character wants to be after the letter,
      # but my thingy has it before.
      #### This shouldn't be a problem any more now that convert_number_to_hebrew() uses $geresh rather than '
      # $heb_date_in_hebrew =~ s/\'(\S)/$1\'/;
      # Print basic date info.
      print UTFOUT "$heb_date_in_hebrew|$eng_date||0\n";
      print UTFOUT "$heb_date|$eng_date||1\n";

      my $item;

      # The date was event 1, so start with event order 2.
      my $event_order = 2;
      foreach $item (@{$print_data_for_day[$idx]})
      {

           # Perl gives a warning when printing a bullet to the text file, so just replace it with a space
           # Declare a new variable so that it doesn't change the original value in the print_data_for_day array
           my $item_to_print = get_text_safe($item);

           # Remove all the bolding and such.  For now, don't
           # do anything with the information.
           my ($newitem, $bold, $italic, $partial_bold, $size) = identify_special_codes($item_to_print);

           # The above doesn't remove partial bolds, so do that manually.
           $newitem =~ s/$START_BOLD//g;
           $newitem =~ s/$END_BOLD//g;

           # He wants the item description and time in separate
           # columns.  Not sure why, but I'll just do it by
           # finding the first time-ish string.  This is a pretty
           # weird way to do it, I admit.
           my $desc = $newitem;
           my $time = "";
           while ($desc =~ /^\s*(.*[^\d])(\d+:\d+.*)$/)
           {
                $desc = $1;
                $time = $2 . $time;
           }

           # Remove leading and lagging whitespace.
           $time =~ s/^\s//g;
           $desc =~ s/^\s//g;
           $time =~ s/\s$//g;
           $desc =~ s/\s$//g;


           # If $desc contains a comma, this will mess up the csv delimiters so we would need to quote the field.
           # But we can't just add quotes, in case the $desc itself contains quotes (such as zt"l).
           # There are no commas anyway in the text we use here.
           #    SINCE WE'RE USING PIPE AS THE FIELD SEPARATOR, AND NO TEXT DELIMITER, THIS DOESN'T MATTER ANY MORE.

           #if ($desc =~ /,/)
           #{
           #     croak "Can't have comma in event description field when outputing csv file - need to escape it somehow.\n";
           #}

           # Need to escape quotes such as in zt"l  - NOT ANY MORE
           #$desc =~ s/\"/\\\"/g;



#           if ($desc =~ /\"/)
#           {
#              # Try single quotes.
#          croak if ($desc =~ /\'/);
#              $desc = "'$desc'";
#           }
#           else
#           {
#              $desc = "\"$desc\"";
#           }

           if ($desc ne "")     # the blank lines mess up the importing
           {
                print UTFOUT "$desc|$eng_date|$time|$event_order\n";
           }
           $event_order++;
      }
   }

   print UTFOUT "\n";
   close UTFOUT or croak "Error: Problem closing file $output_filename \n";
}


sub dump_calendar()
{

   open (OUT, ">$output_filename") || croak "Error: couldn't open $output_filename\n";

   foreach my $day (@list_of_days)
   {
      my $idx = $day->{idx};
      if ($idx == 0)
      {
         next;
      }

      # For readability, put in an extra line
      # at the start of each week.
      # AB updated comment to reflect code change
      if ($day->{day_of_week} eq "Sun")
      {
         print OUT "\n";
      }


      # Print basic date info.
      print OUT $day->{day_of_week} . ",";
      print OUT $day->{Eday} . ",";
      print OUT $day->{Emon} . ",";
      print OUT $day->{Eyear} . ",";
      print OUT $day->{Hday} . ",";
      print OUT get_output_month_name($day->{Hmon}) . ",";
      print OUT $day->{Hyear} . ",";

      # AB added
      if (!$output_format_compact)
      {
         print OUT "\n";
      }

      my $item;

      foreach $item (@{$print_data_for_day[$idx]})
      {

               # Perl gives a warning when printing a bullet to the text file, so just replace it with a space
               # Declare a new variable so that it doesn't change the original value in the print_data_for_day array
               my $item_to_print = get_text_safe($item);

               # AB modified
               if ($output_format_compact)
               {
                  print OUT $item_to_print . ",";
               }
               else
               {
                  print OUT $item_to_print . "\n";
               }
      }

      if ($debug_info)
      {
         print OUT "Sunrise," . get_sunrise($day) . ",";
         print OUT "Sunset," . get_sunset($day) . ",";
      }

      print OUT "\n";

   }
   close OUT || croak "Error: Problem closing file $output_filename \n";
}


sub get_text_safe($)
{
        my ($item) = @_;
        # Perl gives a warning when printing a bullet to the text file, so just replace it with a $text_bullet ("middle dot")
        # make sure this copy is returned into a new variable so that it doesn't change the original value in the print_data_for_day array
        $item =~ s/$bullet/$text_bullet/;
        return $item;
}



sub dump_ical_calendar()
{

   my $ical_filename = "sscm_calendar.ics";
#   $ical_filename =~ s/\.txt/\.ics/;
   print "Producing ical file output to $ical_filename\n";

   open (ICAL, ">$ical_filename") || croak "Error: couldn't open $ical_filename\n";
   binmode(ICAL, ":utf8");

   my $crlf = "\n"; # "\015\012";
   print ICAL "BEGIN:VCALENDAR$crlf";
   print ICAL "VERSION:2.0$crlf";
   print ICAL "PRODID:SSCMCAL$crlf";
   my $print_ical = 1;
   foreach my $day (@list_of_days)
   {
      my $idx = $day->{idx};
      if ($idx == 0)
      {
         next;
      }

      my $year = $day->{Eyear};
      my $imonth = $day->{Emon};
      my $iday = $day->{Eday};
      if ($imonth =~ /^\d$/)
      {
         $imonth = "0" . $imonth;
      }
      if ($iday =~ /^\d$/)
      {
         $iday = "0" . $iday;
      }
      # I just make all times midnight.  Not sure what the last
      # two digits or Z mean.
#      my $date_string = $year . $imonth . $iday . "T000000";
      my $date_string = $year . $imonth . $iday;

      # Try to use @months_to_print here...
      if (($year == $curr_year && $imonth >= 9) || ($year == $curr_year+1 && $imonth <= 10))
      {
        $print_ical = 1;
      }
      else
      {
        $print_ical = 0;
      }

      if ($print_ical)
      {
         print ICAL "BEGIN:VEVENT$crlf";
         print ICAL "UID:sscm" . $day->{idx} . "\@sscm.org$crlf";
         print ICAL "DTSTAMP:$date_string$crlf";
         print ICAL "DTSTART:$date_string$crlf";

         my $heb_date_in_hebrew = convert_number_to_hebrew($day->{Hday}, undef) . " " .
                $hebrew_month_unicode{$day->{Hmon}} . " " .
                            get_hebrew_year_string($day);

#         print ICAL "DTEND:$date_string$crlf";
         print ICAL "SUMMARY:$heb_date_in_hebrew$crlf";
         print ICAL "DESCRIPTION:";

         foreach my $item (@{$print_data_for_day[$idx]})
         {
            # Perl gives a warning when printing a bullet to the text file, so just replace it with a space
            # Declare a new variable so that it doesn't change the original value in the print_data_for_day array
            my $item_to_print = get_text_safe($item);

            my ($ical_item_to_print, $bold, $italic, $partial_bold, $size)  = identify_special_codes($item_to_print);

            # Do we want to disable other bolding if we're already bolding all
            # of the titles in ical ($bold_everything_in_ical)?
            $ical_item_to_print =~ s/$START_BOLD/<b>/g;
            $ical_item_to_print =~ s/$END_BOLD/<\/b>/g;
            if ($bold) {
              $ical_item_to_print = "<b>$ical_item_to_print</b>";
            }
            if ($italic) {
              $ical_item_to_print = "<em>$ical_item_to_print</em>";
            }
            print ICAL "$crlf $ical_item_to_print\\n";
         }

         print ICAL "$crlf";
         print ICAL "END:VEVENT$crlf";
      }
   }

   print ICAL "END:VCALENDAR$crlf";
   close ICAL || croak "Error: Problem closing file $ical_filename \n";
}








##################################
####                         #####
####     RULE CALCULATORS    #####
####                         #####
##################################

sub check_tefillin_time($$)
{
    # This assumes the Shacharis time has already been set according to usual rules,
    # and displays tefillin times (Misheyyakir) for the given day if they are very late relative to scheduled Shacharis.
    # Also if $move_later is true, may adjust Shacharis time if it's too early (such as on Rosh Chodesh)
    #  Based on discussion with Rabbi Felder on Shabbos 6 Av 5770
    my ($day, $move_later) = @_;
    my $sunrise = get_sunrise($day);
    if (!is_time($sunrise))
    {
        croak "Error: No valid sunrise defined for day $day->{idx}: $sunrise\n";
    }
    my $tefillin = subtract_minutes($sunrise,57) . $separator . subtract_minutes($sunrise,50);
    my $shacharis = $day->{to_print}->{Shacharis};
    if (is_earlier($shacharis,subtract_minutes($sunrise, 45)))
    {
        $day->{to_print}->{"Earliest Tefillin"} = $tefillin;
        if (is_earlier($shacharis, subtract_minutes($sunrise, $earliest_shacharis_before_sunrise)))
        {
            if ($move_later)
            {
                # This can happen on Rosh Chodesh so make Shacharis start no later than 69 minutes before sunrise
                my $new_shacharis = round_up_to_5_minutes(subtract_minutes($sunrise, $earliest_shacharis_before_sunrise));

                if (is_earlier("6:45", $new_shacharis))
                {
                    # This can happen now that DST runs into November.  Make Shacharis not later than 6:45 but print a warning
                    $new_shacharis = "6:45";
                    warn "6:45 Shacharis on " . print_date($day) . " is > $earliest_shacharis_before_sunrise min. before sunrise!\n";
                }
                $shacharis =~ s/\d:\d\d/$new_shacharis/;
                $day->{to_print}->{Shacharis} = $shacharis;
            }
            else
            {
                # On Friday, Nov. 5, 2010, sunrise is at 7:59, so we keep Shacharis at 6:45 but print a warning
                warn "First Shacharis at $shacharis on ". print_date($day) .
                                    " is > $earliest_shacharis_before_sunrise min. before sunrise!\n";
            }
        }
    }
}


sub set_mincha_maariv_for_week($)
{
    # sets Mincha and Maariv for weekdays, Sunday through Thursday,
    # assuming the given day is a Sunday and the entire range (until Thursday) is within the range of dates with sunset data available
    my ($day) = @_;

    if ($day->{day_of_week} ne "Sun")
    {
        croak "can't set Mincha/Maariv for week unless given day is a Sunday.\n";
    }

    my $sunday_index = $day->{idx};
    my $thursday_index = $sunday_index + 4;

    my $earliest_sunset;
    my $latest_sunset;
    my $mincha;
    my $maariv;

    if ($thursday_index > $#list_of_days)
    {
        # If we don't have calendar data until Thursday, can't set Mincha/Maariv times for the week
        $earliest_sunset = "UNKNOWN";
        $latest_sunset = "UNKNOWN";
        $mincha = "UNKNOWN";
        $maariv = "UNKNOWN";
        warn "Mincha and Maariv not scheduled for last partial week, beginning " . print_date($day) . "\n";
    }
    else
    {
        # Regular mincha is 10 minutes before sunset, rounded down to the nearest 5 minutes.
        # It's based on the earliest sunset of the week (Sun-Thu).
        for my $index ($sunday_index .. $thursday_index)
        {
            my $sunset_today = get_sunset($list_of_days[$index]);
            if (!is_time($sunset_today))
            {
                croak "Error: No valid sunset defined for day $index: $sunset_today\n";
            }

            if (!defined($earliest_sunset))
            {
                $earliest_sunset = $sunset_today;
                $latest_sunset = $sunset_today;
            }
            else
            {
                # Need to compare days.
                if (is_earlier($sunset_today, $earliest_sunset))
                {
                    $earliest_sunset = $sunset_today;
                }
                elsif (is_earlier($latest_sunset, $sunset_today))
                {
                    $latest_sunset = $sunset_today;
                }
            }
        }
        if (!defined($earliest_sunset) || !defined($latest_sunset))
        {
            croak "Error: No days found for a sunset!\n";
        }

        my $primary_mincha = round_down_to_5_minutes(subtract_minutes($earliest_sunset, 10));

        if (is_earlier($early_weekday_mincha,$primary_mincha))
        {
            $mincha = $even_earlier_weekday_mincha . $separator . $early_weekday_mincha . $separator . $primary_mincha;
        }
        elsif (is_earlier($even_earlier_weekday_mincha,$primary_mincha))
        {
            $mincha = $even_earlier_weekday_mincha . $separator . $primary_mincha;
        }
        else
        {
            $mincha = $primary_mincha;
        }

#        my $early_mincha;
#
#        if (is_earlier($early_weekday_mincha,$primary_mincha))
#        {
#            $early_mincha = $early_weekday_mincha;
#        }
#
#        if (!defined($early_mincha))
#        {
#            $mincha = $primary_mincha;
#        }
#        else
#        {
#            $mincha = "$early_mincha\/$primary_mincha";
#        }

        my $main_maariv = add_minutes($primary_mincha,30);

        # Late maariv is normally at 9:30, but must be at least 33 minutes after the latest sunset of the week.
        my $late_maariv = add_minutes($latest_sunset,33);
        if (is_earlier($late_maariv,"9:31"))
        {
            $late_maariv = "9:30";
        }
        elsif (is_earlier($late_maariv,"9:36"))
        {
            $late_maariv = "9:35";
        }
        else
        {
            $late_maariv = "9:37";
        }

        $maariv = "$main_maariv$separator$late_maariv";
    }

    return $mincha, $maariv;



}


sub get_normal_mincha($)    # this is no longer used as it's combined into set_mincha_maariv_for_week($)
{
   # Regular mincha is 10 minutes before sunset, rounded down
   # to the nearest 5 minutes.  It's based on the earliest sunset
   # of the week (Sun-Thu).
   my ($day) = @_;
   my $primary_mincha;
   my $second_mincha = "open";

   my $current_day_idx = $day->{idx};

   # Push back to Sunday.  If the first day in our calendar
   # happens to not be Sunday, we obviously can't go back
   # any earlier than that.
   #### This should be unnecessary because we call this only for Sunday
#   while ($current_day_idx > 1 &&
#          $list_of_days[$current_day_idx]->{day_of_week} ne "Sun")
#   {
#      $current_day_idx--;
#   }

   # Okay, we should be at the first day of the week.
   my $earliest_sunset = "open";
   while ($current_day_idx <= $#list_of_days &&
          $list_of_days[$current_day_idx]->{day_of_week} ne "Fri")
   {
      if ($earliest_sunset eq "open")
      {
         $earliest_sunset = get_sunset($list_of_days[$current_day_idx]);
         if (!is_time($earliest_sunset))
         {
            croak "Error: No valid sunset defined for day $current_day_idx: $earliest_sunset\n";
         }
      }
      else
      {
         # Need to compare days.
         my $sunset_today = get_sunset($list_of_days[$current_day_idx]);

         is_time($sunset_today) || croak "Error: $sunset_today not valid time for $current_day_idx\n";

         if (is_earlier($sunset_today,$earliest_sunset))
         {
            $earliest_sunset = $sunset_today;
         }
      }
      $current_day_idx++;
   }
   if ($earliest_sunset eq "open")
   {
      croak "Error: No days found for a sunset!\n";
   }

   $primary_mincha =
      round_down_to_5_minutes(subtract_minutes($earliest_sunset, 10));

   if (is_earlier("8:15",$primary_mincha))
   {
      $second_mincha = "8:15";
   }

   if ($second_mincha eq "open")
   {
      return $primary_mincha;
   }
   else
   {
      return "$second_mincha\/$primary_mincha";     # if needed again, fix for new separator
   }
}


sub get_normal_maariv($$)   # this is no longer used as it's combined into set_mincha_maariv_for_week($)
{
   # Calculate maariv times for a normal weekday.
   # Assumes that mincha has already been calculated.
   my ($day, $mincha) = @_;

#   my $mincha = $day->{to_print}->{Mincha};    # It's not yet assigned to the hash; must be received as parameter
   # Strip off the earlier mincha time, if it's there.
   $mincha =~ s/\S+\///;        # if needed again, fix for new separator

   my $early_maariv = add_minutes($mincha,30);

   # Late maariv is normally at 9:30, but must be at least
   # 33 minutes after the latest sunset of the week.
   my $current_day_idx = $day->{idx};

   # Push back to Sunday.  If the first day in our calendar
   # happens to not be Sunday, we obviously can't go back
   # any earlier than that.
#   while ($current_day_idx > 1 &&
#          $list_of_days[$current_day_idx]->{day_of_week} ne "Sun")
#   {
#      $current_day_idx--;
#   }
   my $latest_sunset = "open";
   while ($current_day_idx <= $#list_of_days &&
          $list_of_days[$current_day_idx]->{day_of_week} ne "Fri")
   {
      if ($latest_sunset eq "open")
      {
         $latest_sunset = get_sunset($list_of_days[$current_day_idx]);
         if (!$latest_sunset)
         {
            croak "Error: No sunset defined for day $current_day_idx\n";
         }
      }
      else
      {
         # Need to compare days.
         my $sunset_today = get_sunset($list_of_days[$current_day_idx]);

         if (is_earlier($latest_sunset,$sunset_today))
         {
            $latest_sunset = $sunset_today;
         }
      }
      $current_day_idx++;
   }
   my $late_maariv = add_minutes($latest_sunset,33);
   if (is_earlier($late_maariv,"9:31"))
   {
      $late_maariv = "9:30";
   }
   elsif (is_earlier($late_maariv,"9:36"))
   {
      $late_maariv = "9:35";
   }
   else
   {
      $late_maariv = "9:37";
   }

   return "$early_maariv/$late_maariv";
}


sub get_shabbos_mincha ($)
{
   my ($day) = @_;

   my $sunset = get_sunset($day);

   my $mincha;

   if (during_avos_season($day) &&
                    !($day->{Eyear} =~ 2011 && $day->{Emon} =~ 9)     # exception for backward compatibility
                    )
   {
      # AB corrected.  Mincha will be between 33 and 37 minutes before sunset on days when there is an Avos shiur.
      $mincha = round_down_to_5_minutes(subtract_minutes($sunset,33));
   }
   else
   {
      $mincha = round_down_to_5_minutes(subtract_minutes($sunset,30));
   }

   return $mincha;
}


sub get_friday_mincha ($$)
{
   # Get normal Friday mincha.  If the second argument
   # is true, it will always return the 18 minutes
   # before sunset version.
   my ($day, $force_late) = @_;

   my $sunset = get_sunset($day);

   # I subtract 14 minutes so that rounding down to the nearest
   # 5 will leave us at most 18 minutes before sunset.
   # (I.e. candle-lighting or later.)
   my $mincha = subtract_minutes($sunset,14);
   $mincha = round_down_to_5_minutes($mincha);

   if (is_earlier("7:15",$mincha) && !$force_late)
   {
      $mincha = "7:15";
   }

   # This is added in 5770
   my $sunrise = get_sunrise($day);
   my $plag = compute_plag($sunrise,$sunset);
   my $early_mincha = round_down_to_5_minutes(subtract_minutes($plag,14));

   # This condition tweaked for 5771, see whether it works.
   # We want to ensure that the early Mincha starts immediately after the March clock change.
   # Also don't want two Minchas only 5 minutes apart.
   # Not sure whether the end date for two Minchas will be correct.  Check this!
   # Tweaked again for 5772 after Executive decision on Wed. Sept. 21, 2011
   $early_mincha =~ s/7:10/7:05/;   # so it will not get later than 7:05
   if (!is_earlier($early_mincha,"5:35") && !$force_late && $early_mincha !~ "7:10")
   {
        $mincha = $early_mincha . $separator . $mincha;
   }

   return $mincha;
}


sub modify_public_holidays
{
   # Change Shacharis to holiday_shacharis time for
   # each public holiday.

   # Make sure that we find at least one of each holiday
   # in the calendar.  If we don't, print a warning.
   my @civic_holidays = (
      "Labour Day",
      "Thanksgiving",
      "Dec. 25",
      "Dec. 26",
      "New Years",
      "Good Friday",
      "Victoria Day",
      "Canada Day",
      "Civic Holiday",
      "Family Day"
   );

   print "Handling Public Holidays.\n";

   foreach my $year (keys (%english_years))
   {
      my $idx;
      # Labour day.
#      $idx = $index_of_first_day_of_the_month{"$year,9"};
#      if ($idx)
#      {
#         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Mon")
#         {
#            $idx++;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#               last;
#            }
#            $day = $list_of_days[$idx];
#         }

         $idx = index_of_date(Nth_Weekday_of_Month_Year($year,9,1,1));  # first Monday of September

#         if ($idx >= 0)
#         {
            set_holiday($idx, "Labour Day");
#            $day->{to_print}->{Shacharis} = $holiday_shacharis;
#            $day->{to_print}->{"Earliest Tefillin"} = undef;
#            if ($debug_info)
#            {
#                add_notes($day,"Labour Day");
#            }
#            $holidays_found{"Labour Day"} = 1;
#         }
#      }

      # Thanksgiving.
#      $idx = $index_of_first_day_of_the_month{"$year,10"};
#      if ($idx)
#      {
#         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Mon")
#         {
#            $idx++;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#               last;
#            }
#            $day = $list_of_days[$idx];
#         }
#
#         if ($idx >= 0)
#         {
#            # Second Monday, so add 7
#            $idx += 7;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#            }
#         }
         $idx = index_of_date(Nth_Weekday_of_Month_Year($year,10,1,2));  # second Monday of October

#         $day = $list_of_days[$idx];
#         if ($idx >= 0)
         {
            set_holiday($idx, "Thanksgiving");
         }
#      }

      # Dec. 25 & 26.
      $idx = index_of_date($year,12,25);
#      $idx = $index_of_first_day_of_the_month{"$year,12"};
      if ($idx)
      {
#         $idx += 24;
         my $day = $list_of_days[$idx];
         # If Dec. 25 is a weekend, push forward to Monday.
         while ($day->{day_of_week} eq "Sat" ||
                $day->{day_of_week} eq "Sun")
         {
            $idx++;
            $day = $list_of_days[$idx];
         }
#         if ($idx <= $#list_of_days)
         {
            set_holiday($idx, "Dec. 25");
         }
         $idx++;
         $day = $list_of_days[$idx];
         while ($day->{day_of_week} eq "Sat" ||
                $day->{day_of_week} eq "Sun")
         {
            $idx++;
            $day = $list_of_days[$idx];
         }
#         if ($idx <= $#list_of_days)
         {
            set_holiday($idx, "Dec. 26");
         }
      }

      # Jan. 1
      $idx = $index_of_first_day_of_the_month{"$year,1"};
      if ($idx)
      {
         my $day = $list_of_days[$idx];
         while ($day->{day_of_week} eq "Sat" ||
                $day->{day_of_week} eq "Sun")
         {
            $idx++;
            $day = $list_of_days[$idx];
         }
#         if ($idx <= $#list_of_days)
         {
            set_holiday($idx, "New Years");
#            $day->{to_print}->{Shacharis} = $holiday_shacharis;
#            $day->{to_print}->{"Earliest Tefillin"} = undef;
#            $holidays_found{"New Years"} = 1;
#            if ($debug_info)
#            {
#                add_notes($day,"New Years");
#            }
         }
      }

      # Good Friday
      # I hard-code the next few years
      # of Good Fridays, because it's tricky to calculate.
      ### NO! It's built in to Date::Calc!

      $idx = index_of_date(Easter_Sunday($year));   # This is Easter Sunday; must go back two days
#      $idx = get_good_friday_day_index($year);
      if ($idx)
      {
            $idx -= 2;
            set_holiday($idx, "Good Friday");   # will correctly check that holiday is in bounds of the array
      }

      # Victoria Day. (second-last Monday in May)
      $idx = $index_of_first_day_of_the_month{"$year,6"};
      if ($idx)
      {
         # Move back to May 31.
         $idx--;
         my $day = $list_of_days[$idx];
         while ($day->{day_of_week} ne "Mon" && $idx >= 0)
         {
            $idx--;
            $day = $list_of_days[$idx];
         }
#         if ($idx >= 7)
         {
            $idx -= 7;
            set_holiday($idx, "Victoria Day");
         }
      }

      #
      # Canada Day. (July 1 or following Monday)
      $idx = $index_of_first_day_of_the_month{"$year,7"};
      if ($idx)
      {
         my $day = $list_of_days[$idx];
         while ($day->{day_of_week} eq "Sat" ||
                $day->{day_of_week} eq "Sun")
         {
            $idx++;
            $day = $list_of_days[$idx];
         }
#         if ($idx <= $#list_of_days)
         {
            set_holiday($idx, "Canada Day");
         }
      }

      # Civic Holiday. (First Monday in August)
      $idx = index_of_date(Nth_Weekday_of_Month_Year($year,8,1,1));  # first Monday of August
#      $idx = $index_of_first_day_of_the_month{"$year,8"};
#      if ($idx)
#      {
#         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Mon")
#         {
#            $idx++;
#            $day = $list_of_days[$idx];
#         }
#         if ($idx <= $#list_of_days)
         {
            set_holiday($idx, "Civic Holiday");
         }
#      }

      # Family Day.  Third Monday in February
      $idx = index_of_date(Nth_Weekday_of_Month_Year($year,2,1,3));  # third Monday of February
#      $idx = $index_of_first_day_of_the_month{"$year,2"};
#      if ($idx)
#      {
#         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Mon")
#         {
#            $idx++;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#               last;
#            }
#            $day = $list_of_days[$idx];
#         }
#
#         if ($idx >= 0)
#         {
#            # Third Monday, so add 14
#            $idx += 14;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#            }
#         }
#
#         $day = $list_of_days[$idx];
#         if ($idx >= 0)
         {
            set_holiday($idx, "Family Day");
#            $day->{to_print}->{Shacharis} = $holiday_shacharis;
#            $day->{to_print}->{"Earliest Tefillin"} = undef;
#            if ($debug_info)
#            {
#                add_notes($day,"Family Day");
#            }
#            $holidays_found{"Family Day"} = 1;
         }
#      }

   }

   foreach my $holiday (@civic_holidays)
   {
      if (!defined($holidays_found{$holiday}))
      {
         warn "Couldn't find $holiday in calendar!\n\n";
      }
   }
}

sub set_holiday ($$)
{
    my ($idx, $holiday_name) = @_;
    if (defined $idx && $idx > 0 && $idx <= $#list_of_days)
    {
        my $day = $list_of_days[$idx];
        $day->{to_print}->{Shacharis} = $holiday_shacharis;
        delete $day->{to_print}->{"Earliest Tefillin"};
        if (!is_during_DST($day) && $day->{day_of_week} ne "Fri")
        {
        	$day->{to_print}->{Mincha} = $early_sunday_mincha_winter . $separator . $day->{to_print}->{Mincha};
        }
        $day->{public_holiday} = $holiday_name;     # so that we can later access the fact that it's a public holiday
        if ($debug_info)
        {
            add_notes($day,$holiday_name);
        }
        $holidays_found{$holiday_name} = 1;
    }
}



sub list_clock_change_days()   # AB wrote this.
{
   foreach my $year (keys (%english_years))
   {
#      # Labelling clock change dates according to the new DST rules (effective 2007).  # NOW IT WORKS RETROACTIVELY
#      if ($year < 2007)
#      {
#         warn "Clock change dates are not labelled for years prior to 2007.\n\n";
#         next;
#      }

      # Spring forward on the second Sunday of March at 2:00 a.m.  Label this on the Saturday night before.
      my $idx = absolute_to_idx(get_DST_start($year));
#      my $idx = $index_of_first_day_of_the_month{"$year,3"};
      if ($idx)
      {
         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Sun")
#         {
#            $idx++;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#               last;
#            }
#            $day = $list_of_days[$idx];
#         }
#
#         if ($idx >= 0)
#         {
#            # Second Sunday, so add 7
#            $idx += 7;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#            }
#         }

#         if ($idx > 0)
         {
#            $day = $list_of_days[$idx];
            add_prenotes($day, $BOLD . "Daylight-Saving Time"); # to print output on the Sunday morning
            # print print_date($day) . " is the first day of DST, " . is_during_DST($day) . "\n";

            if ($idx > 1)
            {
               $day = $list_of_days[$idx-1]; # to print output on the Saturday night
               add_notes($day, $BOLD . "Change clocks forward one hour at 2:00 a.m.");
               # print print_date($day) . " is the day before DST, " . is_during_DST($day) . "\n";
            }
         }
      }

      # Fall back on the first Sunday of November at 2:00 a.m.  Label this on the Saturday night before.
      $idx = absolute_to_idx(get_DST_end($year));
#      $idx = $index_of_first_day_of_the_month{"$year,11"};
      if ($idx)
      {
         my $day = $list_of_days[$idx];
#         while ($day->{day_of_week} ne "Sun")
#         {
#            $idx++;
#            if ($idx > $#list_of_days)
#            {
#               $idx = -1;
#               last;
#            }
#            $day = $list_of_days[$idx];
#         }

#         if ($idx > 0)
         {
#            $day = $list_of_days[$idx];
            add_prenotes($day, $BOLD . "Standard Time");    # to print output on the Sunday morning
            # Bold Mincha to remind people that it's an hour earlier than previously
            $day->{to_print}->{Mincha} = $BOLD . $day->{to_print}->{Mincha};
            # print print_date($day) . " is the day back to Standard Time, " . is_during_DST($day) . "\n";

            if ($idx > 1)
            {
               $day = $list_of_days[$idx-1]; # to print output on the Saturday night
               add_notes($day, $BOLD . "Change clocks back one hour at 2:00 a.m. EDT");
                        # Rabbi Oppenheimer complained about getting stuck in an infinite loop (Nov. 2011) so added "EDT" in 2012
               # print print_date($day) . " is the last full day of DST, " . is_during_DST($day) . "\n";
            }

            # Bold following Friday candle lighting and Shabbos Shema time
            if ($idx + 5 <= $#list_of_days)
            {
                $day = $list_of_days[$idx+5];
                $day->{to_print}->{"Candle Lighting"} = $BOLD . $day->{to_print}->{"Candle Lighting"};

                if ($idx + 6 <= $#list_of_days)
                {
                    $day = $list_of_days[$idx+6];
                    $day->{to_print}->{"Latest Sh'ma"} = $BOLD . $day->{to_print}->{"Latest Sh'ma"};
                }
            }
         }
      }
   }
}




# Why is this called modify_... when the other similar functions are called handle_... ?
sub modify_rosh_chodesh()
{
   # Go through the entire calendar.  Every time I encounter
   # the 30th of a Hebrew month or the 1st, do the necessary
   # changes for Rosh Chodesh and Birkas HaChodesh (AB added).
   #  Exception is Rosh Hashana.
   print "Handling Rosh Chodesh.\n";
   my $day_idx = 1;
   while ($day_idx <= $#list_of_days)
   {
      my $day = $list_of_days[$day_idx];
      my $heb_day = $day->{Hday};
      my $heb_mon = $day->{Hmon};
      my $day_of_week = $day->{day_of_week};

      if ($heb_day == 1 || $heb_day == 30)
      {
         # Then this is Rosh Chodesh.
         if ($day_of_week eq "Sat")
         {
            move_shabbos_shacharis_earlier($day);   # starting in 5772
            # (In previous years, we didn't do anything unusual for shabbos Rosh Chodesh.)
         }
         elsif ($day->{to_print}->{Shacharis} =~ /$sunday_shacharis/)
         {
            # We don't do anything unusual for Sunday Rosh Chodesh.
            ;
         }
         else
         {
            if ($day_of_week !~ /Mon|Tue|Wed|Thu|Fri/)
            {
               croak "Bad day of week: $day_of_week\n";
            }

            $day->{to_print}->{Shacharis} = $rosh_chodesh_shacharis;
            # we may have set the early Shacharis too early, so check it against the tefillin time
            check_tefillin_time($day, 1);
            ## Since we're setting the early Shacharis at 6:30, we need to ensure it's not too early relative to sunrise.
            ## This will probably need tweaking.
            #my $this_rosh_chodesh_shacharis = $rosh_chodesh_shacharis;
            #my $sunrise = get_sunrise($day);
            #if(is_earlier("7:42",$sunrise))
            #{
            #    $this_rosh_chodesh_shacharis =~s/6:30/6:45/;
            #}
            #$day->{to_print}->{Shacharis} = $this_rosh_chodesh_shacharis;
         }
         # Don't add Rosh Chodesh note or Birkas HaChodesh (AB) for Rosh Hashana.
         if (!($heb_day == 1 && $hebrew_month_index{$heb_mon} == 1))
         {
            my $month_name;
            if ($heb_day ==1)
            {
                $month_name = $heb_mon;
            }
            elsif ($day_idx < $#list_of_days)
            {
                # 30th day of the month, so need the next month's name
                $month_name = $list_of_days[$day_idx+1]->{Hmon};
            }
            else
            {
                # Can't get the next month's name!
                warn "No month name available for Rosh Chodesh on " . print_date($day) ." because the next day's data is not available.\n";
                $month_name = "";
            }
            my $output_month_name = get_output_month_name ($month_name);
            #$month_name =~ s/Tevet/Teves/;  # bug in Hebcal as they give Tevet even when set to Ashkenazis
            #$month_name =~ s/Tamuz/Tammuz/; # bug in Hebcal as spelling was inconsistent with Tzom Tammuz
            # It was Jonathan Zion's suggestion to label the month names on Rosh Chodesh.
            add_prenotes($day, $BOLD . "Rosh Chodesh $output_month_name");

            # AB: Shabbos before Rosh Chodesh is Birkas HaChodesh,
            # but this should not be determined from the second day of a 2-day Rosh Chodesh.
            my $idx = $day_idx - 1;
            if ($idx > 0 && $list_of_days[$idx]->{Hday} == 29)  # start working backwards from Erev Rosh Chodesh until we find a Shabbos.
            {
               while ($idx > 0 && $list_of_days[$idx]->{day_of_week} ne "Sat")
               {
                  $idx--;
               }
               if ($idx > 0)
               {
                  add_prenotes($list_of_days[$idx], $BOLD . "Birkas HaChodesh");
               }
            }

		# Jason Spiro suggested adding a note saying Ulechaparat Pasha:
		if ($hebrew_month_index{$heb_mon} == 1	# this will pick only 30 Tishrei since we have already excluded 1 Tishrei
				&& is_leap($day)
		)
		{
			add_prenotes($day, $BOLD . "Ulchapparas Pasha");
		}

         }
      }

      if ($heb_day == 1)
      {
         # Skip to the next Rosh Chodesh day.
         $day_idx += 29;
      }
      else
      {
         # Just search until we find the next Rosh Chodesh.
         $day_idx++;
      }
   }
}

sub get_output_month_name($)
# for correcting month names where Hebcal's transliteration is buggy
{
    my ($hebcal_month_name) = @_;
    my $output_month_name = $hebcal_month_name;
    $output_month_name =~ s/Tevet/Teves/;  # bug in Hebcal as they give Tevet even when set to Ashkenazis
    $output_month_name =~ s/Tamuz/Tammuz/; # bug in Hebcal as spelling was inconsistent with Tzom Tammuz
    $output_month_name =~ s/ /$nbsp/; # replace any space with non-breaking space, such as in Adar I and Adar II
    return $output_month_name;
}


sub is_leap($)
# Determine whether the given day is in a Jewish leap year
{
	my ($day) = @_;
	my $heb_year = $day->{Hyear};
	my $year_in_cycle = $heb_year % 19;
	my $is_leap = (
		$year_in_cycle == 0 ||
		$year_in_cycle == 3 ||
		$year_in_cycle == 6 ||
		$year_in_cycle == 8 ||
		$year_in_cycle == 11 ||
		$year_in_cycle == 14 ||
		$year_in_cycle == 17
	);

#	print OUT "Year " . $heb_year . $is_leap ? " is " : " is not " . "a leap year. \n";

	return $is_leap;
}


sub move_shabbos_shacharis_earlier($)
# STARTING IN 2018, SHABBOS SHACHARIS IS ALWAYS AT 9:00
# SO THIS FUNCTION SHOULD DO NOTHING!
# as of 5772, Shabbos Shacharis will be at 9:00 instead of 9:15 on any Hallel day
# also need to move Mr. Deutsch's Chumash shiur.
# Note that yamim tovim are handled separately.  NO - for 5772 he said to keep the shiur when yom tov falls on Shabbat so must use this function
{
	return;   # DOING NOTHING AS OF 2018
#    my ($day) = @_;
#    if ($day->{day_of_week} ne "Sat")
#    {
#        croak "This function is only for Shabbos!\n";
#    }
#    $day->{to_print}->{Shacharis} = $shabbos_shacharis_with_hallel;
#    if (defined($day->{to_print}->{"Chumash Shiur"}))    # check in case it was cancelled for some other reason, though unlikely
#    {
#        $day->{to_print}->{"Chumash Shiur"} = $chumash_shiur_special;
#    }
}


sub compute_plag ($$)
{
   my ($sunrise,$sunset) = @_;

   my $minutes_per_shaa = minutes_per_shaa($sunrise,$sunset);

   # Plag is 1 and 1/4 hours before sunset.  I think.
   my $minutes_to_subtract = int($minutes_per_shaa * 1.25);

   my $plag = subtract_minutes($sunset,$minutes_to_subtract);

   return $plag;
}

sub compute_shma ($$)
{
   # Compute sof zman krias shma.  Just compute GR"A, and
   # subtract 36 minutes for M"A.

   my ($sunrise,$sunset) = @_;

   my $minutes_per_shaa = minutes_per_shaa($sunrise,$sunset);

   # ZKSH is 3 hours after sunrise.
   my $minutes_to_add = int($minutes_per_shaa * 3);

   my $gra_zksh = add_minutes($sunrise,$minutes_to_add);
   my $ma_zksh = subtract_minutes($gra_zksh,36);

   return $ma_zksh . $separator . $gra_zksh;     # not using $separator because would probably make the Shabbos column too wide
}

sub handle_pesach
{
   # For each year in our calendar, check if Pesach occurs, and
   # if it does, go through and fill in all of the relevant rules,
   # including general rules for Nisan.
   # Note that if the 15th of Nisan isn't in the calendar, I don't
   # bother doing anything.  For now, though, I'll print an error
   # if the 15th isn't in the calendar, but the first of Nisan
   # or Iyyar is.
   #
   # Also note that I print all of the days of the Omer here.
   print "Handling Pesach.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my ($day, $idx);
      my $first_day_of_pesach_idx = find_hebrew_date($year,"Nisan",15);
      my $first_of_nisan_idx = find_hebrew_date($year,"Nisan",1);
      my $first_of_iyyar_idx = find_hebrew_date($year,"Iyyar",1);
      if ($first_day_of_pesach_idx)
      {
         # Shabbos Hagodol - drasha can never be on erev pesach, so start
         # looking for shabbos 2 days earlier.
         $idx = $first_day_of_pesach_idx - 2;
         while ($idx > 0 && $list_of_days[$idx]->{day_of_week} ne "Sat")
         {
            $idx--;
         }
         if ($idx > 0)
         {
            $day = $list_of_days[$idx];
            add_drasha($day);
#            if ($renovation)
#            {
#                $day->{to_print}->{Drasha} = "TBA";
#            }
#            else
#            {
#                my $mincha = $day->{to_print}->{Mincha};
#                $day->{to_print}->{Drasha} = subtract_minutes($mincha,70);
#            }
#            # Cancel Nach shiur and shiurim.
#            $day->{to_print}->{Shiur} = undef;
#            $day->{to_print}->{Shiurim} = undef;
            if ($idx == $first_day_of_pesach_idx - 8)
            {
               # I think that we should really mark erev Pesach
               # as Shabbos Hagodol, although I'm not sure.  [This is correct. - AB]
               warn "Erev Pesach falls on Shabbos in $year.  Look over Pesach carefully this year, and decide whether to keep 2:00 Mincha!\n\n";
               add_prenotes($list_of_days[$idx+7], $BOLD . "Shabbos Hagodol");
            }
            else
            {
               add_prenotes($day, $BOLD . "Shabbos Hagodol");
            }
         }

         # There are a bunch of changes that are required
         # here to handle Erev Pesach on Shabbos.
         # They're scattered throughout somewhat haphazardly,
         # so be careful.

         # Bedikas Chometz is day before erev pesach, unless it is a
         # Friday, in which case it gets pushed back to Thursday.
         $idx = $first_day_of_pesach_idx - 2;
         if ($idx > 0)
         {
            $day = $list_of_days[$idx];
            if ($day->{day_of_week} eq "Fri")
            {
               $day = $list_of_days[$idx-1];
            }

            # Cancel 9:30 Ma'ariv - no, Maariv was reinstated in 2009
            # David C. said that in 2010 only 4 people showed up, but Brian G. said to keep it in for 2011
#            my $maariv = $day->{to_print}->{Maariv};
#            $maariv =~ s/\/\d\d?:\d\d?$//;     # if needed again, fix for new separator
#            $day->{to_print}->{Maariv} = $maariv;
            $day->{to_print}->{Sunset} = get_sunset($day);
            add_notes($day, $BOLD . "Bedikas Chometz");
            remove_notes($day, "Tehillim after late Maariv");
         }

         # Erev Pesach.
         $idx = $first_day_of_pesach_idx - 1;
         if ($idx > 0)
         {
            $day = $list_of_days[$idx];
            my $siyum_day = $day;
            my $burn_chometz_day = $day;
            if ($day->{day_of_week} eq "Sat")
            {
               if ($idx < 3) {
                    croak "Calendar starts too close to Pesach\n";
               }
               # Shacharis and Siyyum get moved to Thursday.
               $siyum_day = $list_of_days[$idx-2];
               $burn_chometz_day = $list_of_days[$idx-1];
            }

            my $current_shacharis = $siyum_day->{to_print}->{Shacharis};

            # AB reorganizing the siyyum code so that siyyum time depends directly on the previously scheduled Shacharis time.
            # I don't see why we need the extra error-checking based on day of the week.
            # The only problem with this would be if, at some point in the future, we discontinue the differentiation
            # in Shacharis times between the early and late days.  I hope this doesn't happen.
            ##### IT HAPPENED! Since November 2008, there is no difference in Shacharis times for Torah reading days.
            # Rewriting code to accommodate.

		# In 2014 - all of this is basically irrelevant, as the siyum time constants all use $siyum_time now,
		# which just says "after each minyan".

            my $day_of_week = $siyum_day->{day_of_week};
            my $siyum;

            if ($current_shacharis eq $early_shacharis && ($day_of_week eq "Mon" || $day_of_week eq "Thu"))
            {
               $siyum_day->{to_print}->{Shacharis} = $siyum_shacharis;
               $siyum = $siyum_mon_thurs;
            }
            elsif ($current_shacharis eq $late_shacharis && ($day_of_week eq "Wed" || $day_of_week eq "Fri"))
            {
               $siyum_day->{to_print}->{Shacharis} = $siyum_shacharis;
               $siyum = $siyum_wed_fri;
            }
            elsif ($siyum_day->{public_holiday} eq "Good Friday")
            {
               ##  AB Comment:  This will happen in 2012, when Erev Pesach falls on Good Friday.
               ##  Hasn't happened since 1998 so we don't have a precedent for Shacharis and Siyyum times.
               # Now Ari M. said revert to usual weekday Shacharis timing because it's a busy day so some people will want the 6:45,
               # but have the siyyum after the 7:30 and 8:30, NOT after the 6:45.
               ### But there were complaints about having the first minyan without a siyyum, so in the end there was one!
               ########   RECHECK THIS FOR 2015!!!!!
               warn "Programming Erev Pesach on a public holiday for 2012 - revisit later to determine whether it's correct.\n\n" .
                            "(Also notice late sunrise in 2018 and 2029.) \n\n";
               #warn "The date " . print_date($siyum_day) . " appears to be Erev Pesach on a public holiday.\n";
               #warn "We haven't had this since 1998.  Someone needs to determine the Shacharis and Siyyum times and enter them accordingly.\n\n";
               $siyum_day->{to_print}->{Shacharis} = $siyum_shacharis_public_holiday; # "6:45" . $separator . "7:30" . $separator . "8:30$BOLD";
               $siyum = $siyum_public_holiday;
            }
            else
            {
                croak "Something wrong with siyyum day in $siyum_day->{Eyear} / $siyum_day->{Hyear} \n";
            }

            #if ($current_shacharis eq $early_shacharis ||
            #    $current_shacharis eq $late_shacharis)
            #{
            #   $siyum_day->{to_print}->{Shacharis} = $no_middle_minyan_shacharis;
            #}
            #else
            #{
            #   ##  AB Comment:  This will happen in 2012, when Erev Pesach falls on Good Friday.
            #   ##  Hasn't happened since 1998 so we don't have a precedent for Shacharis and Siyyum times.
            #   warn "Unusual shacharis time $current_shacharis for erev pesach.  Please investigate.  Date is " . print_date($siyum_day) . "\n";
            #}
            #my $day_of_week = $siyum_day->{day_of_week};
            #my $siyum;
            #if ($day_of_week eq "Wed" ||
            #    $day_of_week eq "Fri")
            #{
            #   $siyum = "7:15/8:00";
            #}
            #elsif ($day_of_week eq "Mon" ||
            #       $day_of_week eq "Thu")
            #{
            #   $siyum = "7:25/8:15";
            #}
            #else
            #{
            #   croak "$day_of_week should not be Erev Pesach!\n";
            #}

            #add_prenotes($day, $BOLD . "Erev Pesach");

            $siyum_day->{to_print}->{"Siyum & Breakfast"} = $siyum;

            # Candle lighting is handled by the standard yom tov routine.

            my $shaa = minutes_per_shaa
               (get_sunrise($burn_chometz_day),get_sunset($burn_chometz_day));

            # For these calculations, we use MA shaa, which is
            # 12 minutes longer (144 / 12)
            $shaa = $shaa + 12;
            my $alos = subtract_minutes(get_sunrise($burn_chometz_day),72);
            my $eat_until = add_minutes($alos,4*$shaa);
            my $burn_chometz = add_minutes($alos,5*$shaa);
            my $chatzos = add_minutes($alos,6*$shaa);

            # AB reorganizing this a little too.
            $burn_chometz_day->{to_print}->{"Burn Chometz Before"} = $burn_chometz;
            if ($day->{day_of_week} eq "Sat")
            {
               # Then we list May eat chometz until and dispose of
               # chometz before.
               my $shaa = minutes_per_shaa
                  (get_sunrise($day),get_sunset($day));
               $shaa = $shaa + 12;
               my $alos = subtract_minutes(get_sunrise($day),72);  # AB corrected
               my $dispose_chometz = add_minutes($alos,5*$shaa);
               $eat_until = add_minutes($alos,4*$shaa); # AB This is the variable declared in the outer code block, before the "if" condition.
               $chatzos = add_minutes($alos,6*$shaa);   # AB Same as previous comment.
               $day->{to_print}->{"Dispose of Chometz Before"} = $dispose_chometz;  # AB fixed this - I think it was wrong in 5768
               # Early Shacharis on Erev Pesach.
               $day->{to_print}->{Shacharis} = "7:00".$BOLD;
               delete $day->{to_print}->{"Chumash Shiur"};
            }

            $day->{to_print}->{"May Eat Chometz Until"} = $eat_until;
            $day->{to_print}->{"Chatzos"} = $chatzos;
         }

         # I have a separate routine to print Yom Tov information
         # that is typically common to all yomim tovim
         handle_yom_tov($first_day_of_pesach_idx,"Erev Pesach","First Day of Pesach","Second Day of Pesach",0);

         # Exceptions for Shacharis: First 2 days of Pesach only 9:15 (and if it's Shabbos must set Chumash Shiur to 8:15)
         $list_of_days[$first_day_of_pesach_idx]->{to_print}->{Shacharis} = $pesach_shacharis;
         if (defined $list_of_days[$first_day_of_pesach_idx]->{to_print}->{"Chumash Shiur"})
         {
            $list_of_days[$first_day_of_pesach_idx]->{to_print}->{"Chumash Shiur"} = $chumash_shiur_pesach;
            #   delete $list_of_days[$first_day_of_pesach_idx]->{to_print}->{"Chumash Shiur"};
	# it seems to have been cancelled in 2018, is this a permanent change?
	#  NO!! Mr. Deutsch clarified that the shiur will always take place.
	# So we list it on this day uniquely at 8:15
         }
         $list_of_days[$first_day_of_pesach_idx+1]->{to_print}->{Shacharis} = $pesach_shacharis;

         # Chol Hamoed
         my $i;
         for ($i = 3; $i < 7; $i++)
         {
            $idx = $first_day_of_pesach_idx + $i - 1;
            $day = $list_of_days[$idx];
            # Make sure that we haven't overstepped the bounds
            # of the array.
            $day || croak "Error: Undefined day during Chol Hamoed\n";
            add_prenotes($day, $BOLD . "Chol Hamoed");

            if ($day->{day_of_week} eq "Sat")
            {
            	# Now that Shacharis on Shabbos is 9:00 always (starting in 2018),
            	# the difference here is that there is no YMM.
                $day->{to_print}->{Shacharis} = $yom_tov_shacharis;
               # starting in 5772, moving Shacharis to 9:00 on any Shabbos Hallel days (exc. first day of Pesach)
               # move_shabbos_shacharis_earlier($day);
            }
            elsif ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/
                        && !defined($day->{public_holiday}))
            {
                # Cancel middle minyan on Chol Hamoed, and add an 8:30 minyan
                # Then we get the 6:30/7:30/8:30 minyan schedule
                $day->{to_print}->{Shacharis} = $chol_hamoed_shacharis;
                check_tefillin_time($day, 0);   # probably never a problem on Pesach, but just to be safe
            }
	delete $day->{to_print}->{"Likras Shabbos for Boys"};
         }

         # Last days of Yom Tov
         # add_prenotes($list_of_days[$first_day_of_pesach_idx + 5], $BOLD . "Erev Yom Tov");  # AB added
         handle_yom_tov($first_day_of_pesach_idx+6,"Erev Yom Tov","Seventh Day of Pesach","Eighth Day of Pesach",1);

         # Erev 7th day of Pesach is unusual in that it is the only yom tov we bring in early,
         # so we override the usual Mincha rules from the yom_tov routine
         $day = $list_of_days[$first_day_of_pesach_idx + 5];
         # Add an asterisk to candle lighting for Pesach, since Mincha is always
         # at 7:15.
         if (is_earlier($day->{to_print}->{"Candle Lighting"},"7:15"))
         {
            croak "Shouldn't Candle lighting always be after 7:15 on Erev 7th day Pesach (based on the new DST rules since 2007)?\n";
            ## AB In 2002 even the 7th day of Pesach was before DST, using the old rules.
         }

         $day->{to_print}->{"Candle Lighting"} .= "**";
#            $day->{to_print}->{"Candle Lighting"} . "**";
         $day->{to_print}->{"Mincha"} = $BOLD . get_friday_mincha($day,0);
         $day->{to_print}->{"Plag HaMincha"} = compute_plag(get_sunrise($day),get_sunset($day));

         # Also need to add yizkor on 8th day.
         add_yizkor($first_day_of_pesach_idx + 7);

         add_notes($list_of_days[$first_day_of_pesach_idx + 7], "Allow one hour for repurchase of chometz");    # added for 5773

         # On Isru Chag, cancel the bais medrash minyan and add 8:30 Shacharis.
         my $isru_day = $list_of_days[$first_day_of_pesach_idx+8];
         if ($isru_day->{to_print}->{Shacharis} eq $early_shacharis ||
             $isru_day->{to_print}->{Shacharis} eq $late_shacharis)
         {
            $isru_day->{to_print}->{Shacharis} = $isru_chag_shacharis;
         }
	delete $isru_day->{to_print}->{"Likras Shabbos for Boys"};

         # When planning for 5774, President Aaron Wagschal said to schedule 8:30 Shacharis before yom tov based on
         # Yeshiva Darchei Torah's schedule.
         # He also said not to schedule the 8:30 Shacharis beyond Isru Chag.
         # "For simplicity, let's just have it for isru chag and then update the kehila each yom tov"
         my $start_date = $pesach_recess_start_date{$year};
         if (defined ($start_date))
         {
            if ($start_date < 1 || $start_date > 14)
            {
                croak "Start day for 8:30 Shacharis must be a date in Nisan before Pesach $year!\n";
            }
            # my $start_date_idx = find_hebrew_date($year,"Nisan",$start_date);
            for ($idx = find_hebrew_date($year,"Nisan",$start_date); $idx < $first_day_of_pesach_idx; $idx++)
            {
                $day = $list_of_days[$idx];
		add_late_shacharis($day);
#                my $old_shach = $day->{to_print}->{Shacharis};
#                if ($old_shach !~ /8:30/ && $day->{day_of_week} ne "Sat" )  # excludes Shabbos but no longer excludes siyyum day
#                {
#                    $day->{to_print}->{Shacharis} =
#                        $old_shach . " / " # $separator
#				. $START_BOLD . "8:30" . $END_BOLD;    # decide whether to use $separator
#                }
		delete $day->{to_print}->{"Likras Shabbos for Boys"};	# don't know whether this follows the same rule
            }
         }
         else
         {
            warn "No start date for 8:30 Shacharis before Pesach defined for $year.\n";
         }


	# From discussion with Gedalia Felder on the plane overnight on 29 Tishrei 5776,
	# we concluded that the 8:30 Shacharis should continue one day after Isru Chag,
	# and another extra day if that day is Friday.
	# (Possibly more if there are days of from Darchei Torah)
	$day = $list_of_days[$first_day_of_pesach_idx + 9];
	add_late_shacharis($day);
	if ($day->{day_of_week} eq "Thu")
	{
		$day = $list_of_days[$first_day_of_pesach_idx + 10];
		add_late_shacharis($day);
	}

#         # AB: We appear to add an 8:30 minyan for one week after Pesach.
#         # Reverting to this version for 5772; decide see whether it is correct in general
#         # The idea can be refined over time.
#         # warn "NOTE: Check 8:30 minyanim around Pesach and Succos manually\n";
##         for ($i = 1; $i < 8; $i++)
##         {
##            $day = $list_of_days[$first_day_of_pesach_idx +7+ $i];
##            my $old_shach = $day->{to_print}->{Shacharis};
##            if ($old_shach !~ /8:30/ && $day->{day_of_week} ne "Sat")
##            {
##               $day->{to_print}->{Shacharis} =
##                  $old_shach . "/$START_BOLD" . "8:30$END_BOLD";    # decide whether to use $separator
##            }
##         }
#
#         # We appear to add an 8:30 minyan until the Shabbos after Pesach.
#         # This is not really correct in general, but we are reverting to this version for 5773.
#         # The idea must be refined over time, depending on the day of the week on which Pesach ends, and the yeshiva schedules.
##         $idx = $first_day_of_pesach_idx + 8;
##         while ($list_of_days[$idx]->{day_of_week} ne "Sat")
##         {
##            my $old_shach = $list_of_days[$idx]->{to_print}->{Shacharis};
##            if ($old_shach !~ /8:30/)
##            {
##               $list_of_days[$idx]->{to_print}->{Shacharis} =
##                  $old_shach . $separator . $START_BOLD . "8:30$END_BOLD";    # decide whether to use $separator
##            }
##            $idx++;
##         }
#
#         # AB - similarly for the days before Pesach, excluding the Siyyum day, going back to the previous Sunday.
#         # For 5770 Brian said to include the siyyum day.
#         # And in 5770 it actually started a whole week before Pesach (not the Sunday before)
#         $idx = $first_day_of_pesach_idx - 1;  # start from Erev Pesach
#         # $idx = $first_day_of_pesach_idx - 2;  # excludes Erev Pesach
#         # while ($idx > 0 && $idx >= $first_day_of_pesach_idx - 7)
#         while ($idx > 0 && $idx >= find_hebrew_date($year,"Nisan",$pesach_recess_start_date{$year}))
#         # while ($idx > 0 && $list_of_days[$idx]->{day_of_week} ne "Sun")
#         {
#            my $old_shach = $list_of_days[$idx]->{to_print}->{Shacharis};
#            if ($old_shach !~ /8:30/ && $list_of_days[$idx]->{day_of_week} ne "Sat" )  # excludes Shabbos but no longer excludes siyyum day
#            # if ($old_shach !~ /8:30/ && !defined ($list_of_days[$idx]->{to_print}->{"Siyum & Breakfast"}))
#            # excludes Siyyum day even if it was not erev Pesach
#            {
#               $list_of_days[$idx]->{to_print}->{Shacharis} =
#                  $old_shach . $separator . $START_BOLD . "8:30$END_BOLD";    # decide whether to use $separator
#            }
#            $idx--;
#         }

         # Print the days of the omer.
         for (my $omer = 1; $omer <= 49; $omer++)
         {
            my $day_idx = $first_day_of_pesach_idx + $omer;
            if ($day_idx <= $#list_of_days)
            {
               if ($omer == 33)
               {
                  add_prenotes($list_of_days[$day_idx], $BOLD . "Lag B'Omer");
               }
               add_prenotes($list_of_days[$day_idx],"Omer $omer");
            }
         }
      }
      else
      {
         if ($first_of_nisan_idx || $first_of_iyyar_idx)
         {
            croak "For year $year, didn't find a valid Pesach, but found at least one day in Nisan (or the first of Iyyar)\n";
         }
      }

   }
   warn "NOTE: Check 8:30 minyanim around Pesach and Succos manually\n\n";
}

sub handle_shavuos
{
   print "Handling Shavuos.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my ($day, $idx);
      my $first_day_idx = find_hebrew_date($year,"Sivan",6);
      my $first_of_sivan_idx = find_hebrew_date($year,"Sivan",1);
      my $first_of_tamuz_idx = find_hebrew_date($year,"Tamuz",1);
      if ($first_day_idx)
      {
         if ($first_day_idx == 1 || $first_day_idx == $#list_of_days)
         {
            croak "Bad idea to make Shavuos near start or end of calendar\n";
         }
         handle_yom_tov($first_day_idx,"Erev Shavuos","First Day of Shavuos","Second Day of Shavuos",1);  # AB amended

         if ($first_day_idx > 1)
         {
            my $erev = $list_of_days[$first_day_idx-1];  # AB fixed this.
            # add_prenotes($erev, $BOLD . "Erev Shavuos");
            $erev->{to_print}->{"Learning Program"} = $shavuos_learning_program;
         }
         # Early minyan on first day.
         my $day = $list_of_days[$first_day_idx];
         my $vasikin = calculate_vasikin($day); # we used to make this constantly 5:00, but that was a little too late in 5771
         $day->{to_print}->{Shacharis} = $vasikin . $separator . $shavuos_shacharis;
         #indicate_vasikin($day);

         # Handle Yizkor on 2nd day.
         add_yizkor($first_day_idx + 1);

         # AB: Avos UBanim started in 5767 on Second day Shavuos even though it was a weekday.
         ## Not sure whether this will be a permanent rule.  Leaving it out for now.
         if(!$renovation)
         {
             $day = $list_of_days[$first_day_idx + 1];
#            $day->{to_print}->{"Avos UBanim "} = "5:15";
         }
      }
      else
      {
         if ($first_of_sivan_idx || $first_of_tamuz_idx)
         {
            croak "For year $year, didn't find a valid Shavuos, but found at least one day in Sivan (or the first of Tamuz)\n";
         }
      }
   }
}


sub handle_rosh_hashana_and_slichos
{
   print "Handling Rosh Hashana and slichos.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my ($day, $idx);
      my $first_day_idx = find_hebrew_date($year,"Tishrei",1);
      if ($first_day_idx)
      {
         if ($first_day_idx <= 10 || $first_day_idx >= $#list_of_days - 10)
         {
            croak "Bad idea to make Rosh Hashana near start or end of calendar\n";
         }
         my $erev = $list_of_days[$first_day_idx-1];
         # add_prenotes($erev, $BOLD . "Erev Rosh Hashana");
         $erev->{to_print}->{"Hataras Nedarim"} = $NOTIME;

         my $hyear = $list_of_days[$first_day_idx]->{Hyear};
         handle_yom_tov($first_day_idx,"Erev Rosh Hashana","First Day of Rosh Hashana " . $hyear, "Second Day of Rosh Hashana",0);

         # Shacharis is always 8:00 on Rosh Hashana.
         $list_of_days[$first_day_idx]->{to_print}->{Shacharis} = $rh_shacharis;
         $list_of_days[$first_day_idx+1]->{to_print}->{Shacharis} = $rh_shacharis;

         ## Adding HaMelech listing in 2011:
         $list_of_days[$first_day_idx]->{to_print}->{HaMelech} = $hamelech_RH;
         $list_of_days[$first_day_idx+1]->{to_print}->{HaMelech} = $hamelech_RH;

         # When it is Shabbos the various shiurim don't take place:
         delete $list_of_days[$first_day_idx]->{to_print}->{"Chumash Shiur"};
         delete $list_of_days[$first_day_idx]->{to_print}->{Shiurim};  # confirmed this with R' Weitman on Shabbos 9 Elul 5769.
         delete $list_of_days[$first_day_idx]->{to_print}->{"Navi Shiur"};

         # Rabbi Felder said Shofar time is indefinite at Tiferes location so we're leaving it out in 5769.
         if ($list_of_days[$first_day_idx]->{day_of_week} ne "Sat" && !$renovation)
         {
            $list_of_days[$first_day_idx]->{to_print}->{Shofar} = $shofar;
         }
         if ($list_of_days[$first_day_idx+1]->{day_of_week} ne "Sat" && !$renovation)
         {
            $list_of_days[$first_day_idx+1]->{to_print}->{Shofar} = $shofar;
         }

         ## There was Tehillim in 5768 when R' Marcus zt"l was ill but hasn't continued since
         # $list_of_days[$first_day_idx]->{to_print}->{Tehillim} = subtract_minutes($list_of_days[$first_day_idx]->{to_print}->{Mincha}, 30);
         # $list_of_days[$first_day_idx+1]->{to_print}->{Tehillim} = subtract_minutes($list_of_days[$first_day_idx+1]->{to_print}->{Mincha}, 30);

         # AB - at least 4 days of Slichos before Rosh Hashana.
         # This way we don't need to check the day of the week of RH explicitly.
         # (There was a bug in the original condition, which I have now fixed, even though it's commented out.)
         my $slichos_idx = $first_day_idx - 4;

         #if ($list_of_days[$first_day_idx]->{day_of_week} eq "Mon" ||
         #    $list_of_days[$first_day_idx]->{day_of_week} eq "Tue")
         #{
         #   # Then Slichos starts at least a week before Rosh Hashana.
         #   $slichos_idx -= 7;
         #}

         while ($slichos_idx > 1 &&
                $list_of_days[$slichos_idx]->{day_of_week} ne "Sun")
         {
            $slichos_idx--;
         }

         # First Sunday slichos is special.
         if ($list_of_days[$slichos_idx]->{day_of_week} eq "Sun")
         {
            # Print 1:00 a.m. for both Sat. night and Sun. morning.
            if ($slichos_idx > 1)
            {
               $list_of_days[$slichos_idx-1]->{to_print}->{"Teshuva Shiur"} = $teshuva_shiur;  # added in 2012
               $list_of_days[$slichos_idx-1]->{to_print}->{Slichos} = $first_slichos;
            }
            $list_of_days[$slichos_idx]->{to_print}->{Slichos} = $first_slichos;
            $slichos_idx++;
         }

         # Now go through the rest of the days, up to Erev Yom Kippur.
         while ($slichos_idx < $first_day_idx + 9 &&
                $slichos_idx <= $#list_of_days)
         {
            # There are a bunch of special cases.
            my $day = $list_of_days[$slichos_idx];
            if ($day->{day_of_week} eq "Sat")
            {
               # No slichos.
               $slichos_idx++;
               next;
            }
            elsif ($slichos_idx == $first_day_idx-1)
            {
               # Erev Rosh Hashana.

               # AB added:
               if ($day->{to_print}->{Shacharis} =~ /$sunday_shacharis/
                    || defined($day->{public_holiday}))
               {
                  ##  AB Comment:  This will happen in 2012, when Erev Rosh Hashana falls on Sunday.
                  ##  (Also Erev RH can fall on Labour Day, as in 1994 and 2021.)
                  # Rabbi Felder said on Thursday Sept. 8, 2011 to make it 6:30
                  #warn "The date " . print_date($day) . " is Erev Rosh Hashana on a Sunday or public holiday.\n";
                  #warn "We haven't had this since 1998.  Someone needs to determine the Slichos time and enter it accordingly.\n\n";
                  # warn "Setting Slichos on Sunday Erev Rosh Hashana for " . print_date($day) . ".  Make sure this is correct.\n";
                  $day->{to_print}->{Slichos} = $slichos_erev_RH_sunday;
               }
               else
               {
                  $day->{to_print}->{Slichos} = $slichos_erev_RH_weekday;
               }
            }
            elsif ($slichos_idx == $first_day_idx ||
                   $slichos_idx == $first_day_idx+1)
            {
               # Rosh Hashana.  Don't do anything.
               $slichos_idx++;
               next;
            }
            elsif ($slichos_idx == $first_day_idx+8)
            {
               # Erev Yom Kippur.
               my $shacharis = $day->{to_print}->{Shacharis};
               # Must check for Sunday
               # (can't be a public holiday because erev YK can't fall on Monday, and only holidays in Sept./Oct. are on Mondays)
               $day->{to_print}->{Slichos} = ($shacharis =~ /$sunday_shacharis/) ?
                                                    $slichos_erev_YK_sunday :
                                                    $slichos_erev_YK_weekday;
#               if ($shacharis =~ /$sunday_shacharis/)
#               {
#                  # Sunday/holiday.
#                  $day->{to_print}->{Slichos} = "7:15/7:45/8:15";
#               }
#               else
#               {
#                  # Weekday
#                  $day->{to_print}->{Slichos} = "6:30/6:45/7:15";  # This was WRONG in 5771!
#               }
            }
            else
            {
               # Normal day.
               my $shacharis = $day->{to_print}->{Shacharis};
               if ($shacharis =~ /$sunday_shacharis/)
               {
                  # Sunday/holiday.
                  $day->{to_print}->{Slichos} = $slichos_sunday;    #"7:00/7:30/8:00";
               }
               elsif (defined($day->{public_holiday}))
               {
                  $day->{to_print}->{Slichos} = $slichos_public_holiday;
               }
               elsif ($slichos_idx < $first_day_idx)
               {
                  # Weekday before Rosh HaShana
                  $day->{to_print}->{Slichos} = $slichos_before_RH;
               }
               else
               {
                    # Weekday after RH
                    $day->{to_print}->{Slichos} = $slichos_after_RH;
               }
            }

            # On all days, note that Shacharis is after Slichos.
            $day->{to_print}->{Shacharis} = "follows Slichos";
            $slichos_idx++;
         }
      }
      else
      {
         my $prev_elul_idx = find_hebrew_date($year-1,"Elul",1);
         if ($prev_elul_idx)
         {
            croak "Found Elul for " . $year - 1 . " but no Rosh Hashana. " .
                  "That will probably mess up slichos.\n";
         }
      }
   }
}

sub handle_succos  # AB: Note that we've always spelled it Succos, not Sukkos.  Don't know why.
{
   print "Handling Succos.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my ($day, $idx);
      my $first_day_of_succos_idx = find_hebrew_date($year,"Tishrei",15);
      my $first_of_tishrei_idx = find_hebrew_date($year,"Tishrei",1);
      my $first_of_cheshvan_idx = find_hebrew_date($year,"Cheshvan",1);
      if ($first_day_of_succos_idx)
      {
         if (!$first_of_tishrei_idx || !$first_of_cheshvan_idx)
         {
            croak "It's probably a bad idea to break the calendar during Tishrei.".
                    "  Please include a few more days, or write the succos function more carefully.\n";
         }
         handle_yom_tov($first_day_of_succos_idx,
                           "Erev Succos",
                           "First Day of Succos",
                           "Second Day of Succos",
                           0);
         # add_prenotes($list_of_days[$first_day_of_succos_idx - 1], $BOLD . "Erev Succos");  # AB added
         my $day = $list_of_days[$first_day_of_succos_idx];
#         if (!$renovation)
         {
            # New Sisterhood President Judy Jacobs confirmed by e-mail (4 Elul 5768)
            # that there will be a tea this year (5769) and that it will be at 4:30.
		# In 2014 Anita Miller said the tea will be at 4:45.
            $day->{to_print}->{"Sisterhood Tea"} = "4:45";
         }
         # Chol Hamoed
         my $i;
         for ($i = 3; $i < 7; $i++)  # AB exclude Hoshana Rabba as we will treat it separately
         {
            $idx = $first_day_of_succos_idx + $i - 1;
            $day = $list_of_days[$idx];
            # Make sure that we haven't overstepped the bounds
            # of the array.
            $day || croak "Error: Undefined day during Chol Hamoed Succos\n";
            add_prenotes($day, $BOLD . "Chol Hamoed");

            if ($day->{day_of_week} eq "Sat")
            {
            	# Now that Shacharis on Shabbos is 9:00 always (starting in 2018),
            	# the difference here is that there is no YMM.
                $day->{to_print}->{Shacharis} = $yom_tov_shacharis;
               # For Shabbos Chol Hamoed Succos, Shacharis has been at 9:00 for many years
               # move_shabbos_shacharis_earlier($day);
               #$day->{to_print}->{Shacharis} = $shabbos_chol_hamoed_succos_shacharis;
               #$day->{to_print}->{"Chumash Shiur"} = $chumash_shiur_special;
            }
            elsif ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/
                        && !defined($day->{public_holiday}))
            {
                # Cancel middle minyan on Chol Hamoed, and add an 8:30 minyan

                if ($day->{Hyear} == 5771)
                {
                    $day->{to_print}->{Shacharis} = $chol_hamoed_succos_5771_shacharis;
                }
                else
                {
                    ## we haven't yet formalized the permanent rule.
                    #  7:00 will probably be too early in 5772 for its intended purpose.
                    ### NOT CONTINUING with the 7:00 Shacharis
                    $day->{to_print}->{Shacharis} = $chol_hamoed_shacharis;
                }
                check_tefillin_time($day, 0);   # decide whether this should move Shacharis to 6:35 in extreme cases:  2005, 2016, 2024, 2027
		delete $day->{to_print}->{"Likras Shabbos for Boys"};
            }
         }


         # Hoshana Rabba
         $day = $list_of_days[$first_day_of_succos_idx + 6];
         # add_prenotes($day, $BOLD . "Hoshana Rabba");  # AB added # but covered by handle_yom_tov

         my $vasikin = calculate_vasikin($day); # this already prints sunrise so don't need to do it separately

         # my $sunrise = get_sunrise($day);
         # $day->{to_print}->{Sunrise} = $sunrise;

         # my $vasikin = subtract_minutes($sunrise,29);
         # $vasikin = round_down_to_5_minutes($vasikin);

         # AB added:
         if ($day->{to_print}->{Shacharis} =~ /$sunday_shacharis/
                    || defined($day->{public_holiday}))
         {
            ##  AB Comment:  This will happen in 2012, when Hoshana Rabba falls on Sunday.
            warn "Setting Shacharis on Sunday Hoshana Rabba for " . print_date($day) . ".  Check this!\n";
            #warn "The date " . print_date($day) . " is Hoshana Rabba on a Sunday or public holiday.\n";
            #warn "We haven't had this since 2001.  Someone needs to determine the Shacharis times and enter them accordingly.\n\n";
            $day->{to_print}->{Shacharis} = $vasikin . $separator . "7:30" . $separator . "8:30" . $BOLD;
         }
         else
         {
            # The first Shacharis used to be at 6:30, but in 2010 they changed it to 6:15.
            # Problem is, sometimes that's too early.
            # So we make the first minyan 6:15 but not more than 72 minutes before sunrise,
            # then there's a vasikin minyan, and then 7:30.
            my $sunrise = $day->{to_print}->{Sunrise};
            my $early_shacharis = round_up_to_n_minutes (subtract_minutes ($sunrise, 72), 5);
            if (is_earlier($early_shacharis, "6:15"))
            {
                    $early_shacharis = "6:15";
            }
            $day->{to_print}->{Shacharis} = $early_shacharis . $separator . $vasikin . $separator . "7:30" . $BOLD;
            check_tefillin_time($day, 0);   # Don't move Shacharis later because Pesukei Dezimra is long so can start early
#            # this may mess up the first Shacharis time unnecessarily as in 2005 or 2024; Pesukei dezimra is long so can start earlier
            if (is_earlier("6:30",$day->{to_print}->{Shacharis}))
            {
                warn "Check Shacharis time on Hoshana Rabba as sunrise is very late, " . print_date($day) . "\n";
#                $day->{to_print}->{Shacharis} =~ s/^6:\d\d?\//6:30\//;     # if needed again, fix for new separator
            }
         }
         #indicate_vasikin($day);

         handle_yom_tov($first_day_of_succos_idx+7,
                           "Hoshana Rabba",
                           "Shemini Atzeres",
                           "Simchas Torah",
                           1);
         # Handle Yizkor on Shmini Atzeres.
         add_yizkor($first_day_of_succos_idx + 7);

         my $simchas_torah_day = $list_of_days[$first_day_of_succos_idx+8];

         $vasikin = calculate_vasikin($simchas_torah_day);

         #$sunrise = get_sunrise($simchas_torah_day);
         #$vasikin = subtract_minutes($sunrise,40);  # Apparently Vasikin was added to Simchas Torah in 5769.
         #$vasikin = round_down_to_5_minutes($vasikin);
         $simchas_torah_day->{to_print}->{Shacharis} = $vasikin . $separator . $simchas_torah_shacharis;
         #indicate_vasikin($simchas_torah_day);


         # On Isru Chag, cancel the bais medrash minyan and add 8:30 Shacharis.
         my $isru_day = $list_of_days[$first_day_of_succos_idx+9];
         if ($isru_day->{to_print}->{Shacharis} eq $early_shacharis ||
             $isru_day->{to_print}->{Shacharis} eq $late_shacharis)
         {
            $isru_day->{to_print}->{Shacharis} = $isru_chag_shacharis;
         }

         # AB: We appear to add an 8:30 minyan for one week after Simchas Torah.
         # This is probably not correct in general, but the idea can be refined over time.
            # in 5771 this is in fact what happened, so returning to this version for 5772.
         # warn "NOTE: Check 8:30 minyanim around Pesach and Succos manually\n";
#         for ($i = 1; $i < 8; $i++)
#         {
#            $day = $list_of_days[$first_day_of_succos_idx +8+ $i];
#            my $old_shach = $day->{to_print}->{Shacharis};
#            if ($old_shach !~ /8:30/ && $day->{day_of_week} ne "Sat")
#            {
#               $day->{to_print}->{Shacharis} =
#                  $old_shach . "/$START_BOLD" . "8:30$END_BOLD";    # decide whether to use $separator
#            }
#         }

         # AB: We appear to add an 8:30 minyan until the Shabbos after Succos.
         # Reverting to this version for 5773, but it is not correct in general.
         # Really should depend on the day of the week and on the yeshiva schedules.
#         $idx = $first_day_of_succos_idx + 9;
#         while ($list_of_days[$idx]->{day_of_week} ne "Sat")
#         {
#            my $old_shach = $list_of_days[$idx]->{to_print}->{Shacharis};
#            if ($old_shach !~ /8:30/)
#            {
#               $list_of_days[$idx]->{to_print}->{Shacharis} =
#                  $old_shach . $separator . $START_BOLD . "8:30$END_BOLD";    # decide whether to use $separator
#            }
#            $idx++;
#         }

	# From discussion with Gedalia Felder on the plane overnight on 29 Tishrei 5776,
	# we concluded that the 8:30 Shacharis should continue one day after Isru Chag,
	# and another extra day if that day is Friday.
	# (Possibly more if there are days of from Darchei Torah)
	# (Also it seems that we treat a Shabbos Isru Chag as though Sunday is Isru Chag)
	$day = $list_of_days[$first_day_of_succos_idx + 10];
	add_late_shacharis($day);
	if ($day->{day_of_week} =~ /Thu|Sun/)
	{
		$day = $list_of_days[$first_day_of_succos_idx + 11];
		add_late_shacharis($day);
	}


         # AB - similarly for the 4 days between Yom Kippur and Succos.
         for ($i = 1; $i < 5; $i++)
         {
            $day = $list_of_days[$first_day_of_succos_idx - $i];
            add_late_shacharis($day);
#            my $old_shach = $day->{to_print}->{Shacharis};
#            if ($old_shach !~ /8:30/ && $day->{day_of_week} ne "Sat")
#            {
#               $day->{to_print}->{Shacharis} =
#                        $old_shach . " / " # $separator
#				. $START_BOLD . "8:30" . $END_BOLD;    # decide whether to use $separator
#            }
         }
      }
   }
   warn "NOTE: Check 8:30 minyanim around Pesach and Succos manually\n\n";
   # warn "Need a permanent rule for the 7:00 Shacharis on Chol HaMoed Succos as started in 5771.\n\n"; # NOT doing this any more!
}


sub handle_yom_kippur
{
   print "Handling Yom Kippur.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my ($day, $idx);
      my $yk_idx = find_hebrew_date($year,"Tishrei",10);
      if ($yk_idx)
      {
         if ($yk_idx > 1)
         {
            my $erev = $list_of_days[$yk_idx-1];
            add_prenotes($erev, $BOLD . "Erev Yom Kippur");
            my $sunset = get_sunset($erev);
            $erev->{to_print}->{Mincha} = $mincha_erev_YK;
            # Kol Nidrei is 17-21 minutes before sunset.
            $erev->{to_print}->{"Kol Nidrei"} =
               round_down_to_5_minutes(subtract_minutes($sunset,17));
            $erev->{to_print}->{"Candle Lighting"} =
               subtract_minutes($sunset,18);
            $erev->{to_print}->{Sunset} = $sunset;
            # Don't print Maariv.
            delete $erev->{to_print}->{Maariv};
	delete $erev->{to_print}->{"Likras Shabbos for Boys"};
            remove_notes($erev, "Tehillim after late Maariv");
         }
         else
         {
            warn "Found Yom Kippur, but no Erev Yom Kippur in $year!\n\n";
         }

         my $day = $list_of_days[$yk_idx];
         my $sunrise = get_sunrise($day);
         my $sunset = get_sunset($day);
         $day->{to_print}->{Sunset} = $sunset;
         $day->{to_print}->{Sunrise} = $sunrise;
         $day->{to_print}->{"Latest Sh'ma"} = compute_shma($sunrise,$sunset);
         $day->{to_print}->{Shacharis} = $yk_shacharis;
         $day->{to_print}->{HaMelech} = $hamelech_YK;
         delete $day->{to_print}->{"Chumash Shiur"};
         delete $day->{to_print}->{"Earliest Tefillin"};
         # Note that Yizkor is later on Yom Kippur than on other
         # yomim tovim.
         $day->{to_print}->{Yizkor} = $yizkor_YK;
         $day->{to_print}->{Mincha} =
            round_down_to_5_minutes(subtract_minutes($sunset,135)); # AB changed; this is three hours before Motzoai Yom Kippur

         ## There was Tehillim in 5768 when R' Marcus zt"l was ill but hasn't continued since
         # $day->{to_print}->{Tehillim} = subtract_minutes($day->{to_print}->{Mincha}, 15);

         # AB modified here
         if ($day->{day_of_week} ne "Sat")
         {
            $day->{to_print}->{"Motzoai Yom Kippur"} = add_minutes($sunset,45);
         }
         else
         {
            $day->{to_print}->{"Motzoai Shabbos & Yom Kippur"} =
                $day->{to_print}->{"Motzoai Shabbos"};
            delete $day->{to_print}->{"Motzoai Shabbos"};
            delete $day->{to_print}->{Shiurim};
            delete $day->{to_print}->{"Navi Shiur"};
         }

         delete $day->{to_print}->{Maariv};
         remove_notes($day, "Tehillim after late Maariv");
         add_prenotes($day, $BOLD . "Yom Kippur");

         # AB: Shabbos before Yom Kippur is Shabbos Shuva, with a Drasha:
         $idx = $yk_idx - 2;  # might as well get a head start because we know it's never Erev YK
         while ($idx > 0 && $list_of_days[$idx]->{day_of_week} ne "Sat")
         {
            $idx--;
         }
         if ($idx > 0)
         {
            $day = $list_of_days[$idx];
            add_drasha($day);
#            if ($renovation)
#            {
#                $day->{to_print}->{Drasha} = "TBA";
#            }
#            else
#            {
#                my $mincha = $day->{to_print}->{Mincha};
#                my $drasha = subtract_minutes($mincha,70);
#                my $early_mincha = subtract_minutes($drasha, $early_shabbos_mincha_length);
#                $mincha = "$early_mincha/$mincha";
#                $day->{to_print}->{Drasha}  = $drasha;
#                $day->{to_print}->{Mincha} = $mincha;
#            }
#            # Cancel shiurim.
#            $day->{to_print}->{Shiurim} = undef;
            add_prenotes($day, $BOLD . "Shabbos Shuva");
         }
      }
   }
}


sub handle_yom_tov($$$$$)
{
   # Make changes for a typical 2-day yom tov.
   # Just normal shabbos-type stuff.  Anything else must be done by caller.
   my ($first_day_idx, $erev_name, $first_day_name, $second_day_name, $has_neilas_hachag) = @_;

   # First check bounds.  We'll need erev yom tov, first, and second days, so all must be within the array:
   if ($first_day_idx <= 1)
   {
        croak "Bad index for (Erev yom tov) $erev_name: " . $first_day_idx - 1 . "\n";
   }

   if ($first_day_idx >= $#list_of_days)
   {
        croak "Bad index for (Second day yom tov) $second_day_name: " . $first_day_idx + 1 . "\n";
   }

   # First, candle lighting, etc. of previous day.
   my $erev = $list_of_days[$first_day_idx - 1];
   add_prenotes($erev, $BOLD . $erev_name);
   my $erev_sunset = get_sunset($erev);
   $erev->{to_print}->{"Sunset"} = $erev_sunset;

   if ($erev->{day_of_week} eq "Sat")
   {
        #  There is no Shalosh Seudos in shul, so Mincha can be a little later than a regular Shabbos.
        #  Also there is no early (6:00) Mincha, especially because Maariv follows from (the late) Mincha with no listed time.
        my $erev_main_mincha = round_down_to_5_minutes(subtract_minutes($erev_sunset,$shabbos_no_ss_mincha_length));
        ### On Erev Shavuos in 2012 we introduced 2:00 Mincha Gedola so that people could eat Shalosh Seudos at home after Mincha.
        ### How do they know what time to come back for Maariv?  According to Ari Messinger:  "With seyata dshmaya"
        ### Does this apply to Erev Pesach as well, when there is no seuda in the afternoon?  We'll put it in, and see what happens in 2021.
        # In 2016 the 2:00 changed to 2:30.
        $erev->{to_print}->{Mincha} = $shabbos_no_ss_early_mincha . $separator . $erev_main_mincha;
        $erev->{to_print}->{Shiurim} = subtract_minutes($erev_main_mincha,60);
        if (defined ($erev->{to_print}->{"Navi Shiur"}))
        {
        		$erev->{to_print}->{"Navi Shiur"} = subtract_minutes($erev_main_mincha, get_Navi_length($erev));
        }

        delete $erev->{to_print}->{Avos};
        delete $erev->{to_print}->{Shiur};  # This one doesn't matter as it's outside the range of any yom tov
        ## Should we also delete the "Women's Avos"?
        #  On erev Shavuos 5772 it was cancelled and replaced by a women's shiur on the second day of yom tov,
        #  but that was because of a special guest speaker; it's not clear that this has to be the case.
        ### Note that if we wanted to cancel it, doing it here wouldn't help because it isn't scheduled until afterward!

        # Candle lighting is after Motzoai Shabbos, and replaces the Motzoai Shabbos listing.
        $erev->{to_print}->{"Candle Lighting $START_BOLD" . "after$END_BOLD"} = add_minutes($erev_sunset,45);
        delete $erev->{to_print}->{"Motzoai Shabbos"};
   }
   else # erev yom tov is a weekday
   {
      $erev->{to_print}->{"Candle Lighting"} = subtract_minutes($erev_sunset,18);
      # The only Yom Tov that we can bring in early is 7th day Pesach,
      # so that case will be done separately by the Pesach routine.
      # Here we assume Mincha is at the late time.
      $erev->{to_print}->{"Mincha"} = get_friday_mincha($erev,1);
   }

   # Maariv never gets printed on Erev yom tov or yom tov itself
   delete $erev->{to_print}->{Maariv};
	delete $erev->{to_print}->{"Likras Shabbos for Boys"};
   remove_notes($erev, "Tehillim after late Maariv");

   # On Wed. or Thurs. we need an Eiruv Tavshilin
   if ($erev->{day_of_week} eq "Wed" ||
       $erev->{day_of_week} eq "Thu")
   {
      $erev->{to_print}->{"Eiruv Tavshilin"} = $NOTIME;
   }

   # Days 1 and 2:
   my $first_day = $list_of_days[$first_day_idx];
   add_prenotes($first_day, $BOLD . $first_day_name);
   # Any unusual Shacharis time must be done by the calling routine
   $first_day->{to_print}->{Shacharis} = $yom_tov_shacharis;
   delete $first_day->{to_print}->{"Earliest Tefillin"};
	delete $first_day->{to_print}->{"Likras Shabbos for Boys"};
   if ($first_day->{day_of_week} eq "Sat")
   {
            move_shabbos_shacharis_earlier($first_day);
            # starting in 5772 Mr. Deutsch said the shiur will take place even on Shabbat - Yom Tov
            # (In previous years, the shiur was deleted.)
   }
   #delete $first_day->{to_print}->{"Chumash Shiur"};

   my $second_day = $list_of_days[$first_day_idx+1];
   add_prenotes($second_day, $BOLD . $second_day_name);
   $second_day->{to_print}->{Shacharis} = $yom_tov_shacharis;
   delete $second_day->{to_print}->{"Earliest Tefillin"};
	delete $second_day->{to_print}->{"Likras Shabbos for Boys"};
   if ($second_day->{day_of_week} eq "Sat")
   {
            move_shabbos_shacharis_earlier($second_day);
   }
   #delete $second_day->{to_print}->{"Chumash Shiur"};

   my $first_sunset = get_sunset($first_day);
   my $first_sunrise = get_sunrise($first_day);
   $first_day->{to_print}->{Sunset} = $first_sunset;
   $first_day->{to_print}->{Sunrise} = $first_sunrise;
   $first_day->{to_print}->{"Latest Sh'ma"} = compute_shma($first_sunrise,$first_sunset);

   my $second_sunset = get_sunset($second_day);
   my $second_sunrise = get_sunrise($second_day);
   $second_day->{to_print}->{Sunset} = $second_sunset;
   $second_day->{to_print}->{Sunrise} = $second_sunrise;
   $second_day->{to_print}->{"Latest Sh'ma"} = compute_shma($second_sunrise,$second_sunset);


    ### NOW (summer 2011) completely rewriting the Yom Tov Mincha algorithm to streamline the algorithm and
    #   eliminate all the little fixes.

    # Ideally Mincha should be at the same time both days of yom tov, but there are exceptions.
    # Set flags for the exceptions
    my $first_day_set = 0;
    my $second_day_set = 0;

    if ($first_day->{day_of_week} eq "Fri")
    {
        # Yom tov rishon on Friday can be only 7th day Pesach, or Shavuos.
        # Both of these are during DST when summer Friday Mincha rules are in force.
        # Keep the two Minchas as usual for a Friday - early one before Plag, and 7:15
        if ($first_day->{to_print}->{Mincha} !~ "7:15")
        {
            croak "Yom tov rishon on Friday without DST!?\n";
        }
        $first_day->{to_print}->{Mincha} .= $BOLD;
        $first_day_set = 1;
        # Shabbos Candle Lighting for Friday afternoon is already set so no need to change it.

        # Second day is on Shabbos, so just keep regular Shabbos Mincha times, including early one (6:00).
        $second_day_set = 1;

        # For Saturday night, change Motzoai Shabbos to Motzoai Shabbos and Yom Tov.
        $second_day->{to_print}->{"Motzoai Shabbos & Y.T."} =  $second_day->{to_print}->{"Motzoai Shabbos"};
        delete $second_day->{to_print}->{"Motzoai Shabbos"};

        # AB I decided NOT to cancel Avos when 2nd day Shavuos is on Shabbos.
        # Though maybe the Neilas HaChag would take up the whole time until Maariv?
        # Avos was listed in the bulletin in 2006, but I don't know whether it ended up being cancelled.
        # In 2009 there was Avos, but we were in galus (due to renovation) so it was in a different location from the Neilas HaChag.
        # Next time will be in 2020 (5780), so we will have to reevaluate then.
        #delete $second_day->{to_print}->{Avos};  # AB corrected bug, although I wonder whether the shuir may happen on Shavuos.
        #delete $second_day->{to_print}->{Shiur};   # This never matters as it's outside the range of any yom tov
        #####   What about the "Women's Avos"?  We list it in handle_pirkei_avos() according to the usual schedule, so it would not be listed.
    }
    else # first day is not Friday
    {
        $first_day->{to_print}->{"Candle Lighting $START_BOLD" . "after$END_BOLD"} = add_minutes($first_sunset,45);

        if ($second_day->{day_of_week} ne "Fri")  # AB added this condition
        {
            # the second day is neither Friday nor Shabbos, so it has a regular Motzoai Yom Tov listing
            $second_day->{to_print}->{"Motzoai Yom Tov"} = add_minutes($second_sunset,45);
        }
    }

    if ($has_neilas_hachag && $second_day->{day_of_week} ne "Fri")
    {
        if ($second_day->{day_of_week} ne "Sat")
        {
            $second_day->{to_print}->{Mincha} =
                        $BOLD . round_down_to_5_minutes(subtract_minutes($second_sunset,$neilas_hachag_mincha_length));
            $second_day_set = 1;
        }
        $second_day->{to_print}->{"Neilas Hachag"} = "after Mincha";
    }

    # Mincha is longer on Rosh HaShana than on the 3 regalim so set the lengths accordingly:
    my $is_rh =  ($first_day_name =~ /[Ff]irst.*[dD]ay.*[Rr]osh.*[Hh]a[Ss]hana/);
    my $mincha_before_sunset =         ($is_rh) ?  $rosh_hashana_mincha_length :   $yom_tov_mincha_length;
    my $shabbos_mincha_before_sunset = ($is_rh) ?  $shabbos_rh_mincha_length :   $shabbos_no_ss_mincha_length;
    my $mincha_before_plag           = ($is_rh) ?  $friday_rh_mincha_length  :   $yom_tov_mincha_length;

    if ($first_day->{day_of_week} eq "Sat")
    {
        #  There is no Shalosh Seudos in shul, so Mincha can be a little later than a regular Shabbos.
        #  Also there is no early (6:00) Mincha
        # (especially since the time for Maariv is not listed, so we are assuming people stay after the main Mincha).
        # (Relevant case is first day Pesach - see what happens for 2012)
        $first_day->{to_print}->{Mincha} = round_down_to_5_minutes(subtract_minutes($first_sunset,$shabbos_mincha_before_sunset));
        if ($first_day_name =~ /Shemini/)
        {
            $first_day->{to_print}->{Mincha} =
            			$BOLD . subtract_minutes($first_day->{to_print}->{Mincha}, $shemini_atzeres_mincha_earlier);
            # In 2015 decided to make Mincha earlier on Shemini Atzeres to allow more time for auction
        }

        if (defined ($first_day->{to_print}->{Shiurim}))
        {
            $first_day->{to_print}->{Shiurim} = subtract_minutes($first_day->{to_print}->{Mincha},60);
        }
        if (defined ($first_day->{to_print}->{"Navi Shiur"}))
        {
            $first_day->{to_print}->{"Navi Shiur"} = subtract_minutes($first_day->{to_print}->{Mincha}, get_Navi_length($first_day));
        }
        ### Adding 2:00(2:30) Mincha Gedola for same reason as when erev yom tov falls on Shabbos,
        ### but presumably not for Rosh HaShana since morning davening ends so late!
        if (!$is_rh)
        {
            $first_day->{to_print}->{Mincha} = $shabbos_no_ss_early_mincha . $separator . $first_day->{to_print}->{Mincha};
        }
        $first_day_set = 1;

        # No need to cancel Avos and Nach shiurim, because first day Shavuos is never on Shabbos,
        # and the other yamim tovim are outside of the initial Avos and Nach schedule periods anyway.
        #delete $first_day->{to_print}->{Avos};
        #delete $first_day->{to_print}->{Shiur};
        # Candle lighting is already listed "after" the Motzoai Shabbos time, so it replaces the Motzoai Shabbos listing.
        delete $first_day->{to_print}->{"Motzoai Shabbos"};
    }
    elsif ($first_day_name =~ /Shemini/)
    {
    	$first_day->{to_print}->{Mincha} =
    		$BOLD . round_down_to_5_minutes(subtract_minutes($first_sunset, $mincha_before_sunset + $shemini_atzeres_mincha_earlier));
	$first_day_set=1;
    }


    if (!$first_day_set && !$second_day_set)
    {
        # Neither day's Mincha has been set yet, so we set them to be equal based on the earliest of the two sunsets:
        my $earliest_sunset = (is_earlier($first_sunset, $second_sunset)) ?
                                                $first_sunset :
                                                $second_sunset;
        my $common_mincha = round_down_to_5_minutes(subtract_minutes($earliest_sunset, $mincha_before_sunset));
        $first_day->{to_print}->{Mincha} = $common_mincha;
        $first_day_set = 1;
        $second_day->{to_print}->{Mincha} = $common_mincha;
        $second_day_set = 1;

        if ($second_day->{day_of_week} eq "Fri" #&& !$is_rh
                                                            )
        # R' Felder said on 12 Elul 5773 to have only one Mincha on Rosh HaShana, despite previous discussion as recorded below.
        # But in the end they reinstated the early Mincha at 6:00 on Rosh HaShana (2013)!
        {
            # If second day is Friday we might adjust for early Shabbos
            warn "Check Mincha times carefully for yom tov on Friday: " . print_date($second_day) . "\n";
            my $second_day_mincha;  # we will store it here before putting it in the structure

            if (is_earlier("7:15",$common_mincha) && !$is_rh)
            {
                # In this case we are moving the second day Mincha from the "common" time to 7:15.
                # This results in the two days having two different Mincha times,
                # so there is no point using the "common" time for the first day either.
                # That is, we "unset" the first day Mincha here, so that it will be redetermined on its own later.
                # R' Felder said not to apply this 7:15 rule on Rosh HaShana (5774 - keep Mincha at 7:20)
                $second_day_mincha = $BOLD . "7:15";
                $first_day_set = 0;
            }
            else
            {
                $second_day_mincha = $common_mincha;
            }

            # Now we still need to add the "early" Friday Mincha on the second day.  This can happen even if the main Mincha is before 7:15.
            # On Rosh HaShana and Succos 5771 there was early Friday Mincha, but not on Simchas Torah.
            # Have to check condition carefully - was this only a function of time, or is it because Simchas Torah lunch is late?
            # Executive decision on Wed. Sept. 21, 2011 set the same rule as for regular Fridays, inconsistent with what happened in 5771:
            if (!is_earlier($common_mincha,"7:00") )
            {
                my $early_mincha = round_down_to_5_minutes(subtract_minutes($second_day->{to_print}->{"Plag HaMincha"}, $mincha_before_plag));
                # Don't worry about the 7:10 -> 7:05 problem as second day Shavuos is never on Friday.
                $second_day_mincha = $early_mincha . $separator . $second_day_mincha;
            }
            ## BUG - need to get rid of asterisk from candle lighting on Second Day of Rosh Hashana 5778.
            ##          Also need to make sure asterisk gets added for e.g. Second Day of Succos 5771.

            $second_day->{to_print}->{Mincha} = $second_day_mincha;
        }
    }

    if (!$first_day_set)
    {
        $first_day->{to_print}->{Mincha} = round_down_to_5_minutes(subtract_minutes($first_sunset, $mincha_before_sunset));
        $first_day_set = 1;     # probably don't need the flag any more, but just in case
    }

    if (!$second_day_set)
    {
        $second_day->{to_print}->{Mincha} = round_down_to_5_minutes(subtract_minutes($second_sunset, $mincha_before_sunset));
        $second_day_set = 1;     # probably don't need the flag any more, but just in case
    }

	## They added a 6:00 Mincha on both days of Shavuos, starting in 5776.
	## (Presumably not on Friday; and Shabbos is already covered by previous rules.)
	if ($first_day_name =~ /Shavuos/ && $first_day->{day_of_week} ne "Fri")
	{
		$first_day->{to_print}->{Mincha} = $shavuos_early_mincha . $separator . $first_day->{to_print}->{Mincha};
		$second_day->{to_print}->{Mincha} = $shavuos_early_mincha . $separator . $second_day->{to_print}->{Mincha};
	}

    # Maariv never gets printed on Erev yom tov or yom tov itself
    delete $first_day->{to_print}->{Maariv};
    remove_notes($first_day, "Tehillim after late Maariv");

    delete $second_day->{to_print}->{Maariv};
    remove_notes($second_day, "Tehillim after late Maariv");

#    #####
#    ## TODO:  ULTIMATELY THE YOM TOV MINCHA ALGORITHM NEEDS TO BE COMPLETELY REWRITTEN.
#    ## TOO MANY INEFFICIENT PATCHWORK FIXES.
#
#   # On Friday, make it 7:15 if it's earlier.
#   # On Shabbos, make it the normal shabbos time.
#   if ($first_day->{day_of_week} ne "Sat")
#   {
#      # Then mincha is at least **12** minutes before sunset.
#      #  This was originally set to 20 minutes before sunset, but in 5769 we realized it was way too early.
#      #  However, be careful with days when there is Neilas HaChag, and also Rosh HaShana.
#      my $mincha = subtract_minutes($sunset,12);
#      $mincha = round_down_to_5_minutes($mincha);
#      $first_day->{to_print}->{Mincha} = $mincha;
#   }
#   else
#   {
#      # The main Shabbos Mincha time does not change because of yom tov.
#      # However, in the summer there may have been an early Mincha scheduled, and I think people will not want it on the first day of yom tov.
#      $first_day->{to_print}->{Mincha} =~ s/\S+\///;
#   #   # Nothing special for Shabbos, but cancel Avos
#   #   # and Nach shiurim
#   #   # AB This was coded wrong initially, so I fixed the bug,
#   #   # but then I commented it out because it's never needed.
#   #   # First day Shavuos is never on Shabbos,
#   #   # and the other yamim tovim are outside of the initial Avos or Nach schedule periods anyway.
#   #   delete $first_day->{to_print}->{Avos};
#   #   delete $first_day->{to_print}->{Shiur};
#   }
#
#
#   # Mincha on Rosh HaShana takes about 5 minutes longer than other yamim tovim,
#   # so we start 5 minutes earlier.
#   # This applies both to weekdays and to Shabbos,
#   ######### MAYBE 10 minutes for weekdays, since we made regular yom tov later????******************
#   # but it must be implemented before checking for the Friday 7:15 rule (on the second day).
#   if ($first_day_name =~ /[Ff]irst.*[dD]ay.*[Rr]osh.*[Hh]a[Ss]hana/)
#   {
#      if ($first_day->{day_of_week} ne "Sat")
#      {
#            $first_day->{to_print}->{Mincha} = subtract_minutes($first_day->{to_print}->{Mincha}, 10);
#      }
#      else
#      {
#            $first_day->{to_print}->{Mincha} = subtract_minutes($first_day->{to_print}->{Mincha}, 5);
#
#            if (defined ($first_day->{to_print}->{Shiurim}))
#            #  This won't matter any more because shiurim are cancelled on Rosh HaShana
#            {
#                $first_day->{to_print}->{Shiurim} = subtract_minutes($first_day->{to_print}->{Shiurim}, 5);
#
#                ## This is no longer an issue since we don't have the Tehillim any more
#                # warn "Rosh HaShana ".$first_day->{Eyear}."/" . $first_day->{Hyear} . " falls on Shabbos - do shiurim conflict with Tehillim?";
#            }
#      }
#
#   }
#
#   if ($first_day->{day_of_week} eq "Fri")
#   {
#      # Make mincha at 7:15 if it's later.
#      if (is_earlier("7:15",$first_day->{to_print}->{Mincha}))
#      {
#         $first_day->{to_print}->{Mincha} = $BOLD . "7:15";
#      }
#   }
#   else # Not Friday
#   {
#      $first_day->{to_print}->{"Candle Lighting $START_BOLD" . "after$END_BOLD"} = add_minutes($sunset,45);
#      # Delete any existing Havdala info.
#      delete $first_day->{to_print}->{"Motzoai Shabbos"};
#   }
#
#   # Maariv never gets printed on Erev yom tov or yom tov itself
#   delete $first_day->{to_print}->{Maariv};
#   remove_notes($first_day, "Tehillim after late Maariv");
#
#   # Day 2:
#
#
#   if ($second_day->{day_of_week} ne "Sat")
#   {
#      # Then mincha is at least 12 minutes before sunset.
#      my $mincha = subtract_minutes($sunset,12);
#      $mincha = round_down_to_5_minutes($mincha);
#
#      # Mincha on Rosh HaShana takes about 10 minutes longer than other yamim tovim,
#      # so we start 10 minutes earlier.
#      # Second day RH is never on Shabbos,
#      # but this change must be implemented before checking for the Friday 7:15 rule (on the second day).
#      if ($second_day_name =~ /[Ss]econd.*[dD]ay.*[Rr]osh.*[Hh]a[Ss]hana/)
#      {
#         $mincha = subtract_minutes($mincha, 10);
#      }
#
#      if (is_earlier("7:15",$mincha) &&
#          $second_day->{day_of_week} eq "Fri")
#      {
#         # On Friday, Mincha is 7:15 at the latest.
#         $mincha = $BOLD . "7:15";
#      }
#      elsif ($first_day->{day_of_week} ne "Sat")
#      {
#         # If neither day is shabbos, then make the two days line up,
#         # unless one of the days is a Friday with early mincha.
#         if (is_earlier($mincha,$first_day->{to_print}->{Mincha}))
#         {
#            $first_day->{to_print}->{Mincha} = $mincha;
#         }
#         else
#         {
#            #  AB:  I think this condition is redundant, because we're already working within the
#            #  condition that second day is not Sat, so obviously first day is not Fri.  Doesn't matter.
#            if ($first_day->{day_of_week} ne "Fri" ||
#                ($first_day->{to_print}->{Mincha} !~ /7:15/))
#            {
#               $mincha = $first_day->{to_print}->{Mincha};
#            }
#         }
#      }
#      $second_day->{to_print}->{Mincha} = $mincha;
#      if ($second_day->{day_of_week} ne "Fri")  # AB added this condition
#      {
#         $second_day->{to_print}->{"Motzoai Yom Tov"} = add_minutes($sunset,45);
#      }
#   }
#   else # Saturday night
#   {
#      # Change Motzoai Shabbos to Motzoai Shabbos and Yom Tov.
#      $second_day->{to_print}->{"Motzoai Shabbos and Y.T."} =
#         $second_day->{to_print}->{"Motzoai Shabbos"};
#      delete $second_day->{to_print}->{"Motzoai Shabbos"};
#
#      # AB I decided NOT to cancel Avos when 2nd day Shavuos is on Shabbos.
#      # Avos was listed in the bulletin in 2006, and I have no reason to believe that it ended up being cancelled.
#      ## Cancel Avos and Nach shiurim
#      #delete $second_day->{to_print}->{Avos};  # AB corrected bug, although I wonder whether the shuir may happen on Shavuos.
#      #delete $second_day->{to_print}->{Shiur};
#
#   }
#
#   # Maariv never gets printed on Erev yom tov or yom tov itself
#   delete $second_day->{to_print}->{Maariv};
#   remove_notes($second_day, "Tehillim after late Maariv");
#
#
#   if ($has_neilas_hachag && $second_day->{day_of_week} ne "Fri")
#   {
#         if ($second_day->{day_of_week} ne "Sat")
#         {
#            $second_day->{to_print}->{Mincha} = subtract_minutes($second_day->{to_print}->{Mincha},5);
#         }
#         $second_day->{to_print}->{"Neilas Hachag"} = "after Mincha";
#   }
}

sub add_yizkor($)
{
    #  This puts in the Yizkor time and the Mishnayos shiur for the shalosh regalim
    #  Do not use this for Yom Kippur as the time is different and there is no Mishnayos
    my ($idx) = @_;
    my $day = $list_of_days[$idx];
    $day->{to_print}->{Yizkor} = $yizkor_time;
	####  For 5775 they said to cancel the Mishnayos,
	#### probably because R' Moshe Teichner used to give it and he no longer lives here
    #$day->{to_print}->{Mishnayos} = $mishnayos_time;
}


sub add_drasha($)
{
    # This is for Shabbos Shuva and Shabbos Haggadol
    # Schedule the Drasha 70 minutes before main Mincha
    # and make other relevant changes

    ### Note sunset ranges (always DST now):
    #   Shabbos Shuva   6:45 - 7:43
    #   Shabbos Hagodol 7:30 - 8:08

    my ($day) = @_;
    my $old_mincha = $day->{to_print}->{Mincha};
    # Strip off the earlier mincha time, if it's there.
    # the \S+ (non-whitespace characters) includes the non-breaking space 00a0,
    # but this is dangerous because if we ever switch the separator to include ordinary whitespace it will mess up!
    #$mincha =~ s/\S+\///;
    $old_mincha =~ s/\S+$separator//;       # this one should work regardless of how $separator changes!
    my $main_mincha = subtract_minutes ($old_mincha, 5);    # allowing for extra leeway in case the Drasha goes late
    my $drasha = subtract_minutes($main_mincha,70);
    my $early_mincha = subtract_minutes($drasha, $early_shabbos_mincha_length);
    if (is_earlier($early_shabbos_mincha,$early_mincha))
    {
        # this is not likely to happen, but if it does the Mincha time might be confusing
        # Maybe it will happen in a late year such as 2024?  Yes.  No, not any more since we increased $early_shabbos_mincha_length
        $early_mincha = $early_shabbos_mincha;
        warn "Early Mincha before the Drasha is rescheduled at $early_mincha on " . print_date($day) .
        ", even though this is more than $early_shabbos_mincha_length minutes before the Drasha.  Investigate this. \n\n";
    }
    my $mincha = $BOLD . $early_mincha . $separator . $main_mincha;
    $day->{to_print}->{Drasha}  = $drasha;
    $day->{to_print}->{Mincha} = $mincha;

    # Cancel Nach shiur and shiurim, in case they were scheduled
    delete $day->{to_print}->{Shiur};
    delete $day->{to_print}->{Shiurim};
    delete $day->{to_print}->{"Navi Shiur"};
}

sub add_late_shacharis($)		# for days when yeshiva kids are off
{
	my ($day) = @_;
	my $old_shach = $day->{to_print}->{Shacharis};
	if ($old_shach !~ /8:30/ && $day->{day_of_week} ne "Sat")
	{
		$day->{to_print}->{Shacharis} =
			$old_shach . " / " # $separator
				. $START_BOLD . "8:30" . $END_BOLD;    # decide whether to use $separator
	}
}


sub handle_fast_days
{
   # Handle all fast days except Tisha B'Av.
   # I handle Taanis Esther (but nothing Purim-specific)
   my ($abt, $te, $sabt,$tg) = ("Asarah B'Teves",
                    "Taanis Esther",
                    "Shiva Asar B'Tammuz",
                    "Tzom Gedalia");

   # This is how the fasts are spelled in the input file.
   my %alternate_names = (
         $abt => "Asara B'Tevet", #this is how it's spelled by Hebcal even when selecting ashkenazi pronunciation (bug in Hebcal)
         $te => "Ta'anis Esther", #in the sephardi pronunciation version it was "Ta'anit Esther"
         $sabt => "Tzom Tammuz",
         $tg => "Tzom Gedaliah",
   );

   my %fast_month = (
         $abt => "Tevet",
         $te => "Adar",
         $sabt => "Tamuz",
         $tg => "Tishrei",
      );
   my %fast_day = (
         $abt => 10,
         $te => 13,
         $sabt => 17,
         $tg => 3,
   );
   print "Handling Fast days.\n";
   foreach my $year (keys (%hebrew_years))
   {
      foreach my $name ($abt, $te, $sabt, $tg)
      {
         my ($day_idx, $day);
         if ($name eq $te)
         {
            # Two issues with Taanis Esther.
            # First, it is the only fast day that gets
            # pushed to an earlier date if it falls
            # on Shabbos.  Second, it falls in Adar or
            # Adar II, so the best way to find it is
            # to just start from Nisan and work back.
            $day_idx = find_hebrew_date($year,"Nisan",1);
            while ($day_idx  &&
                   $list_of_days[$day_idx]->{Hday} != 13)
            {
               $day_idx--;
            }

            if (!$day_idx)
            {
               # Check if the calendar ends in Adar.
               if ($list_of_days[$#list_of_days]->{Hmon} =~ /Adar/)
               {
                  croak "I find Purim based on Nisan, so please don't end the calendar in Adar\n";
               }
               next;
            }

            if ($list_of_days[$day_idx]->{day_of_week} eq "Sat")
            {
               # Push back to Thursday.
               $day_idx -= 2;
            }
            if ($day_idx < 1)
            {
               next;
            }
            $day = $list_of_days[$day_idx];
         }
         else # Other fast days.
         {
            $day_idx = find_hebrew_date($year,$fast_month{$name},$fast_day{$name});
            if (!$day_idx)
            {
               next;
            }
            $day = $list_of_days[$day_idx];
            if ($day->{day_of_week} eq "Sat")
            {
               $day_idx++;
               if ($day_idx > $#list_of_days)
               {
                  croak "This is just a bad idea\n";
               }
               $day = $list_of_days[$day_idx];
            }
         }

         # Make sure that the input file agrees with us.
         my $input_name = $alternate_names{$name};
         my $other = $day->{other_info};
         if (!defined($other) || $other !~ /$input_name/)
         {
            warn "Date disagrees with Hebcal for $name/$input_name in year $year.\n";
            ### This flags a bug in Hebcal 3.7, where they incorrectly move 10 Tevet from Friday to Thursday.  In fact we fast on Friday.
            # Hebcal fixed this in version 3.9.
         }

         # Okay, we have the day, now do the times.
         add_prenotes($day, $BOLD . $name);


         ##  I spoke to Rabbi Felder on Motzai Shabbos Aug. 7, 2010, about fast-beginning times.  He said use 16.1 degrees.
         # The problem is I don't think we can derive that directly from sunrise/sunset data alone.
         # For now, hard-coding 5771 times from other sources
         # but we will need a permanent solution.
         # Maybe we (David?) can find a way to extract 16.1 data from Hebcal?
         $day->{to_print}->{"Fast begins"} = "TBA!"; # this will remain if not overridden
         my @sixteen_point_one = (
            [2010,9,12,"5:26"],
            [2010,12,17,"6:12"],
            [2011,3,17,"6:02"],
            [2011,7,19,"4:01"],     # time from 2007
            [2011,10,2,"5:51"]      # time from 2007
         );
         foreach my $time (@sixteen_point_one)
         {
#            if ($day_idx == index_of_date(@{$time}))   # neat! don't need to restrict array to [0..2] before passing to index_of_date!
#            {
#                $day->{to_print}->{"Fast begins"} = $time->[3];
#            }
         }

         # We now compute the 16.1 degrees time
         # by hand.  It seems to agree within one minute for the cases above.
         my $cos_zenith = cos((90+16.1)*pi/180);
         my $time = compute_suntime($day,$cos_zenith,"Sunrise");
#    print "$day->{Eyear}/$day->{Emon}/$day->{Eday} old value was " . $day->{to_print}->{"Fast begins"} . "\n";
         $day->{to_print}->{"Fast begins"} = $time;
#    print "$day->{Eyear}/$day->{Emon}/$day->{Eday} new value was " . $day->{to_print}->{"Fast begins"} . "\n";

         if ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/
                        && !defined($day->{public_holiday})
                        && $name ne $tg)
                        # Tzom Gedalia Shacharis time will be overridden by Slichos anyway; don't want to clutter with tefillin time
         {
            $day->{to_print}->{Shacharis} = $fast_day_shacharis;
            # we may have set the early Shacharis too early, so check it against the tefillin time
            check_tefillin_time($day, 1);
         }

         my $sunset = get_sunset($day);
         $day->{to_print}->{Sunset} = $sunset;
         $day->{to_print}->{Mincha} = $BOLD . round_down_to_5_minutes(subtract_minutes($sunset,30)) . "$only";

         if ($day->{day_of_week} ne "Fri")  # AB added this condition
         {
            my $maariv = round_up_to_5_minutes(add_minutes($sunset,30));    # at least 30 minutes after sunset

            # Add a 9:30 maariv on weekday Asara B'Teves, and
            # on Taanis Esther that does not fall on erev Purim (maybe not).
            #  AB Should we remove 9:30 Maariv if 10 Tevet is on a public holiday?  We may have to reverse the order of the functions.
            #  (First happens in 5775 / Jan. 2015.) DONE as we did reverse the order and now relying on previously set $fast_day_shacharis
            if (($name eq $abt && ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/
                        && !defined($day->{public_holiday}))
            			# $day->{to_print}->{Shacharis} =~ $fast_day_shacharis
		)
                    # || ($name eq $te && $day->{Hday} != 13)  # This was added last-minute in 5767 but we'll remove it for 5770.
               )
            {
                $maariv .= $separator . "9:30";
            }
            else
            {
                $maariv .= "$BOLD$only";
                remove_notes($day, "Tehillim after late Maariv");  # This takes care of Purim night as well.
            }
            $day->{to_print}->{Maariv} = $maariv;
         }

	if (defined ($day ->{to_print}->{"Likras Shabbos for Boys"}))
		# This is Friday; need to reschedule Likras Shabbos based on the new Mincha time
	{
		$day ->{to_print}->{"Likras Shabbos for Boys"} =
				subtract_minutes($day->{to_print}->{Mincha}, $likras_shabbos_length);
	}

         # All fasts end 42 minutes after sunset.
         # TODO: 17 of Tamuz is unclear, it may be 45.
         $day->{to_print}->{"Fast ends"} = add_minutes($sunset,42) . "***";
         add_notes($day,"***For extenuating circumstances please consult the Rav");
      }
   }
}

sub handle_purim
{
   # Since Purim can be in either Adar or Adar II,
   # I just step back from the first of Nisan.
   print "Handling Purim.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my $first_of_nisan_idx = find_hebrew_date($year,"Nisan",1);
      my $purim_idx;
      if ($first_of_nisan_idx)
      {
            $purim_idx = $first_of_nisan_idx - 16;
      }
#      my $purim_idx = $first_of_nisan_idx;
#      while ($purim_idx > 0 &&
#             $list_of_days[$purim_idx]->{Hday} != 14)
#      {
#         $purim_idx--;
#      }
      if (!$purim_idx || $purim_idx <= 0)
      {
         next;
      }
      if ($purim_idx == 1)
      {
         # We'll need to handle Erev Purim, so this is silly.
         croak "Clearly a bad idea to start the calendar on Purim!\n";
      }
      # Purim can never be on Shabbos, so no need to worry about that.

      my $erev = $list_of_days[$purim_idx-1];
      add_prenotes($erev, $BOLD . "Erev Purim");

      my $megilla;
      if ($erev->{day_of_week} eq "Sat")
      {
         my $motz;
         $motz = $erev->{to_print}->{"Motzoai Shabbos"};
         $erev->{to_print}->{"Motzoai Shabbos & Maariv"} = $motz;
         delete $erev->{to_print}->{"Motzoai Shabbos"};

         # Make it at least 35 minutes after Motzoai Shabbos
         $megilla = round_up_to_5_minutes(add_minutes($motz,35));
         # In 5771 they decided to have a Megilla reading downstairs 10 minutes after the main one (for Motzai Shabbos only)
         $megilla = $megilla . $separator . add_minutes($megilla,10) . $separator . add_minutes($megilla,90);

         # in case Purim is before the clock change (such as 5770),
         # we need to cancel Avos UBanim that would take place Motzai Shabbos.
         # Note that if it's after the clock change, there's no reason to cancel Avos UBanim from Shabbos afternoon.
         delete $erev->{to_print}->{"Avos UBanim"};
      }
      else
      {
         my $sunset = get_sunset($erev);    # it's already printed because of the fast day
         # Maariv at least 35 minutes after sunset
         $erev->{to_print}->{Maariv} =
            round_up_to_5_minutes(add_minutes($sunset,35)) . "$only";
         $megilla = add_minutes($erev->{to_print}->{Maariv},15);
         # Second megilla reading is 90 minnutes after first.
         $megilla = $megilla . $separator . add_minutes($megilla,90);
      }
      $erev->{to_print}->{"Megillas Esther"} = $megilla;

      # Now daytime.
      my $day = $list_of_days[$purim_idx];
      add_prenotes($day, $BOLD . "Purim");
      my $sunrise = get_sunrise($day);
      my $sunset = get_sunset($day);
      # $day->{to_print}->{Sunrise} = $sunrise; # will be printed when calculating vasikin anyway
      $day->{to_print}->{Sunset} = $sunset;

      # It seems that we always want to have a vasikin minyan on Purim.
      # This was first done in 5769 when sunrise was late, after the clock change (and Purim was on a workday)
      # but then it was added for 5770 when sunrise is early and Purim is on Sunday.
      # The other minyanim have to juggle around, depending on how late sunrise is and whether or not it's a working day.
      # It's hard to pin down the rules, because things have changed over the years.
      # This will have to be reevaluated every year.

      # In all cases, Megilla is 40 minutes after Shacharis time (I think that's an intentional underestimate).

      my $vasikin = calculate_vasikin($day);
      # my $vasikin = round_down_to_5_minutes(subtract_minutes($sunrise,23));
      my $megilla_vasikin = add_minutes($vasikin, 40);

      if ($day->{to_print}->{Shacharis} =~ /$sunday_shacharis/
                    || defined($day->{public_holiday}))
      {
         # Sunday or Public Holiday
         # In 5764 and 5767 (both on Sunday) Shacharis was 7:00/8:30.
         # In 5765 (Good Friday) Shacharis was 7:00/7:45/8:30.
         # In 5768 (Good Friday) Shacharis was 7:00/7:30/8:30.
         # (Note that Purim will not fall on a public holiday again until 5863 / 2103.)
         # In 5770 we are setting Shacharis at vasikin/7:30/8:30.
         # Let's make that the rule, although if sunrise is very late (such as in 5774 and 5777) we may want to change this,
         # because the first two minyanim will be close together.
         # Of course when it is Sunday or public holiday, there would not be a minyan earlier than vasikin.
         # Note also that in 5777 Daylight-Saving Time begins on Purim!!

         $day->{to_print}->{Shacharis} = $BOLD . $vasikin . $separator . "7:30" . $separator . "8:30";

         # Okay, this is bad, but I'm sick of special rules for
         # things that change their order.  So I'm just going to
         # put an extra space after Esther for the megilla reading
         # in the morning.  Will anyone notice the difference?  Maybe.
         $day->{to_print}->{"Megillas Esther "} = $megilla_vasikin . $separator . "8:10" . $separator . "9:10";


#         if ($day->{day_of_week} eq "Fri")
#         {
#            # I don't think we need to worry about this any more as it's covered by the same rules as Sunday.
#            # This won't happen again until 5863 / 2103!
#            warn "The date " . print_date($day) . " appears to be Purim on a public holiday.\n";
#            warn "In 5765 we added 7:45 Shacharis with Megilla at 8:25; in 5768 we added 7:30 Shacharis with Megilla at 8:10.\n";
#            $day->{to_print}->{Shacharis} = "7:00/7:30/8:30";
#            $day->{to_print}->{"Megillas Esther "} = "7:40/8:10/9:10";
#         }
      }
      else
      {
         # Working day
         # Old rule was Shacharis 6:30/7:30, with Megilla 40 minutes after each Shacharis time, and extra Megilla at 9:30.
         # This worked until 5766.
         # In 5769, Purim fell two days after the new March clock change, so sunrise was very late at 7:38.
         # We moved the 6:30 Shacharis to 6:40, which was still way before vasikin, added vasikin, and 8:30.
         # In 5772, sunrise is very early at 6:41, so we have vasikin at 6:15 and then move the 7:30 to 7:15
         # Here is an attempt at a general rule:
         # (Modifying in 2016)

         if (is_earlier($vasikin,"6:35"))
         {
            # Vasikin will begin at 6:30 or earlier, possibly as early as 6:15 (in 2012)
            # do we want to add a 6:30 Shacharis if vasikin is significantly earlier?
            $day->{to_print}->{Shacharis} = $BOLD . $vasikin . $separator . "7:30" . $separator . "8:30";
            $day->{to_print}->{"Megillas Esther "} = $megilla_vasikin . $separator . "8:10" . $separator . "9:10";
            # Megilla always 40 minutes after each Shacharis
         }
#         if (is_earlier($sunrise,"6:58"))
#         {
#            # Vasikin will begin at 6:30 or earlier - do we want to add a 6:30 Shacharis if vasikin is significantly earlier?
#            # No, it seems we will make the second Shacharis one hour after the first, rather than 7:30.
#            # We are doing it this way first in 2012.
#            my $second_shacharis = add_minutes ($vasikin, 60);
#            my $second_megilla = add_minutes ($second_shacharis, 40);
#            $day->{to_print}->{Shacharis} = $BOLD . $vasikin . $separator . $second_shacharis . $separator . "8:30";
#            # Megilla always 40 minutes after each Shacharis
#            $day->{to_print}->{"Megillas Esther "} = $megilla_vasikin . $separator . $second_megilla . $separator . "9:10";
#         }
	elsif (is_earlier($vasikin, "7:00"))
	{
		# Vasikin will begin 6:35 or later, so we add the 6:30 first.
		# But we add a 7:30 as well, because vasikin is significantly earlier.
		# Not sure whether this is the right cutoff.
		$day->{to_print}->{Shacharis} = $BOLD."6:30".$separator . $vasikin . $separator . "7:30" . $separator . "8:30";
		$day->{to_print}->{"Megillas Esther "} =
				"7:10" . $separator . $megilla_vasikin . $separator . "8:10" . $separator . "9:10";
		check_tefillin_time($day, 0); # this won't change the Shacharis time
	}
         else
         {
            $day->{to_print}->{Shacharis} = $BOLD . "6:30" . $separator . $vasikin . $separator . "8:30";
            check_tefillin_time($day, 1); # this may end up changing the Shacharis time
            my $first_megilla;
            if ($day->{to_print}->{Shacharis} =~ /(\d:\d\d)/)
            {
                $first_megilla = add_minutes($1, 40);
            }
            else
            {
                croak "Bad Shacharis time on Purim\n";
            }
            $day->{to_print}->{"Megillas Esther "} = $first_megilla . $separator . $megilla_vasikin . $separator . "9:10";
         }
#         else
#         {
#            # This is what we ended up doing in 5769, when sunrise was very late at 7:38.  The 6:30 minyan was moved to 6:40.
#            # This does not quite follow the general rule, which we have now implemented above by calling check_tefillin_time.
#            $day->{to_print}->{Shacharis} = $BOLD . "6:40/$vasikin/8:30";
#            $day->{to_print}->{"Megillas Esther "} = "7:20/$megilla_vasikin/9:10";
#            check_tefillin_time($day);  # this may cause problems because Shacharis time may change and then megilla time will be messed up
#         }
      }
      #indicate_vasikin($day);

      $day->{to_print}->{"Yeshivas Mordechai HaTzaddik"} = "10:00-11:00";  # Check this? - for several years we were listing this as 10:15

      if ($day->{day_of_week} ne "Fri")
      {
         $day->{to_print}->{Mincha} = is_during_DST($day) ? $purim_mincha : $purim_mincha_standard; # added 1:00 Mincha in 2018
         $day->{to_print}->{Maariv} = $motz_purim_maariv;
         remove_notes($day, "Tehillim after late Maariv");
      }
	delete $day->{to_print}->{"Likras Shabbos for Boys"};

      my $shushan_purim_day = $list_of_days[$purim_idx+1];
      add_prenotes($shushan_purim_day, $BOLD . "Shushan Purim");
   }
   warn "Purim always needs to be checked carefully, including sunrise time, and Yeshivas Mordechai HaTzaddik.\n\n";
}

sub handle_chanukah
{
   # Main change for Chanukka is 6:45/6:50/7:30
   # minyan on weekdays.  Also, shabbos Chanukka starts at 9:00.
   # (This used to be only for Shabbos-Rosh Chodesh-Chanukka, but for 5772 we changed the rule to all Hallel days.)
   print "Handling Chanukka.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my $first_day_idx = find_hebrew_date($year,"Kislev",25);
      my $last_day_plus = find_hebrew_date($year,"Tevet",3);
      if (($first_day_idx && !$last_day_plus) ||
          (!$first_day_idx && $last_day_plus))
      {
         warn "You started or ended too close to chanuka!\n" .
              "Skipping Chanuka for $year\n\n";
         next;
      }

      if (!$first_day_idx)
      {
         next;
      }

      my $iday;
      if ($first_day_idx > 1)
      {
         my $erev = $list_of_days[$first_day_idx-1];
         add_prenotes($erev, $BOLD . "Erev Chanuka");
	delete $erev->{to_print}->{"Likras Shabbos for Boys"};
      }

      for ($iday = 0; $iday < 8; $iday++)
      {
         my $day = $list_of_days[$first_day_idx+$iday];
         $day || croak "Bad day\n";
         add_prenotes($day, $BOLD . "Chanuka");
         if ($day->{day_of_week} eq "Sat")
         {
            # Starting in 5772, we are moving Shacharis to 9:00 on all Shabbos Hallel days.
            # (Previously was only Shabbos-Rosh Chodesh-Chanukka.)
            move_shabbos_shacharis_earlier($day);
            ## Only issue is Rosh Chodesh.
            #if ($day->{Hday} == 1 ||
            #    $day->{Hday} == 30)
            #{
            #   $day->{to_print}->{Shacharis} = $shabbos_chol_hamoed_succos_shacharis;
            #   $day->{to_print}->{"Chumash Shiur"} = $chumash_shiur_special;
            #}
         }
         elsif ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/)
         {
            $day->{to_print}->{Shacharis} = $chanuka_shacharis;
         }
	if ($iday < 7)		# Don't need to do this on the last day of Chanukka; only on candle-lighting eves
	{
		delete $day->{to_print}->{"Likras Shabbos for Boys"};
	}
      }
   }
}

sub handle_tisha_bav  # includes labelling Shabbos Chazon and Shabbos Nachamu (AB),
                      #  and cancelling middle Shacharis until first Monday in Elul
{
   print "Handling Tisha B'Av.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my $day_idx= find_hebrew_date($year,"Av",9);
      if (!$day_idx)
      {
         next;
      }

      my $day = $list_of_days[$day_idx];

      if ($day->{day_of_week} eq "Sat")
      {
         # Tisha B'av gets pushed off to Sunday.
         $day_idx++;
         if ($day_idx > $#list_of_days)
         {
            croak "Bad day index for postponed Tisha B'av: $day_idx\n";
         }
         $day = $list_of_days[$day_idx];
      }

      if ($day_idx <= 1)
      {
         croak "Bad day index for Tisha B'av: $day_idx\n";
      }
      my $erev = $list_of_days[$day_idx-1];

      add_prenotes($erev, $BOLD . "Erev Tisha B'Av");
      add_prenotes($day, $BOLD . "Tisha B'Av");

      # Erev Tisha B'Av

      # List Chatzos
      my $sunrise = get_sunrise($erev);
      my $sunset = get_sunset($erev);
      my $shaa = minutes_per_shaa($sunrise,$sunset);
      my $chatzos = add_minutes($sunrise,$shaa*6);
      $erev->{to_print}->{Chatzos} = $chatzos;
      $erev->{to_print}->{"Fast begins at sunset"} = $sunset;

      if ($erev->{day_of_week} ne "Sat")
      {
         # I print Seuda Hamafsekes on weekdays only.
         $erev->{to_print}->{"Seuda Hamafsekes"} = $NOTIME;
         # Mincha is at least 1 hour and 20 minutes before sunset.
         $erev->{to_print}->{Mincha} =
            $BOLD . round_down_to_5_minutes(subtract_minutes($sunset,80)) . "$only";
         # Maariv is at least 30 minutes after sunset.
         $erev->{to_print}->{Maariv} =
            round_up_to_5_minutes(add_minutes($sunset,30));
         remove_notes($erev, "Tehillim after late Maariv");
      }
      else
      {
         # Shabbos.
         # Mincha is at least 2 hours before sunset.
         my $mincha = round_down_to_5_minutes(subtract_minutes($sunset,120));
         $erev->{to_print}->{Mincha} = $START_BOLD . $mincha . $END_BOLD;
         # AB: Shiurim need to be rescheduled to an hour before the new Mincha time
         $erev->{to_print}->{Shiurim} = subtract_minutes($mincha,60);
         # $erev->{to_print}->{"Navi Shiur"} = subtract_minutes($mincha,45);
         delete $erev->{to_print}->{"Navi Shiur"};  # was cancelled in 5779
         ## Re-adding early Mincha if the main Mincha is still late enough (didn't do this in 2012)
         # Notice sunset on erev Tisha B'Av can range from 8:23 to 8:57
         add_early_shabbos_mincha_if_applicable($erev);
	warn "Check Shabbos Mincha schedule for erev Tisha B'Av on " . print_date($erev) .  "\n";
	### NOTE IN 2016 THEY ADDED 2:30 MINCHA (the regular one was at 6:20)
	## Meaning:  If the main Mincha was early enough that we wouldn't add a 6:00 Mincha, then add 2:30:
	if ($erev->{to_print}->{Mincha} !~/$early_shabbos_mincha/)
	{
		$erev->{to_print}->{Mincha} = $shabbos_no_ss_early_mincha . $separator . $mincha . $BOLD; # forgot bold in 2019
	}

         # Until 2012 we scheduled Maariv at least 25 minutes after motzoai shabbos.
         # But in 2012 people complained it was too early for those who keep 72 min
         # so changing it to be at least 5 minutes after 72 min (Chanani's suggestion)
         # Might as well explicitly calculate it from sunset rather than retrieving the Motzoai Shabbos listing!
         #my $motzoai_shabbos =
         #   $erev->{to_print}->{"Motzoai Shabbos"};
         #defined ($motzoai_shabbos) or croak "No Motzoai Shabbos on shabbos!\n";
         $erev->{to_print}->{Maariv} =
            round_up_to_5_minutes(add_minutes($sunset,77));

         # Cancel Avos shiur, I guess.
         delete $erev->{to_print}->{Avos};
         #delete $erev->{to_print}->{"Avos UBanim "};		# Ittamar's message implied not to cancel Avos UBanim
         delete $erev->{to_print}->{"Women's Avos"};
         # remove Sunset listing because it's replaced with "Fast begins at sunset"
         delete $erev->{to_print}->{Sunset};
      }

      # Day of Tisha B'Av

      # List Chatzos
      $sunrise = get_sunrise($day);
      $sunset = get_sunset($day);
      $shaa = minutes_per_shaa($sunrise,$sunset);
      $chatzos = add_minutes($sunrise,$shaa*6);
      $day->{to_print}->{Chatzos} = $chatzos;
      $day->{to_print}->{Sunset} = $sunset;

      if ($day->{to_print}->{Shacharis} !~ /$sunday_shacharis/)
      {
         $day->{to_print}->{Shacharis} = $tisha_bav_weekday_shacharis;
      }
      else
      {
         $day->{to_print}->{Shacharis} = $tisha_bav_sunday_shacharis;
      }

      my $later_mincha =
         round_down_to_5_minutes(subtract_minutes($sunset,40));
      $day->{to_print}->{Mincha} = $BOLD . "2:00" . $separator . "4:30" . $separator . $later_mincha;   # 4:30 added in 2010
      $day->{to_print}->{Maariv} =
            round_up_to_5_minutes(add_minutes($sunset,30)) . "$BOLD$only";
      remove_notes($day, "Tehillim after late Maariv");
      $day->{to_print}->{"Fast ends"} = add_minutes($sunset,45) . "***";
      add_notes($day,"***For extenuating circumstances please consult the Rav");


      # AB: Shabbos before Tisha B'Av is Shabbos Chazon:
      my $chazon_idx = $day_idx - 1;  # This is erev Tisha B'Av; start working backward from here.
      while ($chazon_idx > 0 && $list_of_days[$chazon_idx]->{day_of_week} ne "Sat")
      {
         $chazon_idx--;
      }
      if ($chazon_idx > 0)
      {
         add_prenotes($list_of_days[$chazon_idx], $BOLD . "Shabbos Chazon");
      }


      # AB: Shabbos after Tisha B'Av is Shabbos Nachamu:
      my $nachamu_idx = $day_idx + 2;  # 9 Av is never on Friday so start looking 2 days after 9 Av.
      while ($nachamu_idx <= $#list_of_days && $list_of_days[$nachamu_idx]->{day_of_week} ne "Sat")
      {
         $nachamu_idx++;
      }
      if ($nachamu_idx <= $#list_of_days)
      {
         add_prenotes($list_of_days[$nachamu_idx], $BOLD . "Shabbos Nachamu");
      }

      # now cancel middle Shacharis from after 9 Av until the first Monday in Elul
      # NO!!! In 2011 the minyan continued throughout the summer, so we will not cancel it in future
#      my $idx = $day_idx + 1;
#      while ($idx <= $#list_of_days && $list_of_days[$idx]->{Hday} != 1)
#      {
#            if ($list_of_days[$idx]->{to_print}->{Shacharis} !~ /$sunday_shacharis|$shabbos_shacharis/)    # if needed, fix for public holidays
#            {
#               $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/\/\s?\d:\d\d?\s?//;   # if needed again, fix for new separator
#               # hopefully this will also take care of Rosh Chodesh correctly
#               #  This should also still work if we add whitespace before and after slashes (/) in lists of times
#               #  Not sure about non-breaking spaces though
#            }
#            $idx++;
#      }
#      while ($idx <= $#list_of_days && $list_of_days[$idx]->{day_of_week} ne "Mon")
#      {
#            if ($list_of_days[$idx]->{to_print}->{Shacharis} !~ /$sunday_shacharis|$shabbos_shacharis/)
#            {
#               $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/\/\s?\d:\d\d?\s?//;   # if needed again, fix for new separator
#            }
#            $idx++;
#      }

   }
}

sub list_misc_days()
{
   # Lists Yahrzeits of 2 former rabbis, Tu Bishvat,
   # Pesach Sheni, Tu B'Av, Purim Katan.
   # AB added Yom HaAtzmaut, Yom HaZikaron, Yom Yerushalayim.
   # AB Also changes Mincha time on Shabbos before Rabbi G. Felder's Yahrzeit.
   # Note - AB would prefer the spelling Yortzeit but Rabbi Felder always changes it manually to Yahrzeit anyway.
   print "Labelling Miscellaneous days.\n";
   foreach my $year (keys (%hebrew_years))
   {
      my $day;
      my $day_idx = find_hebrew_date($year,"Cheshvan",4);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         # changed from prenotes to notes based on Rabbi Felder's request
         add_notes ($day, $BOLD . "Yahrzeit of HaRav Yosef Weinreb zt\"l");
      }

      $day_idx = find_hebrew_date($year,"Tevet",24);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         # changed from prenotes to notes based on Rabbi Felder's request
         add_notes ($day, $BOLD . "Yahrzeit of HaRav Gedalia Felder zt\"l");

         # AB adding here:
         ###  Until 5768 there was a special shalosh seudos on the Shabbos before the yahrzeit,
         ###  so Mincha was earlier to allow extra time.
         ###  In 5769 we switched to a weekday program because of the renovation.
         ###  It is unclear whether in 5770 we will resume the shalosh seudos.
         ###  To be safe, we're scheduling Mincha earlier, but this is subject to change, of course!
         # In 5770 there was a big Motzai Shabbos program
         # For 5771 Brian G. said to keep the time early anyway - and there was the Shalosh seudos.
         while ($day_idx > 0 && $list_of_days[$day_idx]->{day_of_week} ne "Sat")
         {
            $day_idx--;
         }
         if ($day_idx > 0 && !$renovation)
         {
            $day = $list_of_days[$day_idx];
            # Starting with 5772 we've finally decided to make Mincha 10 minutes earlier than the regular Mincha time,
            # rather than at a constant 4:00, to avoid the problem of being too early when sunset is late.
            $day->{to_print}->{Mincha} =  $BOLD . subtract_minutes($day->{to_print}->{Mincha}, 10);
            # $day->{to_print}->{Mincha} =  $BOLD . "4:00";
            # Shiurim are at 3:40 anyway so they don't have to be rescheduled.
	#  But the Navi shiur might be later so we have to move it:
            my $navi = subtract_minutes($day->{to_print}->{Mincha}, get_Navi_length($day));
            if (is_earlier($navi,"3:40"))
            {
                $navi = "3:40";
            }
            $day->{to_print}->{"Navi Shiur"} = $navi;

            delete $day->{to_print}->{Shiur};   # this is the shiur after SS
            # Don't need this warning any more as we've solved the problem (5772)
#            my $sunset = $day->{to_print}->{Sunset};
#            if (is_earlier("5:04",$sunset))
#            {
#                # so regular Mincha would have been at least 4:35 and we are making it more than half an hour earlier!
#                # This will happen in 5769 and again in 5772
#                # (In 5769 it ended up getting cancelled due to the renovation, and they did a bo-bayom weeknight event instead.)
#                warn "Sunset is relatively late, at $sunset, on  " . print_date($day) . ",\n" .
#                     "the day of the special Shalosh Seudos for Rabbi Felder's Yahrzeit.\n" .
#                     "Consider rescheduling Mincha a little later.\n" .
#                     "We had this problem in 5766, where Shalosh Seudos ended early and everyone was waiting around for Maariv.\n" .
#                     "If Mincha is rescheduled, make sure that the extra flyer in the bulletin is also amended.\n\n";
#            }
         }
      }

      $day_idx = find_hebrew_date($year,"Sh'vat",15);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         add_prenotes ($day, $BOLD . "Tu BiShvat");
      }

      # The Knesset amended the Yom HaAtzmaut rules in 5764.
      $day_idx = find_hebrew_date($year,"Iyyar",5);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         if ($day->{day_of_week} eq "Sat")
         {
            $day_idx = $day_idx - 2;
         }
         elsif ($day->{day_of_week} eq "Fri")
         {
            $day_idx--;
         }
         elsif ($day->{day_of_week} eq "Mon")
         {
            $day_idx++;
         }
         if ($day_idx > 0 && $day_idx <= $#list_of_days)
         {
            add_prenotes ($list_of_days[$day_idx], $BOLD . "Yom HaAtzmaut");
         }
         $day_idx--;
         if ($day_idx > 0 && $day_idx <= $#list_of_days)
         {
            add_prenotes ($list_of_days[$day_idx], $BOLD . "Yom HaZikaron");
         }
      }

      $day_idx = find_hebrew_date($year,"Iyyar",14);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         add_prenotes ($day, $BOLD . "Pesach Sheini");
      }

      $day_idx = find_hebrew_date($year,"Iyyar",28);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         add_prenotes ($day, $BOLD . "Yom Yerushalayim");
      }

      $day_idx = find_hebrew_date($year,"Av",15);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         add_prenotes ($day, $BOLD . "Tu B'Av");
      }

      $day_idx = find_hebrew_date($year,"Adar I",14);
      if ($day_idx)
      {
         $day = $list_of_days[$day_idx];
         add_prenotes ($day, $BOLD . "Purim Katan");
         if ($day_idx < $#list_of_days)
         {
            $day = $list_of_days[$day_idx+1];
            add_prenotes ($day, $BOLD . "Shushan Purim Katan");
         }
      }
   }
}

sub list_vsain_tal_umotor()  # AB wrote this function
{
    foreach my $year (keys (%english_years))
    {
        my $idx = index_of_date($year, 12, 4);
#      my $idx = $index_of_first_day_of_the_month{"$year,12"};
      if ($idx)
      {
#         # Move to Dec. 4.
#         $idx = $idx+3;
         # Before a civil leap year it's Dec. 5.
         if ($year % 4 == 3)
         {
            $idx++;
         }
         if ($year > 2099)
         {
            croak "Tal UMatar algorithm needs to be adjusted for the Y2.1K Siddur Bug (so-named by Tzvi Goldman).\n";
            # Note - this croaks first in 2100, not 2099.  We correctly begin Tal UMatar on Dec. 5, 2099,
            # even though it does not immediately precede a leap year.
         }
         if ($idx <= $#list_of_days)
         {
            my $day = $list_of_days[$idx];
            if ($day->{day_of_week} eq "Fri")
            {
               $idx++;  # We don't start Tal UMatar on Friday night.
            }
            if ($idx <= $#list_of_days)
            {
                add_notes($list_of_days[$idx], $BOLD . "V'Sein Tal UMatar at Maariv");
            }
         }
      }
    }
}


sub birkat_hachamma()  # AB wrote this function
{
   foreach my $year (keys (%english_years))
   {
      #  I could have done this using the Hebrew year, and then the correct condition would be ($year % 28 == 1).
      #  But since the date is always April 8 (until the end of the 21st century) it's more natural to check the English year.
      #  Note that Birkat HaChamma was last in 1981 (1981 % 28 == 21) and will next be in 2009 (2009 % 28 == 21).
      if ($year % 28 == 21)
      {
         my $idx = index_of_date($year, 4, 8);
#         my $idx = $index_of_first_day_of_the_month{"$year,4"};
         if ($idx)
         {
#            # Move to April 8.
#            $idx = $idx+7;
#            if ($idx <= $#list_of_days)
            {
               my $day = $list_of_days[$idx];
               if ($day->{day_of_week} ne "Wed")
               {
                  croak "April 8 not on a Wednesday in a Birkat HaChamma year? $year We must have reached the 22nd century!\n";
               }
               my $sunrise = get_sunrise($day);
               $day->{to_print}->{Sunrise} = $sunrise;
               add_prenotes($day, $BOLD . "Birkas HaChamma");  # Maybe this should be after Shacharis or something.
               ## Note also that in 5769 we ended up scheduling Shacharis vasikin.
               warn "Shacharis should be scheduled attentively for Birkas HaChamma on ". print_date($day).".\n\n";
            }
         }
      }
   }
}


sub molad_to_text(@)
{
    my @molad = @_;
    return Date_to_Text_Long(@molad[0..2])." at ". $molad[3] . ":" . $molad[4] . " and ". $molad[5] . " seconds.";
}


#sub molad_to_text_old($)
#{
#    my ($molad) = @_;
#    return Date_to_Text_Long($molad->{year},$molad->{month},$molad->{day})." at ".
#                                $molad->{hour}.":".$molad->{min}." and ".$molad->{sec}." seconds.";
#}

sub kl_time_to_text(@)
{
    my ($hour, $min) = @_;
    # Note we ignore the seconds

    # we write our times using 12-hour clock
    my $suffix = ($hour < 12) ? " a.m." : " p.m.";
    if ($hour > 12)
    {
        $hour -= 12;
    }
    elsif ($hour == 0)
    {
        $hour = 12;
        if ($min == 0)
        {
            $suffix = " midnight";
            warn "There's a Kiddush Levana deadline at midnight.\n\n";
        }
    }

    my $kl_time = "$hour:$min$suffix";
    # Fix single-digit minutes
    $kl_time =~ s/:(\d[^\d])/:0$1/;
    return $kl_time;
}


sub add_molad(@)
{
    my @prev_molad = @_;
    my @molad_interval = (29,12,44,3.33333333334);     # better to be rounded up than down, because we truncate the seconds for KL
    my @next_molad = Add_Delta_DHMS(@prev_molad, @molad_interval);
    # It keeps only integer seconds so we have to add a second sometimes:   ### MAYBE NOT!!!!  It's keeping the fractional part as well
#    if ($next_molad[5] % 10 == 6)
#    {
#        $next_molad[5]++;
#    }
    return @next_molad;
}

#sub add_molad_old($$)
#{
#    my ($prev_molad,$next_molad) = @_;
#    ($next_molad->{year},$next_molad->{month},$next_molad->{day},$next_molad->{hour},$next_molad->{min},$next_molad->{sec}) =
#        Add_Delta_DHMS($prev_molad->{year},$prev_molad->{month},$prev_molad->{day},$prev_molad->{hour},$prev_molad->{min},$prev_molad->{sec},
#                     29,12,44,3.33333333333);
#    # It only keeps integer seconds so we have to add a second sometimes:
#    if ($next_molad->{sec} % 10 == 6)
#    {
#        $next_molad->{sec}++;
#    }
#}


sub get_kl_from_molad(@)
{
    my @molad = @_;
    my @half_month = (14,18,22,0);          # (Ignore half a chelek because we will round down to the nearest minute anyway.)
    my @time_difference = (0,-7,-21,0);     # difference between Jerusalem mean local time and EST.
    my @kiddush_levana = Add_Delta_DHMS(Add_Delta_DHMS(@molad,@half_month),@time_difference);
    my $DST_start = get_DST_start($molad[0]);
    my $DST_end = get_DST_end($molad[0]);
    my $kl_date = Date_to_Days(@kiddush_levana[0..2]);
    if (($kl_date > $DST_start && $kl_date < $DST_end) ||
        ($kl_date == $DST_start && $kiddush_levana[3] >= 2)   ||
        ($kl_date == $DST_end && $kiddush_levana[3] < 1))       # any time before 1:00 EST on the end-date should be converted to EDT
    {
        @kiddush_levana = Add_Delta_DHMS(@kiddush_levana,0,1,0,0);
    }

    #if ($kl_date == $DST_start-1 || $kl_date == $DST_start || $kl_date == $DST_end-1 || $kl_date == $DST_end)  # REFINE THIS CONDITION!!!
    #{
    #    warn "Kiddush Levana deadline is on or right before a clock change day: ". molad_to_text(@kiddush_levana). " Be very careful!\n\n";
    #}

    return @kiddush_levana;
}


#sub get_kl_from_molad_old($$)
#{
#    # Half the month is 14 days, 18 hours and 22 minutes.
#    # (Ignore half a chelek because we will round down to the nearest minute anyway.)
#    # But then we subtract 7 hours and 21 minutes difference between Jerusalem mean local time and EST.
#    # This gives 14 days 11 hours 1 minute.
#    my @half_month = (14,11,1,0);
#    my ($molad, $kl) = @_;
#    ($kl->{year},$kl->{month},$kl->{day},$kl->{hour},$kl->{min},$kl->{sec}) =
#        Add_Delta_DHMS($molad->{year},$molad->{month},$molad->{day},$molad->{hour},$molad->{min},$molad->{sec},@half_month);
#    # Remember to add an hour if we are on DST.
#    my $DST_start = Date_to_Days(Nth_Weekday_of_Month_Year($kl->{year},3,7,2));
#    my $DST_end = Date_to_Days(Nth_Weekday_of_Month_Year($kl->{year},11,7,1));
#    my $kl_date = Date_to_Days(($kl->{year},$kl->{month},$kl->{day}));
#    if (($kl_date > $DST_start && $kl_date < $DST_end) ||
#        ($kl_date == $DST_start && $kl->{hour} >= 2)   ||
#        ($kl_date == $DST_end && $kl->{hour} < 1))
#    {
#        ($kl->{year},$kl->{month},$kl->{day},$kl->{hour},$kl->{min},$kl->{sec}) =
#            Add_Delta_DHMS($kl->{year},$kl->{month},$kl->{day},$kl->{hour},$kl->{min},$kl->{sec},0,1,0,0);
#    }
#    if ($kl_date == $DST_start-1 || $kl_date == $DST_start || $kl_date == $DST_end-1 || $kl_date == $DST_end)
#    {
#        warn "Kiddush Levana deadline is on or right before a clock change day: ". molad_to_text($kl). " Be very careful!\n\n";
#    }
#}

sub handle_kiddush_levana()
{
    my @molad = (2004,10,14,2,0,0);    #  Molad for Cheshvan 5765 was on a whole hour
    my $number_of_months = 1080;            #   arbitrary number of months to calculate, though this takes us to the next whole-hour molad
    print "Base molad was on ". molad_to_text(@molad) . "\n";
    print "Calculating Kiddush Levana deadlines for $number_of_months months.\n";
    for (1..$number_of_months)
    {
#        print molad_to_text(@molad);
        my @kiddush_levana = get_kl_from_molad(@molad);
#        print "Kiddush levana deadline at year $kiddush_levana[0], month $kiddush_levana[1], .....\n";
#        print "Kiddush levana deadline at ". molad_to_text(@kiddush_levana);
        my $kl_index = index_of_date(@kiddush_levana[0..2]);
#        print (@kiddush_levana[3..4]."\n");
        my $kl_time = kl_time_to_text(@kiddush_levana[3..4]);
#        print $kl_index;
#        print "ARE WE HERE YET?";
        if ($kl_index)
        {
            my $kl_day = $list_of_days[$kl_index];
            my $kl_note;
            # choosing 30 minutes after sunset as the earliest deadline to list on a given day;
            # otherwise list it the previous night
            if ($kiddush_levana[3] >= 17 && is_earlier(add_minutes(get_sunset($kl_day),30),$kl_time))
            {
                $kl_note = "Kiddush Levana only until $kl_time";
                #  Have not added note such as in Av 5769, saying "Last full night for KL" when next day's deadline is early
            }
            else
            {
                # The deadline has to be written on the previous day
                if ($kiddush_levana[3] == 0 ||
                    ($kiddush_levana[3] < 8 && is_earlier($kl_time, subtract_minutes(get_sunrise($kl_day),30))))
                {
                    $kl_note = "Last night for Kiddush Levana (until $kl_day->{day_of_week} $kl_time)";
                    $kl_note =~ s/Sat/Shabbos/;
                }
                else
                {
                    $kl_note = "Last night for Kiddush Levana (all night)";
                }
                $kl_index--;
                $kl_day = $list_of_days[$kl_index];
            }
            if ($kl_index)  # need this condition in case subtracted 1 above
            {
                add_notes($kl_day, $BOLD . $kl_note);
                if ($kl_index+1 <= $#list_of_days && (is_during_DST($kl_day) != is_during_DST($list_of_days[$kl_index+1])))
                {
                    warn "Kiddush Levana deadline is the night of a clock change: ". molad_to_text(@kiddush_levana). " Be very careful!\n\n";
                }

                # Now if the deadline falls on Friday night or yom tov, list an earlier reminder:
                # First deal with Friday night
                if ($kl_day->{day_of_week} =~ "Fri" && $kl_index>1)
                {
                    #  In case the deadline is Friday night, I'm not going to worry that Thursday night may have been yom tov,
                    # because the only relevant yamim tovim are Pesach and Succos, whose first days never fall on Thursday night,
                    # so the only way Thursday night could be yom tov is if it were the second night,
                    # meaning that the original Friday night deadline was on the 17th of the month, which is impossible (even in the Far East).
                    add_notes($list_of_days[$kl_index-1], $BOLD . "Last ideal night for Kiddush Levana");
                }
                #  Now yom tov:  need to check for 14th or 15th of Nisan or Tishrei
                elsif ($kl_day->{Hmon} =~ /Tishrei|Nisan/ && $kl_day->{Hday} =~ /14|15/)
                {
                    # Need to move back until we reach a night that is not yom tov or Friday night
                    my $warning_index = $kl_index-1;
                    my $warning_day = $list_of_days[$warning_index];
                    while ($warning_index > 0 && ($warning_day->{day_of_week} =~ "Fri" || $warning_day->{Hday} =~ 14))
                    {
                        $warning_index--;
                        $warning_day = $list_of_days[$warning_index];
                    }
                    if ($warning_index)
                    {
                        add_notes($warning_day, $BOLD . "Last ideal night for Kiddush Levana");
                    }
                }
            }
        }
        # now go to the following month's molad
        @molad = add_molad(@molad);
    }
    print "Calculated Kiddush Levana deadlines until molad of ". molad_to_text(@molad) ."\n";

    ### If there is a lunar eclipse visible here before the calculated deadline, manually replace the note

    #  December 2010 lunar eclipse is after the calculated deadline so no change
    #  June 2011 eclipse not visible here
    # December 2011 eclipse after deadline
    #  April 2014 eclipse after deadline

    # For October 2014:
    handle_eclipse(2014,10,7);

    # April 2015 eclipse not visible here

    # For September 2015:
    handle_eclipse(2015,9,27);

    # For January 2018 (barely visible here, partial eclipse leading to moonset just before U2):
    handle_eclipse(2018,1,30);

    # July 2018 eclipse not visible here
    # January 2019 eclipse after deadline

    warn "Lunar eclipses considered only until 2020.  Beyond then, Kiddush Levana is calculated based on the molad only." .
        " The deadline may be earlier if there is a lunar eclipse.\n\n";

    # handle_kiddush_levana_5770(); ## Don't need this any more!!
}


sub handle_eclipse($$$)
{
    # inserts an earlier kiddush levana deadline based on a lunar eclipse, replacing a later deadline for that month
    # parameters are year, month, day
    # assumes the eclipse occurs before the calculated deadline

    my $idx = index_of_date(@_);
    if ($idx)
    {
        # First, remove any already-listed deadline on the given date
        remove_notes($list_of_days[$idx], "Kiddush Levana");
        # add the corrected note
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (only until lunar eclipse)");
        # in case the calculated deadline was one or two days later, remove it
        $idx++;
        if ($idx)
        {
            remove_notes($list_of_days[$idx], "Kiddush Levana");
        }
        $idx++;
        if ($idx)
        {
            remove_notes($list_of_days[$idx], "Kiddush Levana");
        }
    }
}




#sub handle_kiddush_levana_old()
#{
#    ##  TODO:  Write a general algorithm for Kiddush Levana
#    my @moladot;
#    my $base_molad = {};
#    $base_molad->{year} = 2004;
#    $base_molad->{month} = 10;
#    $base_molad->{day} = 14;
##    $base_molad->{time} = "2:00";
#    $base_molad->{hour} = 2;
#    $base_molad->{min} = 0;
#    $base_molad->{sec} = 0;
##    $base_molad->{chalakim} = 0;
#    push @moladot, $base_molad;
##    print @moladot[0]->{year}."\n";
#
##    my $test_molad = $moladot[0];
##    print @test_molad;
#    print "Base molad was on ". molad_to_text($base_molad) . "\n";
##    print "Base molad was on ". Date_to_Text($test_molad->{year},$test_molad->{month},$test_molad->{day}) .
##                                        " at " . $test_molad->{time} . " and " . $test_molad->{chalakim} . " chalakim.\n";
##    print "Base molad was on ". Decode_Day_of_Week(Day_of_Week(@base_molad[0..2]));
##    print "Base molad is ".@base_molad[0..@base_molad];
#
#    print "Calculating moladot for 87 years.\n";
#    for (my $i=0;$i<1080;$i++)
#    {
#        my $prev_molad = $moladot[$#moladot];
#        my $next_molad = {};
#
#        add_molad($prev_molad,$next_molad);
##    my ($year2,$month2,$day2, $hour2,$min2,$sec2) =
##      Add_Delta_DHMS($prev_molad->{year},$prev_molad->{month},$prev_molad->{day}, 2,0,0,
##                     29,12,44,3.333333);
##        print "Next molad is at " . molad_to_text($next_molad)."\n"; # Date_to_Text($year2,$month2,$day2). $hour2 . $min2 . $sec2 . "\n";
#        push @moladot, $next_molad;
#    }
#
#    foreach my $molad (@moladot)
#    {
##        print "Molad at ". molad_to_text($molad)."\n";
#        my $kl = {};
#        get_kl_from_molad($molad, $kl);
##        print "Kiddush Levana until ". molad_to_text($kl)."\n";
#        my $index = index_of_date($kl->{year},$kl->{month},$kl->{day});
#
#
#        ## This is the basic output but it needs to be fixed.
#        if ($index)
#        {
#            add_notes($list_of_days[$index], $BOLD . "KL until today at ". $kl->{hour}.":".$kl->{min});
#        }
#    }
#
#    handle_kiddush_levana_5770();
#}


sub handle_kiddush_levana_5770()    #This is not used any more!!
{
    ##  TODO:  Write a general algorithm for Kiddush Levana

    # For now, I'm just entering times manually.
    warn "Kiddush Levana needs to be done more generally, as it is programmed manually for 5769 and 5770.\n\n";

    my $idx = index_of_date(2008,9,14);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Monday 1:15 a.m.)");
    }

    $idx = index_of_date(2008,10,12);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
        }
    }

    $idx = index_of_date(2008,11,12);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Thursday 1:43 a.m.)");
    }

    $idx = index_of_date(2008,12,11);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2009,1,10);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Sunday 3:11 a.m.)");
    }

    $idx = index_of_date(2009,2,8);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2009,3,10);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Wednesday 5:40 a.m.)");
    }

    $idx = index_of_date(2009,4,7);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
        }
    }

    $idx = index_of_date(2009,5,7);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
        }
    }

    $idx = index_of_date(2009,6,6);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2009,7,6);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2009,8,4);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last full night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Kiddush Levana only until 9:20 p.m.");
        }
    }

    $idx = index_of_date(2009,9,3);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2009,10,1);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx+=2;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Kiddush Levana only until 10:48 p.m.");
        }
    }

    $idx = index_of_date(2009,11,1);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }



    $idx = index_of_date(2009,12,1);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Kiddush Levana only until 11:16 p.m.");
    }

    $idx = index_of_date(2009,12,30);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2010,1,28);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Shabbos 12:44 a.m.)");
        }
    }

    $idx = index_of_date(2010,2,27);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2010,3,28);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Tuesday 3:12 a.m.)");
        }
    }

    $idx = index_of_date(2010,4,27);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2010,5,27);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (until Friday 4:40 a.m.)");
    }

    $idx = index_of_date(2010,6,24);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
        }
    }

    $idx = index_of_date(2010,7,25);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2010,8,23);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
    }

    $idx = index_of_date(2010,9,21);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Last night for Kiddush Levana (all night)");
        }
    }

    $idx = index_of_date(2010,10,21);
    if ($idx)
    {
        add_notes($list_of_days[$idx], $BOLD . "Last ideal night for Kiddush Levana");
        $idx++;
        if ($idx)
        {
            add_notes($list_of_days[$idx], $BOLD . "Kiddush Levana only until 8:21 p.m.");
        }
    }


}

#sub indicate_vasikin($)

sub calculate_vasikin($)
{
    # This will calculate the time for Shacharis k'vasikin on a particular day,
    # assuming it is one of the particular holidays for which a vasikin length is specified in %vasikin_length.
    # It will return the time followed by two asterisks,
    # and will also indicate on the following line that the time listed earlier for Shacharis is k'vasikin.
    # Also prints the sunrise time for the day
    # Currently to be used for Hoshana Rabba, Simchas Torah, Purim, and Shavuos.
    my ($day) = @_;
    my $hmonth = $day->{Hmon};
    my $hday = $day->{Hday};
    my $length = $vasikin_length{"$hday,$hmonth"};
    if (!defined($length))
    {
        croak "No Vasikin length defined for $hday,$hmonth\n";
    }
    my $sunrise = get_sunrise($day);
    $day->{to_print}->{Sunrise} = $sunrise;
    my $vasikin = round_down_to_5_minutes(subtract_minutes($sunrise,$length));
    $vasikin .= "***";

    # these lines are from a previous version
    #my $shacharis = $day->{to_print}->{Shacharis};
    ## print "Shacharis on ". print_date($day). " is at " . $shacharis . " including vasikin.\n";
    #if ($shacharis !~ /\*\*/)
    #{
    #    croak "Vasikin minyan needs to be labelled with asterisks on " . print_date($day) . "\n" .
    #        "Shacharis is now listed as $shacharis \n";
    #}
    $day->{to_print}->{"***K'vasikin"} = $NOTIME;
    return $vasikin;
}


sub handle_pirkei_avos()
{
    # List the chapter of pirkei avos each week according to the standard schedule
    # This is currently used for the "Women's Shiur", but we will also save it as a separate record so that the info is available
    print "Handling Pirkei Avos.\n";
    foreach my $year (keys (%hebrew_years))
    {
        # last day of Pesach in chu"l is 22 Nisan, and 23 is never Shabbos, so earliest possible date for first Perek is 24 Nisan
        my $day_idx = find_hebrew_date($year,"Nisan",24);
        if ($day_idx)
        {
            # Now move forward to Shabbos
            while ($day_idx < $#list_of_days && $list_of_days[$day_idx]->{day_of_week} ne "Sat")
            {
                $day_idx++;
            }

            ###  There are always exactly 22 Shabbatot from after Pesach (chu"l) until Rosh Hashana,
            #   but we skip one of them if it is Shavuos or 8/9 Av, in which case there are only 21 weeks of scheduled Pirkei Avos.
            #   To keep it simple, we count the weeks up to 22, and track separately whether we have skipped one.

            my $week = 1;       # to count the number of weeks elapsed from the beginning (will be incremented even if we skip that week)
            my $skipped = 0;    # to track whether we've skipped a week for Shavuos or 8/9 Av
            while ($day_idx < $#list_of_days && $week <= 22)        # 22 Shabbatot from after Pesach until Rosh HaShana
            {
                my $day = $list_of_days[$day_idx];
                # must exclude Shavuos and 8/9 Av
                if ($day->{prenotes} =~ /Tisha|Second/)     # can't say Shavuos because that would also include Erev Shavuos
                {
                    $skipped = 1;
                }
                else
                {
                    my $perek;
                    if ($week == 22)
                    {
                        $perek = "5-6";
                    }
                    elsif ($week == 21)
                    {
                        $perek = "3-4";
                    }
                    elsif ($week == 20 && $skipped)
                    {
                        $perek = "1-2";
                    }
                    else
                    {
                        $perek = ($week - $skipped) % 6;
                        $perek =~ s/0/6/;
                    }
                    $day->{perek} = $perek;
                    $day->{to_print}->{"Women's Avos"} = "#" . $perek . " " . $womens_avos;
		if (is_earlier (get_sunset($day), add_minutes($womens_avos, 75)))
		{
			warn "Early sunset relative to Women's Avos shiur on " . print_date($day) . ".\n";
		}
                }
                $day_idx += 7;
                $week++;
            }
        }
        else    # warn if the start date isn't available but the end date is
        {
            if ($hebrew_years{$year+1})    # next Rosh Hashana exists
            {
                warn "Avos chapters not scheduled for year $year.\n";
            }
        }
    }
}





sub apply_special_quirks()
{
    # changes that are limited to one or a small number of particular occasions, not describable by any permanent rule

    # The 8:00 Sunday Shacharis was cancelled throughout summer 2009 (even though originally scheduled)
    # so we now omit it in the bulletin for September and October 2009 (including Labour Day and Thanksgiving),
    # until it resumes after Simchas Torah
    my $idx = index_of_date(2009,9,6);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/8:00\///;
    }

    $idx = index_of_date(2009,9,7);  # Labour Day
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/8:00\///;
    }

    $idx = index_of_date(2009,9,13);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/8:00\///;
    }

    $idx = index_of_date(2009,9,27);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Slichos} =~ s/7:45\///;
    }

    $idx = index_of_date(2009,10,12);  # Thanksgiving
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Shacharis} =~ s/8:00\///;
    }


    # Friday early Mincha started in spring 2009 at 164 Shelborne temporary location,
    # but discontinued when we changed to a different temporary location.
    # So we remove it from Sept. 2009 when printing the 5770 calendar.
    $idx = index_of_date(2009,9,4);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Mincha} =~ s/6:\d\d\///;
    }

    $idx = index_of_date(2009,9,11);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Mincha} #= "7:15";  #
                                                   =~ s/6:00?\///; # need the ? bcs at this point stored as 6:0
    }

    # Again in Sept. 2011 there was a rule change, so keep old rule for backward compatibility with what was printed:
    $idx = index_of_date(2011,9,23);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Mincha} =~ s/5:\d\d\///;
    }

    # Mr. Deutsch's Chumash Shiur was at 8:30 until Rosh HaShana 5770, when it is changing to 8:15.
    #  Keep it at 8:30 for the first two weeks of September until the change.
    $idx = index_of_date(2009,9,5);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{"Chumash Shiur"} = "8:30";
        $idx += 7;
        if ($idx)
        {
            $list_of_days[$idx]->{to_print}->{"Chumash Shiur"} = "8:30";
        }
    }

    # In 2010 we scheduled early Shabbos Mincha to run until Yom Kippur, and get earlier than 6:00 in order to be 20 minutes before the Shiurim.
    # This rule is changed for 2011, but since it's already printed in Sept. 2010, keep the old rule then:
    $idx = index_of_date(2010,9,4);
    if ($idx)
    {
        $list_of_days[$idx]->{to_print}->{Mincha} = "5:55/7:15";
    }
    $idx = index_of_date(2010,9,25);
    if ($idx)
    {
        # Strip off the earlier mincha time, for the same reason as above
        $list_of_days[$idx]->{to_print}->{Mincha} =~ s/\S+\///;
    }


    # Certain events such as Kapparos are scheduled on an ad hoc basis every year:
#    $idx = index_of_date(2009,9,24);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], $BOLD . "Kapparos");     # this ended up getting removed from the calendar before printing
#    }
#
#    $idx = index_of_date(2009,10,7);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], $BOLD . "Simchas Bais HaShoeivah");
#    }
#
#    $idx = index_of_date(2010,11,17);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], $BOLD . "120th Anniversary Dinner - A Lifetime of Achievements");
#    }

    my @bold_notes = (
        [2009,9,24,  "Kapparos"],     # this ended up getting removed from the calendar before printing I think
        [2009,10,7,  "Simchas Bais HaShoeivah"],
        [2010,9,26,  "Simchas Bais HaShoeivah"],
        [2010,11,17, "120th Anniversary Dinner - A Lifetime of Achievements"],
        [2011,9,5, "Annual BBQ at Earl Bales Park"],
        [2011,10,17,  "Simchas Bais HaShoeivah"],
        [2011,11,27, "SSCM eZone Family Day"],
        [2011,12,18, "Youth Chanuka Party"],
        [2012,3,4, "Youth Purim Party"],
        [2012,9,3, "Annual BBQ at Earl Bales Park 5 p.m."],   # this is rescheduled from an earlier date (twice)
    );

    foreach my $note (@bold_notes)
    {
        $idx = index_of_date(@{$note});   # neat! don't need to restrict array to [0..2] before passing to index_of_date!
        if ($idx)
        {
            add_notes ($list_of_days[$idx], $BOLD . $note->[3]);
        }
    }



    warn "Need to schedule Tickets, Kapparos, Succah Decorating, Simchas Bais HaShoeivah, and other ad-hoc events each year.\n\n";


    my @tickets = (     # just add any ticket sales dates and times to this array.
        [2010,8,29,"7:30-9:30"],
        [2010,8,30,"7:30-9:30"],
        [2010,8,31,"7:30-9:30"],
        [2010,9,1,"7:30-9:30"],
        [2010,9,2,"7:30-9:30"],
        [2010,9,4,"10:00-12:30"],
        [2010,9,5,"7:30-9:30"],
        [2010,9,6,"7:30-9:30"],
        [2011,9,18,"9:00 a.m. - 12:00 noon"],
        [2011,9,19,"9-11 a.m.; 7:30-9:30 p.m."],
        [2011,9,20,"9-11 a.m.; 7:30-9:30 p.m."],
        [2011,9,21,"9-11 a.m."],
        [2011,9,22,"9-11 a.m.; 7:30-9:30 p.m."],
        [2011,9,24,"10:30 p.m.-12:45 a.m."],
        [2011,9,25,"9:00 a.m. - 12:00 noon"],
        [2012,9,5,"7:30-9:30 p.m."],
        [2012,9,6,"7:30-9:30 p.m."],
        [2012,9,8,"10:30 p.m.-12:45 a.m."],
        [2012,9,9,"9:30 a.m. - 12:00 noon; 7:30-9:30 p.m."],
        [2012,9,11,"7:30-9:30 p.m."],
        [2012,9,12,"9:30 a.m. - 1:30 p.m.; 7:30-9:30 p.m."],
        [2013,9,1,"7:30-9:30 p.m."],    # there are other dates in August 2013 but they won't get printed in 5774 calendar anyway
	[2014,9,10, "7:30-9:30 p.m."],
	[2014,9,11, "10:00-11:30 a.m."],
	[2014,9,14, "9:30 a.m. - 12:00 noon"],
	[2014,9,15, "7:30-9:30 p.m."],
	[2014,9,16, "10:00-11:30 a.m.; 7:30-9:30 p.m."],
	[2014,9,17, "7:30-9:30 p.m."],
	[2014,9,20, "10:30 p.m.-12:45"],	# removed a.m. to fit on one line
	[2014,9,21, "9:30 a.m. - 12:00 noon"],
	[2014,9,22, "7:30-9:30 p.m."],

    );

    foreach my $ticket (@tickets)
    {
        $idx = index_of_date(@{$ticket}[0..2]);
        if ($idx)
        {
            $list_of_days[$idx]->{to_print}->{"Tickets"} = $ticket->[3];
        }
    }

    warn "If any rules are changed from one year to the next, decide whether times in Sept. and Oct. should be ".
            "backward compatible with what was already printed, and add changes into the following array accordingly.\n\n";
    my @quirks = (
        #  add stuff here!!!

        # to be compatible with previously printed calendar for Sept. 2010 using Hebcal sunset times
        # (and anyway the weekdays only run until Tuesday so it doesn't matter that sunset on Thu is earlier)
        [2010,9,5,"Mincha","7:30"],
        [2010,9,5,"Maariv","8:00/9:30"],
        [2010,9,6,"Mincha","7:30"],
        [2010,9,6,"Maariv","8:00/9:30"],
        [2010,9,7,"Mincha","7:30"],
        [2010,9,7,"Maariv","8:00/9:30"],
        [2010,9,12,"Mincha",$BOLD . "7:05 only"],
        [2010,9,19,"Mincha","7:05"],
        [2010,9,19,"Maariv","7:35/9:30"],
        [2010,9,20,"Mincha","7:05"],
        [2010,9,20,"Maariv","7:35/9:30"],
        [2010,9,21,"Mincha","7:05"],
        [2010,9,21,"Maariv","7:35/9:30"],
        ## once Succos starts, go with new times (unless bulletin isn't distributed by then?)

        ## Women's shiur started in 2011, now being scheduled for 2012. Obviously this needs to be done properly!
        ############   It's now done in handle_pirkei_avos()
        #  Still keep any other Sisterhood items
        [2011,9,24,"Sisterhood Shiur & Shalosh Seudos","4:30"],
#        [2012,4,21,"Women's Avos","#1 5:00"],
#        [2012,4,28,"Women's Avos","#2 5:00"],
#        [2012,5,5,"Women's Avos","#3 5:00"],
#        [2012,5,12,"Women's Avos","#4 5:00"],
#        [2012,5,19,"Women's Avos","#5 5:00"],
#        [2012,5,26,"Women's Avos","#6 5:00"],
#        [2012,6,2,"Women's Avos","#1 5:00"],
#        [2012,6,9,"Women's Avos","#2 5:00"],
#        [2012,6,16,"Women's Avos","#3 5:00"],
#        [2012,6,23,"Women's Avos","#4 5:00"],
#        [2012,6,30,"Women's Avos","#5 5:00"],
#        [2012,7,7,"Women's Avos","#6 5:00"],
#        [2012,7,14,"Women's Avos","#1 5:00"],
#        [2012,7,21,"Women's Avos","#2 5:00"],
#        [2012,8,4,"Women's Avos","#3 5:00"],
#        [2012,8,11,"Women's Avos","#4 5:00"],
#        [2012,8,18,"Women's Avos","#5 5:00"],
#        [2012,8,25,"Women's Avos","#6 5:00"],
#        [2012,9,1,"Women's Avos","#1-2 5:00"],
#        [2012,9,8,"Women's Avos","#3-4 5:00"],
#        [2012,9,15,"Women's Avos","#5-6 5:00"],

	# In 2015 the Women's Avos will change to 6:00, but keep 5:00 for the ones already scheduled in Sept. 2014:
	[2014,9,6,"Women's Avos","#2 5:00"],
	[2014,9,13,"Women's Avos","#3-4 5:00"],
	[2014,9,20,"Women's Avos","#5-6 5:00"],

  # Changing Shabbos Shacharis in 5780, but keep old ones for Sept-Oct 2019:
  [2019,9,7,"Shacharis", $shabbos_shacharis_5779],
  [2019,9,14,"Shacharis", $shabbos_shacharis_5779],
  [2019,9,21,"Shacharis", $shabbos_shacharis_5779],
  [2019,9,28,"Shacharis", $shabbos_shacharis_5779],
  [2019,10,5,"Shacharis", $shabbos_shacharis_5779],
  [2019,10,12,"Shacharis", $shabbos_shacharis_5779],

    );

#    warn "Schedule Women's Avos shiur properly!  Now done manually for 2012 only!\n";


    foreach my $quirk (@quirks)
    {
        $idx = index_of_date(@{$quirk});   # neat! don't need to restrict array to [0..2] before passing to index_of_date!
        if ($idx)
        {
            $list_of_days[$idx]->{to_print}->{$quirk->[3]} = $quirk->[4];
        }
    }


    #########  LAYOUT AND FORMATTING ISSUES   #################################


    ## On a crowded day with too many events in the prenotes, the day may take too many rows
    ## So we combine the prenotes with a dash in between.
    ## To do so, just add the date to this array:
    my @combine_prenotes = (
        [2010,12,4],
#        [2012,3,3],     # really for the 4 special parashiyot, should automatically combine them with the parasha as this is a common problem
#        [2012,3,17],       # DONE!!!
        [2014,3,15],
	[2014,12,20],	# Miketz - Chanuka
	[2015,4,18],
	[2015,5,9],
	[2015,12,12],	# Miketz - Chanuka
	[2016,6,11],
	[2016,8,13],
	[2016,8,20],
#	[2017,3,11],
	[2017,12,16],
	[2018,7,21],
    );

    foreach my $date (@combine_prenotes)
    {
        $idx = index_of_date(@{$date});
        if ($idx)
        {
            $list_of_days[$idx]->{prenotes} =~ s/,/ - /;
        }
    }

    $idx = index_of_date(@{[2016,8,20]});
    if ($idx)
    {
        $list_of_days[$idx]->{prenotes} =~ s/Shabbos //;
    }


    ## First half of December 2010 has too many lines so need to combine
#    $idx = index_of_date(2010,12,4);
#    if ($idx)
#    {
#        $list_of_days[$idx]->{prenotes} =~ s/,/ - /;
#    }

    # Sometimes the Excel box cuts of the bottoms of the letters in the bottom line.
#    $idx = index_of_date(2010,2,27);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx++;
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2010,4,27);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2010,9,10);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2010,9,30);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2011,3,20);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2011,9,30);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }
#    $idx = index_of_date(2011,10,20);
#    if ($idx)
#    {
#        add_notes($list_of_days[$idx], " ");
#    }

    # Sometimes the Excel box cuts of the bottoms of the letters in the bottom line.
    # This seems to happen when there are at least five (or marginally four) lines of text containing bold,
    # with no lines long enough to force an extra blank line.
    # We need to add a blank line at the end to fix this.
    # To do so, just add the date to this array:
    # THESE BLANK LINES (used to) CAUSE PROBLEMS WITH THE CSV WHEN MICHAEL MANN TRIES TO IMPORT IT TO THE WEBSITE
    # but we fixed it by not printing those lines in dump_csv.
    # Alternatively, for really crowded months, can set row height explicitly in set_up_for_printing function.
    my @add_blank_row = (
        [2010,2,27],
        [2010,2,28],
        [2010,4,27],
        [2010,9,10],
        [2010,9,30],
        [2011,3,20],
        [2011,9,24],
        [2011,9,30],
        [2011,10,1],
        [2011,10,20],
        [2011,11,27],
        [2011,12,24],
        [2012,3,24],
        [2012,3,31],
        [2012,5,28],
        [2012,8,18],
        [2012,9,26],
        [2012,10,9],
        [2013,2,23],
        [2013,3,9],
        [2013,3,25],
        [2013,9,26],
        [2013,10,5],
        [2013,10,18],
        [2013,11,2],
        [2013,12,4],
        [2014,6,28],
        [2014,8,9],
        [2014,9,25],
        [2014,10,3],
        [2014,10,25],
        [2015,10,6],
        [2016,10,25],
        [2016,11,5],
        [2017,3,11],
        [2017,3,12],
        [2017,10,21],
        [2017,12,16],
        [2018,1,30],
        [2018,5,28],
        [2018,8,11],
        [2018,8,25],
        [2018,10,2],
        [2019,10,22],
        [2020,7,30],
        [2020,10,11],
    );

#    if (!$output_csv)
    {

        foreach my $date (@add_blank_row)
        {
            $idx = index_of_date(@{$date});
            if ($idx)
            {
                add_notes ($list_of_days[$idx], " ");
            }
        }
    }
#    elsif ($output_excel)
#    {
#        croak "Can't do both Excel and CSV in the same run until we deal with the blank line issue. " .
#            "Set one of the flags \$output_csv or \$output_excel to 0 and then rerun.\n";
#    }


    # In some cases, the $separator makes the row too wide and the box gets too crowded.
    # To remove a single non-breaking space, add the entry to this array:
    #########  HAVEN'T TESTED THIS YET!!!!!!!!!
    my @remove_one_nbsp = (
        [2222, 10, 22, "Latest Sh'ma"],
    );

    foreach my $item (@remove_one_nbsp)
    {
        $idx = index_of_date(@{$item});
        if ($idx)
        {
            $list_of_days[$idx]->{to_print}->{$item->[3]} =~ s/$nbsp//;    # remove ONE non-breaking space
        }
    }


}





##################################
####                         #####
####  TIME UTILITY FUNCTIONS #####
####                         #####
##################################

sub clean_time($)
{
   # Return a cleaner string to represent the time
   # Remove decimals
   my $time = shift @_;
   $time =~ s/:(\d+)\.\d+([^\d])/:$1$2/g;
   $time =~ s/:(\d+)\.\d+$/:$1/g;
   # Fix single digit minutes
   $time =~ s/:(\d[^\d])/:0$1/g;
   $time =~ s/:(\d)$/:0$1/;
   return $time;
}
sub hour($)
{
   # Return the hour in the given time.
   my ($time) = @_;
   if ($time =~ /(\d\d?):\d\d?/)
   {
      return $1;
   }
   else
   {
      croak "Bad time parameter $time\n";
   }
}

sub minute($)
{
   # Return the minutes in the given time.
   my ($time) = @_;
   if ($time =~ /\d\d?:(\d\d?)/)
   {
      return $1;
   }
   else
   {
      croak "Bad time parameter $time\n";
   }
}

sub is_time ($)
{
   # Check if the given string is a valid time of day.
   my ($time) = @_;
   if ($time =~ /\d\d?:\d\d?/)
   {
      return 1;
   }
   else
   {
      return 0;
   }
}

sub is_earlier ($$)
{
   # Determine if the first time given is earlier than
   # the second.
   my ($first,$second) = @_;

   my $first_hr;
   my $first_min;
   my $second_hr;
   my $second_min;

   if ($first =~ /(\d\d?):(\d\d?)/)
   {
      $first_hr = $1;
      $first_min = $2;
   }
   else
   {
      croak "Error: Invalid first time parameter in is_earlier: $first." .
          "  Second is $second\n";
   }

   if ($second =~ /(\d\d?):(\d\d?)/)
   {
      $second_hr = $1;
      $second_min = $2;
   }
   else
   {
      croak "Error: Invalid second time parameter in is_earlier: $second\n" .
          "  First is $first\n";
   }

   if ($first_hr < $second_hr)
   {
      return 1;
   }
   elsif ($first_hr == $second_hr && $first_min < $second_min)
   {
      return 1;
   }
   else
   {
      return 0;
   }
}


sub round_down_to_5_minutes($)
{
   # Round time input down to nearest 5 minutes.
   # Just calls more general function.
   my ($time) = @_;
   return round_to_n_minutes($time, 5, 1);
}

sub round_up_to_5_minutes($)
{
   # Round time input UP to nearest 5 minutes.
   # Just calls more general function.
   my ($time) = @_;
   return round_up_to_n_minutes($time, 5);
}

sub round_to_5_minutes($)   # not used anywhere?
{
   # Round time input to nearest 5 minutes.  Just calls more general
   # function.
   my ($time) = @_;
   return round_to_n_minutes($time, 5, 0);
}

sub round_up_to_n_minutes($$)
{
    # Round time input UP to nearest multiple of n minutes.
    # Must always round up, not down.
    my ($time, $round) = @_;
    return round_to_n_minutes (add_minutes($time, $round-1), $round, 1);
}

sub round_to_n_minutes($$$)
{
   # Round time input down to nearest multiple of n minutes.
   # If always_down is set to 1, then it must round
   # down.  If not, it can round up.
   my ($time, $round, $always_down) = @_;

   my $hr;
   my $min;

   if ($time =~ /(\d\d?):(\d\d?)/)
   {
      $hr = $1;
      $min = $2;
   }
   else
   {
      croak "Invalid time parameter in round_to_n_minutes: $time\n";
   }

   if ($round > 30)
   {
      # It doesn't make much sense to round to more than
      # half an hour, and I'm suspicious if we're trying to.
      croak "Strange rounding request: $round\n";
   }

   if ($round % 5 != 0)
   {
      # It's very strange to round to something not a multiple
      # of 5.
      croak "Rounding to $round is weird!\n";
   }

   if ($min % $round != 0)
   {
      if ($always_down)
      {
         $min = $min - ($min % $round);
      }
      else
      {
         # Round to whichever is closer, up if equal.
         my $option1 = $min - ($min % $round);
         my $option2 = $min + $round - ($min % $round);
         my $diff1 = $min - $option1;
         my $diff2 = $option2 - $min;
         if ($diff2 <= $diff1)
         {
            $min = $option2;
         }
         else
         {
            $min = $option1;
         }

         if ($min == 60)
         {
            $min = "00";
            $hr++;
            if ($hr == 13)
            {
               $hr = 1;
            }
         }
      }
   }

   return "$hr:$min";
}


sub subtract_minutes($$)
{
   # Subtract a given number of minutes from the given time.
   my ($time, $subtract_val) = @_;
   my $hr;
   my $min;

   if ($time =~ /TBA/)
   {
#        print "RETURNING TBA \n \n";
        return $time;
   }
   elsif ($time =~ /(\d\d?):(\d\d?)/)
   {
      $hr = $1;
      $min = $2;
   }
   else
   {
      croak "Invalid time parameter $time\n";
   }

   $min = $min - $subtract_val;

   while ($min < 0)
   {
      $min += 60;
      $hr--;
      if ($hr == 0)
      {
         $hr = 12;
      }
   }

   return "$hr:$min";
}


sub add_minutes($$)
{
   # Add a given number of minutes from the given time.
   my ($time, $add_val) = @_;
   my $hr;
   my $min;

   if ($time =~ /(\d\d?):(\d\d?)/)
   {
      $hr = $1;
      $min = $2;
   }
   else
   {
      croak "Invalid time parameter $time\n";
   }

   $min = $min + $add_val;

   while ($min >= 60)
   {
      $min -= 60;
      $hr++;
      if ($hr == 13)
      {
         $hr = 1;
      }
   }

   return "$hr:$min";
}

sub minutes_per_shaa($$)
{
   # Compute the minutes in a shaa zmanit for the given
   # sunrise and sunset.  I.e. just divide the difference
   # between them (in minutes) by 12.
   my ($sunrise, $sunset) = @_;

   my $rise_hr = hour($sunrise);
   my $rise_min = minute($sunrise);
   my $set_hr = hour($sunset);
   my $set_min = minute($sunset);

   my $total_minutes = (12 + $set_hr - $rise_hr)*60;
   $total_minutes += $set_min;
   $total_minutes -= $rise_min;

   return ($total_minutes / 12);
}

sub get_sunset ($)
{
   my ($day) = @_;
   return $day->{sunset};
}

sub get_sunrise ($)
{
   my ($day) = @_;
   return $day->{sunrise};
}




##################################
####                         #####
####  DATE UTILITY FUNCTIONS #####
####                         #####
##################################

sub during_avos_season ($)
{
    # checks whether we are between the end of Pesach and Rosh HaShana.
    # (does not exclude special days like Shavuos or Tisha B'Av)
    # uses a hack because the other functions are already written
    my ($day) = @_;
    return (between_pesach_and_elul ($day) || between_shavuos_and_rosh_hashana ($day));
}

sub between_pesach_and_elul ($)
{
   # Are we currently between Pesach and Elul.  I don't
   # count Pesach, but I do count Rosh Chodesh Elul.
   # This is just for purposes of inserting the Avos shiur.
   my ($day) = @_;
   my $hmonth = $day->{Hmon};
   my $hday = $day->{Hday};
   my $month_idx = $hebrew_month_index{$hmonth};
   my $answer = 0;

   if (!$month_idx)
   {
      print "Year: " . $day->{Eyear} . " Month: " . $day->{Emon} .
            " Day: " . $day->{Eday} . "\n";
      croak "Error: Bad Hebrew month $hmonth.\n";
   }

   if ($month_idx > 7 && $month_idx < 12)
   {
      $answer = 1;
   }
   elsif ($month_idx == 7 && $hday > 22)
   {
      $answer = 1;
   }
   elsif ($month_idx == 12 && $hday == 1)
   {
      $answer = 1;
   }

   return $answer;
}

sub between_pesach_and_august ($)   # was used once for summertime Avos UBanim
{
   # Are we currently between the end of Pesach and the end of August.
   # This may be used for the Avos UBanim summer schedule.
   my ($day) = @_;
   my $Emon = $day->{Emon};
   my $hmonth = $day->{Hmon};
   my $hday = $day->{Hday};
   my $month_idx = $hebrew_month_index{$hmonth};
   my $answer = 0;

   if (!$month_idx)
   {
      print "Year: " . $day->{Eyear} . " Month: " . $day->{Emon} .
            " Day: " . $day->{Eday} . "\n";
      croak "Error: Bad Hebrew month $hmonth.\n";
   }

   if ($month_idx > 7 && $Emon < 9)
   {
      $answer = 1;
   }
   elsif ($month_idx == 7 && $hday > 22)
   {
      $answer = 1;
   }

   return $answer;
}

sub between_shavuos_and_rosh_hashana($)   # was used once for summertime Avos UBanim
{
   # Are we currently between Shavuos and Rosh Hashana.
   my ($day) = @_;
   my $hmonth = $day->{Hmon};
   my $hday = $day->{Hday};
   my $month_idx = $hebrew_month_index{$hmonth};
   my $answer = 0;

   if (!$month_idx)
   {
      croak "Error: Bad Hebrew month $hmonth\n";
   }

   if ($month_idx > 9 && $month_idx <= 12)
   {
      $answer = 1;
   }
   elsif ($month_idx == 9 && $hday > 7)
   {
      $answer = 1;
   }

   return $answer;
}

sub between_shavuos_and_chazon($)   # new rule for summertime Avos UBanim starting 5774
{
   # Are we currently between Shavuos and Shabbos Chazon.
   my ($day) = @_;
   my $hmonth = $day->{Hmon};
   my $hday = $day->{Hday};
   my $month_idx = $hebrew_month_index{$hmonth};
#   my $answer = 0;

   if (!$month_idx)
   {
      croak "Error: Bad Hebrew month $hmonth\n";
   }

    return ($month_idx == 9 && $hday > 7) || $month_idx == 10 || ($month_idx == 11 && $hday < 8);
}

sub between_shavuos_and_nachamu($)   # new possible rule for summertime Avos UBanim starting 5775
{
   # Are we currently between Shavuos and Shabbos Nachamu (inclusive).
   my ($day) = @_;
   my $hmonth = $day->{Hmon};
   my $hday = $day->{Hday};
   my $month_idx = $hebrew_month_index{$hmonth};
#   my $answer = 0;

   if (!$month_idx)
   {
      croak "Error: Bad Hebrew month $hmonth\n";
   }

    return ($month_idx == 9 && $hday > 7) || $month_idx == 10 || ($month_idx == 11 && $hday < 17);
}

sub yom_tov_season($)   # are we between Rosh HaShana and Isru Chag Sukkos, or around Pesach
{
	my ($day) = @_;
	my $hmonth = $day->{Hmon};
	my $hday = $day->{Hday};
	my $month_idx = $hebrew_month_index{$hmonth};

	if (!$month_idx)
	{
		croak "Error: Bad Hebrew month $hmonth\n";
	}

	return ($month_idx == 1 && $hday < 25) || ($month_idx == 7 && $hday >6 && $hday < 24);
}

sub from_DST_to_RH($)   # are we between the beginning of DST and Rosh HaShana
{
  my ($day) = @_;
  return (is_during_DST($day) && $hebrew_month_index{$day->{Hmon}} > 5);
}

sub get_Navi_length($)
{
  my ($day) = @_;
  return (from_DST_to_RH($day) ? 45 : 30);
}

sub get_good_friday_day_index($)    #### This function no longer used!!!
{

   my ($year) = @_;
   my ($day,$month);

   ###### Don't need this lookup table any more as we can use the Calc module!

#   # Return the index of Good Friday, based on a lookup-table.
#   # If the day isn't in our list, return 0.
#   # AB added to year 2020 from a website.
#   my %gf_year_to_day_map = (
#      2006 => "14.4",
#      2007 => "06.4",
#      2008 => "21.3",
#      2009 => "10.4",
#      2010 => "02.4",
#      2011 => "22.4",
#      2012 => "06.4",
#      2013 => "29.3",
#      2014 => "18.4",
#      2015 => "03.4",
#      2016 => "25.3",
#      2017 => "14.4",
#      2018 => "30.3",
#      2019 => "19.4",
#      2020 => "10.4",
#   );
#
#   if (!defined($gf_year_to_day_map{$year}))
#   {
#      croak "Error: No Good Friday information for year $year.  Script requires modification.\n";
#   }
#
#   my $munged_date = $gf_year_to_day_map{$year};
#   if ($munged_date =~ /(\d\d)\.(\d)/)
#   {
#      $day = $1;
#      $month = $2;
#   }
#   else
#   {
#      croak "Bad date string for Good Friday: $munged_date\n";
#   }

   ($year,$month,$day) = Add_Delta_Days(Easter_Sunday($year), -2);
#   ($year,$month,$day) = Date::Calc::Easter_Sunday($year);
#   $day -= 2;  # to get Good Friday from Easter Sunday; this should ultimately produce correct index even if $day<0.

   my $idx = $index_of_first_day_of_the_month{"$year,$month"};
   if ($idx)
   {
      $idx += $day - 1;
      if ($idx <= $#list_of_days)
      {
         return ($idx);
      }
   }

   # If we've gotten this far, there's no such day in our list.
   return 0;
}

sub find_hebrew_date($$$)
{
   # Return the index corresponding to the given year/month/day
   # on the Hebrew calendar.
   #  Returns undef if we can't find the date.
   my ($year,$month,$day) = @_;
   my $add;
   if (!defined($hebrew_years{$year}))
   {
      # This sometimes happens, e.g. when I step back from
      # Rosh Hashana into Elul.
      return undef;
   }
   if ($month eq "Adar")
   {
      croak "This code probably doesn't handle leap years properly.  Special casing is probably your best bet.\n";
   }

   my $index = $index_of_first_day_of_the_hebrew_month{"$year,$month"};
   if ($index)
   {
      $add = 1;
   }
   else
   {
      # It's possible that the first day of the month isn't in
      # our calendar, but the day that we're looking for is.
      # NOTE! This wasn't working until I fixed the hebrew_months array to include undef!
      # Otherwise there was an off-by-one error.  Fixed on 15 Elul, 5770.
      my $month_idx = $hebrew_month_index{$month};
      my $next_month = $hebrew_months[$month_idx+1];
      $index = $index_of_first_day_of_the_hebrew_month{"$year,$next_month"};
#      print "looking for Hebrew date " . $year. $month . $day."\n";
#      print "$month, $month_idx, $next_month, $index \n";
      if ($next_month eq "Adar" && !$index)
      {
         # Try calling it Adar I instead.
         $index = $index_of_first_day_of_the_hebrew_month{"$year,Adar I"}
      }
      if ($index)
      {
         $add = -1;
      }
      else
      {
         return undef;
      }
   }

   for (my $i = 0; $i < 31; $i++)
   {
      my $date = $list_of_days[$index];
      if ($index == 0 || $index > $#list_of_days)
      {
        last;
      }
      if ($date->{Hday} == $day &&
          $date->{Hmon} eq $month &&
          $date->{Hyear} == $year)
      {
         # Success!
         return $index;
      }

      $index += $add;
   }

   # If we haven't found it, we must have tried every day in the month.
   return undef;
}

sub index_of_date($$$)
{
    # return the index of a given Gregorian calendar date, given in year,month,day.
    # If beginning of the month doesn't exist or if the given date doesn't exist, return undef.
    #  (This is slightly more restrictive than the function find_hebrew_date above.)
    my ($year, $month, $day) = @_;
    my $idx = $index_of_first_day_of_the_month{"$year,$month"};

    if ($idx)
    {
        $idx += ($day - 1);
        if ($idx > $#list_of_days)
        {
            $idx = undef;
        }
    }
    return $idx;
}


sub print_date
{
   # Return a nicely formatted string with the date.
   my ($day) = @_;
   my $string = $day->{day_of_week};

   $string = $string . " " . $day->{Eday} . "/" . $day->{Emon} . "/" . $day->{Eyear};
   ### Not using $separator here because doesn't show up right in Command Prompt window
   return $string;
}

sub print_hebrew_date
{
   # Return a nicely formatted string with the Hebrew date.
   my ($day) = @_;
   my $string = $day->{day_of_week};

   $string = $string . " " . $day->{Hday} . "/" . get_output_month_name($day->{Hmon}) . "/" . $day->{Hyear};
   return $string;
}


sub absolute_to_idx($)
{
    # converts from absolute day number (counting from Jan. 1, 1 CE Gregorian) to index in our database
    # returns undef if the day (or the beginning of the month) does not exist in our database
    my ($days) = @_;
    (my $year, my $month, my $day) = Add_Delta_Days(1,1,1, $days - 1);
    return index_of_date($year, $month, $day);
}


sub idx_to_absolute($)
{
    # converts from index in our database to absolute day number (counting from Jan. 1, 1 CE Gregorian)
    my ($idx) = @_;
    my $day = $list_of_days[$idx];
    return Date_to_Days($day->{Eyear},$day->{Emon},$day->{Eday});
}

sub get_DST_start($)
{
    # returns an absolute day number
    my ($year) = @_;
    if ($year<2007)
    {
        return Date_to_Days(Nth_Weekday_of_Month_Year($year,4,7,1));
    }
    else
    {
        return Date_to_Days(Nth_Weekday_of_Month_Year($year,3,7,2));
    }
}

sub get_DST_end($)
{
    # returns an absolute day number
    my ($year) = @_;
    my $DST_end = Date_to_Days(Nth_Weekday_of_Month_Year($year,11,7,1));
    if ($year<2007)
    {
        $DST_end -= 7;
        #Add_Delta_Days ($DST_end, -7);
    }
    return $DST_end;
}


sub is_during_DST($)
{
    # determines whether the daytime of the given $day reference falls during DST
    my ($day) = @_;
    my $year = $day->{Eyear};
    my $absolute = idx_to_absolute($day->{idx});
    return (get_DST_start($year) <= $absolute  &&  $absolute < get_DST_end($year));
}


###################################
####                          #####
#### OUTPUT UTILITY FUNCTIONS #####
####                          #####
###################################


sub add_notes($$)
{
   # Add the given comment for the given day.
   my ($day,$comment) = @_;

   if (!defined($day->{comments}))
   {
      $day->{comments} = "";
   }

   ## AB modified
#   if ($output_format_compact)
#   {
      $day->{comments} = $day->{comments} . "$comment,";
#   }
#   else
#   {
#      $day->{comments} = $day->{comments} . "$comment\n";
#   }
}


sub remove_notes($$)
{
   # Remove comments containing the given text for the given day, if it is there.
   my ($day,$comment) = @_;

   if (defined($day->{comments}))
   {
      $day->{comments} =~ s/[^,]*$comment[^,]*,//g;
   }

}


sub add_prenotes($$)
{
   # Add the given comment for the given day
   # before any other info.
   my ($day,$comment) = @_;

   if (!defined($day->{prenotes}))
   {
      $day->{prenotes} = "";
   }

   ## AB modified

#   if ($output_format_compact)
#  {
      $day->{prenotes} = $day->{prenotes} . "$comment,";
#  }
#  else
#  {
#     $day->{prenotes} = $day->{prenotes} . "$comment\n";
#  }

}


###################################
####                          #####
#### EXCEL FUNCTIONS          #####
####                          #####
###################################

sub dump_excel_calendar()
{
   # Dump the calendar to an Excel spreadsheet.
   # Hopefully put it into a nice format.
   # TODO: I copied over the print order hacking from dump_calendar.
   # I should really create a separate routine common to both functions,
   # in case I want to do this sort of hackery in the future.   DONE by AMB - this is moved to prepare_print_order()
   #
   # Also, I should move the entire first chunk of this function into
   # its own routine.
   print "Opening Excel...\n";

   # this doesn't happen in 2006-2019.  When will it happen next?  Calendrical exercise.    May 2022 contains Nisan, Iyyar, Sivan.
   # warn "If any civil month contains portions of three Hebrew months, the header may not appear correctly; please fix.\n";    # FIXED!!!

#   my $i;
#   for ($i = 0; $i <= $#print_order; $i++)
#   {
#      if (defined ($print_order_hash{$print_order[$i]}))
#      {
#         croak "Error: " . $print_order[$i] . " is defined twice in print_order array\n";
#      }
#      $print_order_hash{$print_order[$i]} = $i;
#   }

   # Last row that we've written to in the Excel sheet.
   my $last_row = 0;
   # Row that we should start a new day at if we don't
   # want to start a new "week".
   my $current_start_row = -1;

   # Open Excel.
   $Excel = Win32::OLE->new('Excel.Application', sub {$_[0]->Quit;});

   croak "Cannot start Excel\n" if (!$Excel);

   my $book = $Excel->Workbooks->Add || croak "Error: Could not open Excel workbook.\n";
   my $sheet = $book->Worksheets(1);
#   $sheet->{Name} = "All Calendar Data";

   print "Dumping Calendar Data...\n";

   foreach my $day (@list_of_days)
   {
      my $idx = $day->{idx};
      if ($idx == 0)
      {
         next;
      }

#      $print_data_for_day[$idx] = [];

      if ($day->{idx} == 1 || $day->{day_of_week} eq "Sun")
      {
         # Start a new row.
         $current_start_row = $last_row + 2;
      }

      my $row = $current_start_row;

      # Just put Sunday in column 1, Monday in 2, etc.
      my $col = $day_of_week_index{$day->{day_of_week}};


      # Print basic date info.
      if ($full_debug)
      {
         $sheet->Cells($row,$col)->{Value} = $day->{day_of_week};
      }
      $row++;
      my $string_to_put =
         $day->{Eday} . "/" .
         $day->{Emon} . "/" .
         $day->{Eyear} ;
      if ($full_debug)
      {
         $sheet->Cells($row,$col)->{Value} = $string_to_put;
      }
      $row++;
      $string_to_put =
         $day->{Hday} . "/" .
         $day->{Hmon} . "/" .
         $day->{Hyear} ;
      if ($full_debug)
      {
         $sheet->Cells($row,$col)->{Value} = $string_to_put;
      }
      $row++;

      $last_row = ($row > $last_row) ? $row : $last_row;
   }

   # Okay, we've set up all of the data that needs to be printed,
   # and created a raw data sheet.  Now try to create nice data
   # for the months in question.
   #
   # TODO: HACK: I should make this data driven
   ##### NOTE this is now set with the flags at the top of the file
#   my $curr_year = 2012;

#   for ($curr_year = 2005; $curr_year <= 2028; $curr_year++)
   {
#        my $next_year = $curr_year + 1;
#        my @months_to_print = ("$curr_year,5");
# Uncomment whichever months are to be printed.
#        @months_to_print = (
#            "$curr_year,9",
#            "$curr_year,10",
#           "$curr_year,11",
#            "$curr_year,12",
#            "$next_year,1",
#            "$next_year,2",
#            "$next_year,3",
#            "$next_year,4",
#            "$next_year,5",
#            "$next_year,6",
#            "$next_year,7",
#            "$next_year,8",
#            "$next_year,9",
#            "$next_year,10"
#        );


        foreach my $string (@months_to_print)
        {
            print "Printing $string to Excel\n";
            print_month_to_excel ($book,$string,\@print_data_for_day);
        }
   }

    # don't need the SaveAs command because the destructor will automatically prompt to save the file.
    # the SaveAs was useless because it always tried to save the file in the same place with the same name, so it would
    # complain that the file already exists, and then the program would croak, invoking the Excel destructor.
    # Might as well skip that step and just go to the Excel destructor.
#   $book->SaveAs("sscm_calendar.xls") ||
#                        croak "Cannot save sscm_calendar.xls.  File already exists, or file may be open, or something else wrong\n";
#   print "Saved sscm_calendar.xls (probably in My Documents)";
   undef $book;
   undef $Excel;
}


sub print_month_to_excel ($$$)
{
   my ($book, $month_string, $data_for_day_ref) = @_;
   my $sheet = $book->Worksheets->Add({Before => $book->Worksheets("Sheet1")}) or
      croak "Could not create sheet\n";
   $sheet or croak "Sheet is not valid\n";
   my $sheet_name = $month_string;
   $sheet_name =~ s/,/_/;
   $sheet->{Name} = $sheet_name . "_1";

   my $start_idx;
   $start_idx = $index_of_first_day_of_the_month{$month_string};
   $start_idx or croak "Error: No start day for $month_string\n";

   if ($sept_start_third_week_2009 && $month_string eq "2009,9")
   {
        $start_idx += 12;  # To get to Sept. 13
   }

   if ($full_month_per_page || ($sept_start_third_week_2009 && $month_string eq "2009,9"))
   {
      my $end_idx = $start_idx;
      while ($list_of_days[$end_idx+1]->{Eday} != 1)
      {
         $end_idx++;
         print "$end_idx, $#list_of_days\n";
         (($end_idx+1) <= $#list_of_days) or croak "Bad $month_string\n";
      }

      print_half_month_to_excel ($sheet,$start_idx,$end_idx,$data_for_day_ref);
   }
   else
   {
      # Split it up into two pages.

      # The rule for breaking up a month into two sheets is that the
      # third shabbos of the month is always the last one printed.
      #  BUT THAT'S NOT ALWAYS BEST: Sometimes only two on the first sheet
      my $weeks_fit_on_first_page = 3;
      if ($month_string =~ /(2017,3|2018,4)/)  # SHOULD DO THIS MORE GENERALLY!
      {
      	$weeks_fit_on_first_page = 2;
      }
      my $num_shabboses = 0;

      if (!$start_idx)
      {
         croak "Month $month_string is not fully populated!\n";
      }
      my $end_idx = $start_idx;
      while ($num_shabboses < $weeks_fit_on_first_page)
      {
         $end_idx <= $#list_of_days || croak "Month $month_string is bad\n";
         my $day = $list_of_days[$end_idx];
         if ($day->{day_of_week} eq "Sat")
         {
            $num_shabboses++;
         }
         $end_idx++;
      }
      # We incremented end_idx once we got past the third Saturday.
      $end_idx--;
      $end_idx <= $#list_of_days || croak "Bad $month_string\n";

      print_half_month_to_excel ($sheet,$start_idx,$end_idx,$data_for_day_ref);

      # Now do the second half of the month.
      $sheet = $book->Worksheets->Add({Before => $book->Worksheets("Sheet1")}) or
         croak "Could not create sheet\n";;
      $sheet or croak "Sheet is not valid\n";
      $sheet->{Name} = $sheet_name . "_2";

      $start_idx = $end_idx+1;
      $end_idx = $start_idx;

      while ($list_of_days[$end_idx+1]->{Eday} != 1)
      {
         $end_idx++;
         $end_idx <= $#list_of_days or croak "Bad $month_string\n";
      }

      $end_idx <= $#list_of_days or croak "Bad $month_string\n";
      $sheet or croak "Sheet is not valid\n";
      print_half_month_to_excel ($sheet,$start_idx,$end_idx,$data_for_day_ref);
   }
}



# This is the function that does all of the hard work of trying to
# print and format a page of the calendar nicely.
#
# It is intended to handle either a half-month or a full month.
sub print_half_month_to_excel ($$$$)
{
   my ($sheet, $start_idx, $end_idx, $data_for_day_ref) = @_;
   my $start_day;

   $sheet or croak "Sheet is not valid\n";
   $end_idx <= $#list_of_days or croak "Bad $end_idx\n";
   $start_idx >= 1 or croak "Bad $start_idx\n";
   print "Computing dates $start_idx to $end_idx\n";
   if ($start_idx <= 30 || $end_idx >= $#list_of_days - 30)
   {
        warn "Very dangerous to start or end the calendar close to the beginning or end of the data set. \n" .
                "This has not been tested extensively and may lead to unpredictable results.\n" .
                "Please append more data before or after the dates required.\n";
   }

   # The layout is as follows:
   # First row is the Hebrew month(s) and the English month
   # Second row are the days of the week
   # Then individual date entries
   #
   # First row of date entry is English date on the left, Hebrew date on
   # right.

   # TODO: First, do the Hebrew month.
   # This appears to be done only in the first half of the month.
   # But for September we'll put it on both in case we only use the second half.  (Not necessarily.)
   my $col = 1;
   my $row = 1;
   $start_day = $list_of_days[$start_idx];
   if ($start_day->{Eday} == 1 || ($sept_start_third_week_2009 && $start_day->{Emon} =~ /9/ && $start_day->{Eyear} =~ /2009/))
   {
      # Then insert the month and year spanning columns
      # 2-6.
      #  AMB changing it to span columns 1-7, necessary for September 2013 (maybe).
      #$col = 2;

      # I need to check the last day of the month, not just
      # the last day of the days that I'm dumping.
      my $last_idx = $start_idx;
      while ($list_of_days[$last_idx+1]->{Emon} eq $start_day->{Emon})
      {
        $last_idx++;
      }
      my $last_day = $list_of_days[$last_idx];

      # Also check a day in the middle of the month, in case the month spans three Hebrew months:
      my $middle_idx = $start_idx + 15;     # arbitrary offset; if it turns out to be too big then it's not necessary at all
      if ($middle_idx > $last_idx)
      {
            $middle_idx = $last_idx;
      }
      my $middle_day = $list_of_days[$middle_idx];


      # To construct the string, easiest to start from the end and work backwards.
      my $string = $hebrew_month_unicode{$last_day->{Hmon}} . " " .
                            get_hebrew_year_string($last_day) . "      " .
                            $english_months[$start_day->{Emon}] . " " .
                            $start_day->{Eyear};

      if ($middle_day->{Hmon} ne $last_day->{Hmon})
      {
            my $middle_string = $hebrew_month_unicode{$middle_day->{Hmon}};
            if ($middle_day->{Hyear} ne $last_day->{Hyear})
            {
                $middle_string .= " " . get_hebrew_year_string($middle_day);
            }
            $string = $middle_string . " \\ " . $string;    # Is there a string prepending operator?
      }

      if ($middle_day->{Hmon} ne $start_day->{Hmon})
      {
            my $start_string = $hebrew_month_unicode{$start_day->{Hmon}};
            if ($middle_day->{Hyear} ne $start_day->{Hyear})
            {
                $start_string .= " " . get_hebrew_year_string($start_day);
            }
            $string = $start_string . " \\ " . $string;
      }

      ## This is no longer necessary since the title spans all 7 columns.  Just keep the 6 spaces between civil and Hebrew month names.
#      if (length($string) > 35)     # check this number!
#      {
#            # must shorten white space between civil and Hebrew months if the title is too long.
#            # 35 is arbitrary, but it seems to work.
#            $string =~ s/      /   /;
#      }


#      my $string = $hebrew_month_unicode{$start_day->{Hmon}};
#
#      if ($start_day->{Hyear} ne $last_day->{Hyear})
#      {
#         # If we're transitioning to a different year
#         $string = $string . " " . get_hebrew_year_string($start_day);
#         $string = $string . " \\ " . $hebrew_month_unicode{$last_day->{Hmon}};
#         $string = $string . " " . get_hebrew_year_string($last_day);
#         $string = $string . "   " . $english_months[$start_day->{Emon}] . " " .
#                                             $start_day->{Eyear};
#      }
#      else
#      {
#         # Check if month is transitioning
#         if ($start_day->{Hmon} ne $last_day->{Hmon})
#         {
#            $string = $string . "\\" . $hebrew_month_unicode{$last_day->{Hmon}};
#         }
#         $string = $string . " " . get_hebrew_year_string($start_day);
#         $string = $string . "      " . $english_months[$start_day->{Emon}] . " " .
#                                             $start_day->{Eyear};
#         #### FIX THIS IN CASE THERE ARE THREE HEBREW MONTHS IN A CIVIL MONTH
#         #  (Calendrical exercise to figure out when this will next happen)
#         #  It will next happen in May 2022, containing Nisan, Iyyar, and Sivan.
#         #  The program now shows the header as Nisan/Sivan, omitting Iyyar!
#         if ($string =~ /May.*2022/)
#         {
#            croak "Need to fix program to properly display the month title when the civil month contains " .
#                    "portions of three Hebrew months:  " . $string;
#         }
#      }


      insert_in_cell($sheet,$row,$col,$string);
      merge_range($sheet,$row,$col,$row+1,$col+6);  # AMB changed to span columns 1-7
		#  In 2014 changing so that month name takes only 2 rows instead of 3, with 24 font instead of 28
      $sheet->Cells($row,$col)->Font->{Size} = 24;
      $sheet->Cells($row,$col)->{HorizontalAlignment} = xlCenter;
      $sheet->Cells($row,$col)->{VerticalAlignment} = xlCenter;
   }

   # Next, days of the week.
   #
   my @days_of_week = ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","$shin$bet$tav");

   $col = 1;
   $row += 2;
   foreach my $day (@days_of_week)
   {
      insert_in_cell($sheet,$row,$col,$day);
      wrap_text($sheet,$row,$col,$row,$col);
      #merge_range($sheet,$row,$col,$row,$col+1);
      $col += 1;
   }

   # Put some (dotted) lines above and below the days of the week,
   # and solid lines between each day.
   add_lines_to_region ($sheet, $row, $row);

   # Now, we're ready to enter the data.
   my $day_idx;
   my $start_row_of_current_date = -1;
   my $end_row_of_current_date = $row;
   my $MIN_ROWS_PER_ENTRY = 1;  # AMB changed this 2009

#   # 3 extra rows for month, one extra row for days of the week.
#   my $MIN_FINAL_ROW;
#   if ($full_month_per_page)
#   {
#      # Assume 5 rows of data.  There might very rarely be six,
#      # but we probably need to muck around with that case by hand.
#      $MIN_FINAL_ROW = 5*$MIN_ROWS_PER_ENTRY + 4;
#   }
#   else
#   {
#      $MIN_FINAL_ROW = 3*$MIN_ROWS_PER_ENTRY + 4;
#   }


   for ($day_idx = $start_idx; $day_idx <= $end_idx; $day_idx++)
   {
      my $day = $list_of_days[$day_idx];
      # Start a new row on any Sunday, or on the first chunk of data.
      if ($day_idx == $start_idx ||
          $day->{day_of_week} eq "Sun")
      {
         if ($day_idx != $start_idx)
         {
            # Then we're about to start a new row.  Add
            # lines surrounding this region.
            if ($end_row_of_current_date - $start_row_of_current_date + 1 < $MIN_ROWS_PER_ENTRY)
            {
               $end_row_of_current_date = $start_row_of_current_date +
                                          $MIN_ROWS_PER_ENTRY - 1;
            }
            elsif ($end_row_of_current_date - $start_row_of_current_date + 1 >
                        $MIN_ROWS_PER_ENTRY)
            {
               warn "MONTH " . $english_months[$day->{Emon}] . " HAS TOO MANY ROWS\n";
               warn "$end_row_of_current_date, $start_row_of_current_date, $MIN_ROWS_PER_ENTRY\n\n";
            }

            add_lines_to_region ($sheet, $start_row_of_current_date, $end_row_of_current_date);
         }
         $start_row_of_current_date = $end_row_of_current_date + 1;
      }

      # What column are we in?
      $col = $day_of_week_index{$day->{day_of_week}};
      # Actually, each day of the week takes up two columns.  Not any more.

      # Enter the day of the month.
      $row = $start_row_of_current_date;
      my $hstring = convert_number_to_hebrew($day->{Hday}, undef);
#      my $cell_contents = $hstring . "            " . $day->{Eday};
      my $cell_contents = $day->{Eday} . "            " . $hstring;
#      insert_in_cell($sheet,$row,$col,$hstring . "            " . $day->{Eday});
      # Put the Hebrew day in the next column over.
      #insert_in_cell($sheet,$row,$col+1,$hstring);
#      $sheet->Cells($row,$col)->{HorizontalAlignment} = xlCenter;
#      $sheet->Cells($row,$col)->{VerticalAlignment} = xlTop;


      # Start entering the values.
      my $item;
      foreach $item (@{$print_data_for_day[$day_idx]})
      {
         my ($newitem, $bold, $italic, $partial_bold, $size) = identify_special_codes($item);
         if($bold)
         {
            $newitem = $START_BOLD . $newitem. $END_BOLD;
         }
         $cell_contents .= chr(10).$newitem;

#         # 21 is a bit longer than Maariv with 2 times, but shorter
#         # than Shacharis with 2 times.  It also allows 4 times
#         # (which happens occasionally for Shacharis) to fit on
#         # one line.
#         my @list_of_items;
#         if (!$bold)
#         {
#           if ($size >= 12)
#           {
#              @list_of_items = split_string_maxchars($newitem,15);
#           }
#           else
#           {
#              @list_of_items = split_string_maxchars($newitem, 21);
#           }
#         }
#         else
#         # Should we also do this for partial bold?
#         # Would be quite conservative.
#         {
#           # Bolded words are wider.  Try 18.  Ari, feel free
#           # to modify this value if you think there's a better one.
#           if ($size >= 12)
#           {
#              @list_of_items = split_string_maxchars($newitem, 13);
#           }
#           else
#           {
#              @list_of_items = split_string_maxchars($newitem, 19); #check if this is ok????? need 19 for Megillas Esther
#                            # but it messes up "Shiva Asar B'Tammuz" - must fix manually
#                            # long term solution - replace this whole hack by turning each calendar date into a single cell,
#                            # using ALT-ENTER (Chr(10)) for newlines within a cell.
#           }
#         }
#
#         my $subitem;
#         foreach $subitem (@list_of_items)
         {
#            $row++;

#            insert_in_cell($sheet,$row,$col,$subitem);
#            format_cell($sheet,$row,$col,$bold,$italic,$size);     # We're losing any italics (was there any?) and large fonts
            #merge_range($sheet,$row,$col,$row,$col+1);
            # Check if this is a line that we haven't written to yet.
            $end_row_of_current_date =
               ($row > $end_row_of_current_date) ? $row :
                  $end_row_of_current_date;
         }
      }
      # insert_in_cell($sheet,$row,$col,$cell_contents);    # I think this is covered by handle_partial_bold even when there is no bold
      $sheet->Cells($row,$col)->{HorizontalAlignment} = xlLeft;
      $sheet->Cells($row,$col)->{VerticalAlignment} = xlTop;
      wrap_text($sheet,$row,$col,$row,$col);
      handle_partial_bold($sheet,$row,$col,$cell_contents);     # this should do the insert_in_cell even when there is no bold
   }

   # Increase row count to standard size.
   if ($end_row_of_current_date - $start_row_of_current_date + 1 < $MIN_ROWS_PER_ENTRY)
   {
      $end_row_of_current_date = $start_row_of_current_date +
                                 $MIN_ROWS_PER_ENTRY - 1;
   }
   elsif ($end_row_of_current_date - $start_row_of_current_date + 1 >
               $MIN_ROWS_PER_ENTRY)
   {
      warn "MONTH " . $english_months[$start_day->{Emon}] . " HAS TOO MANY ROWS\n";
      warn "$end_row_of_current_date, $start_row_of_current_date, $MIN_ROWS_PER_ENTRY\n\n";
   }

   # Fill in lines for the last row.
   add_lines_to_region ($sheet, $start_row_of_current_date, $end_row_of_current_date);

#   # For half-months with less than 3 weeks, extend
#   # range to 3 weeks.
#   if ($end_row_of_current_date < $MIN_FINAL_ROW)
#   {
#      $end_row_of_current_date = $MIN_FINAL_ROW;
#      insert_in_cell($sheet, $MIN_FINAL_ROW, 1, " "); # to ensure the print area covers the minimum number of weeks
#   }

   # This is a hack, which seems to work as long as we're doing the month on two pages,
   # but even then it's not guaranteed to put the note in the right place.
   # Fix this later.
   #### MAY NEED TO MANUALLY RESIZE BOTTOM ROW!!!!!
    my $footnote_text = "";
    if ($start_day->{Eday} > 1 && $YMM_is_uncertain && ($start_day->{Emon} != 9 || $start_day->{Eyear} != 2019))
    {
      $footnote_text = $footnote_text . $YMM_note . chr(10) . chr(10);
      warn "May need to manually resize bottom row because of YMM note!";
    }

    if ($sheet->{Name} =~ /_[3456789]_2/)
    {
        $footnote_text = $footnote_text . "** Kindly Note:  " . chr(10) . $kindly_note;
    }
    if ($footnote_text ne "")
    {
      if ($col>3)
      {
            $row++;
            $end_row_of_current_date++;
            merge_range($sheet, $row, 4, $row+4, 7);
      }
      else
      {
            merge_range($sheet, $row, 4, $row, 7);
      }
#      merge_range($sheet, 45, 4, 45, 7);
#      merge_range($sheet, 46, 4, 46, 7);
#      merge_range($sheet, 47, 4, 47, 7);
      $sheet->Cells($row,4)->{Font}->{Bold} = 1;
#      $sheet->Cells($row,4)->{Value} = "** Kindly Note:  ";
#      $row++;
#      merge_range($sheet, $row, 4, $row, 7);

        insert_in_cell($sheet,$row,4, $footnote_text);
        wrap_text($sheet,$row,4,$row,4);
#      $sheet->Cells(44,4)->{Value} = "The time for Candle Lighting listed in the calendar is to be regarded";
#      $sheet->Cells(45,4)->{Value} = "where the household commences the observance of Shabbos at the regular hour.";
#      $sheet->Cells(46,4)->{Value} = "In the household where the observance of Shabbos commences earlier,";
#      $sheet->Cells(47,4)->{Value} = "the candles should not be lit before Plag HaMincha.";


    }

   set_up_for_printing($sheet, $row, 7);
#   set_up_for_printing($sheet, $end_row_of_current_date, 7);
}

sub identify_special_codes($)
{
   # Remove any codes from the item, and return
   # then modified item, as well as which codes were removed.
   # size returns the font size, zero if default.
   my ($item) = @_;
   my $bold = 0; my $italic = 0; my $partial_bold = 0; my $size = 0;

   if ($item =~ s/$BOLD//g)
   {
      $bold = 1;
   }

   if ($item =~ s/$ITALIC//g)
   {
      $italic = 1;
   }

   if ($item =~ s/$FONT14//g)
   {
      $size = 14
   }

   # Need to leave these flags in, because I need to remember
   # the location in the string where they occur.
   if ($item =~ /$START_BOLD/ || $item =~ /$END_BOLD/)
   {
      $partial_bold = 1;
   }

   return ($item, $bold, $italic, $partial_bold, $size);
}

sub handle_partial_bold ($$$$)
{
   my ($sheet,$row,$col,$subitem) = @_;

   my @boldies;

   # Do everything necessary for partially bolded entries.
   # It's messy stuff.
   while (($subitem =~ /$START_BOLD/) ||
          ($subitem =~ /$END_BOLD/))
   {

      # I only allow one start/end bold pair in an entry.
      # I'll probably regret it later.
      my $first, my $second, my $third;

      if ($subitem =~ s/^(.*)($START_BOLD)(.*)($END_BOLD)(.*)$/$1$3$5/s)
      {
         # Perl's string matcher should maximize the length
         # of the first .*, which means that it may include
         # other bold commands.  So we need to store based on
         # the final item length.
         ($first,$second,$third) = ($1,$3,$5);
         push @boldies, [length($second), length($third)];
      }
      elsif ($subitem =~ s/^(.*)($START_BOLD)(.*)$/$1$3/)
      {
         ($first,$second) = ($1,$3);
         push @boldies, [length($second), 0];
      }
      elsif ($subitem =~ s/^(.*)($END_BOLD)(.*)$/$1$3/)
      {
         ($second,$third) = ($1,$3);
         push @boldies, [length($second), length($third)];
      }
   }

   insert_in_cell($sheet,$row,$col,$subitem);   # this should handle the insertion even when there is no bold

   my $range = $sheet->Cells($row,$col);
   my $boldy;

   # Now go ahead and apply the bolding.
   foreach $boldy (@boldies)
   {
      my $start = length($subitem) - $boldy->[1] - $boldy->[0] + 1;
      my $length = $boldy->[0];

      if ($length > 0)
      {
         my $chars = $range->Characters({Start => $start, Length => $length})->{Font};
         # For some bizarro reason, on partial strings, you set FontStyle
         # to "Bold", rather than setting Bold to non-zero.
         $chars->{FontStyle} = "Bold";
      }
      else
      {
         warn "Hmm, asking for partial bold, but no string?\n$subitem\n\n";
      }
   }
}


sub set_up_for_printing ($$$)
{
   my ($sheet, $last_row, $last_col) = @_;

   # Adjust column widths.  I just use fixed widths for each column.  (Not any more.)

   ## 7 columns of width 19 will fit into the margins we specify, without having to shrink the page.
   ## Actually, with the margins we're setting, it seems that the page can handle total width columns (7*19)+5/7 or +4/7
   ## But we want Saturday to be wider (21) to allow each of Latest Sh'ma, Motzoai Shabbos, and Avos UBanim to fit on a single line.
   ## Now that there are three Shacharis times, need to make sure they're all on one line.
   ## Apparently any line with 24 characters or more causes the cell to get taller by a line, so let's now increase the width to prevent this.
   ## At width 22, the 24-character lines are okay, but any line of 25 characters (such as the Shacharis with 3 times) still messes up the height.
   ## 22.1 seems to work for 25 characters on a line.

   ## Now that we've added the $nbsp to the separator, the Shacharis line on Shabbos (with 3 times) has 29 characters.
   ## That line requires width 22.57 to fit on one line, but 24.43 to avoid adding extra height.

   ## Column widths in Excel seem to get rounded to the nearest seventh of a unit.
   ## So 22.4 is actually 22+3/7, etc.

   ## Let's try setting Shabbos to 24+3/7, and weekdays to 18+2/7.
   ## That is slightly too big, so we reduce TWO of the weekdays to 18+1/7, and this seems to work.

   ## Which two do we reduce?
   ## Arbitrarily choosing two for now.
   ## Ideally there should be an algorithm to choose which columns are best to shrink in any given month.

   #my $saturday_width = 22.1;   # this saves as 22+1/7, which is big enough for 25 characters, but 22.0 is not
   #my $normal_width = 18.5;     # really 18+4/7
   #my $narrow_width = 18.4;     # really 18+3/7

   my $saturday_width = 24.43;   # really 24+3/7, which is big enough for 29 characters
   my $normal_width = 18.3;     # really 18+2/7
   my $narrow_width = 18.1;     # really 18+1/7

	#######################################################
	#	In 2014 switching to Excel 2007.
	#	Excel 2007 changed the default font size from 10 to 11, which really confused me.
	#	Changing the font size back to 10 seems to return us to the previous requirements.
	#	Therefore the following description is wrong.
	######	...  which seems to change the precise requiements.
	######	17.7 seems to work for all weekday columns.
	######	(Come back to check whether we can increase some of them)
	######	For Shabbos, need 24.6 (really 24 + 4/7) for the 29 characters not to force an extra line
	######	For Friday, need 19.1 (really 19 + 1/7) for the 21 characters of Candle lighting... not to force an extra line
	######	(though candle lighting with a * will still force an extra line until width is 20.1)
	######	This leaves 17.4 (really 17 + 3/7) for each of the first 5 days of the week.

	######	$saturday_width = 24.6;	# really 24+4/7, enough for 29 characters without forcing an extra line
	######	my $friday_width = 19.1;	# really 19+1/7, enough for 21 characters without forcing an extra line

		$normal_width = 17.7;
		$narrow_width = 17.6;
		my $friday_width = 18.1;

    if ($YMM_is_uncertain)
    {
      $saturday_width = 25.4; # actually gives 25.29 for some strange reason?
      $normal_width = 17.6;
      $narrow_width = 17.5;
    }

   # This is absurd, but I can't figure out an easy way to turn
   # column numbers into the letters that Excel wants.
   $sheet->Columns("A:A")->{ColumnWidth} = $narrow_width;
   $sheet->Columns("B:B")->{ColumnWidth} = $normal_width;
   $sheet->Columns("C:C")->{ColumnWidth} = $narrow_width;
   $sheet->Columns("D:D")->{ColumnWidth} = $normal_width;
   $sheet->Columns("E:E")->{ColumnWidth} = $narrow_width;
	#   $sheet->Columns("F:F")->{ColumnWidth} = $normal_width;

	$sheet->Columns("F:F")->{ColumnWidth} = $friday_width;

   $sheet->Columns("G:G")->{ColumnWidth} = $saturday_width;

   ## There is a particular problem for the days during bein hazmanim when there are 4 times for Shacharis,
   ## as this contains 25 characters with no breaking space, needing a width of 18+3/7.
   ## Do these manually for now.

   my $four_times_width = 18.43;    # 18+3/7

   # Exceptions for crowded months
   # Note that we cannot allow more than 42 lines of text in the three calendar weeks making up a page
   # (excluding the month header and day-of-week column headings)
   # otherwise the text will shrink when the page is printed.
   # Note also that sometimes Excel inserts a blank line at the end of the cell
   # when there is a line of text whose width almost reaches the cell width.
   if ($sheet->{Name} =~ /2010_12_1/)
   {
        $sheet->Columns("F:F")->{ColumnWidth} ++;
        $sheet->Columns("A:A")->{ColumnWidth} --;
   }
   elsif ($sheet->{Name} =~ /2011_3_1/)
   {
        $sheet->Columns("G:G")->{ColumnWidth} ++;
        $sheet->Columns("C:C")->{ColumnWidth} --;
   }
   elsif ($sheet->{Name} =~ /2012_3_1/)
   # March is usually a crowded month!
   # Zachor, Taanis Esther, Purim, and a clock change (and now even Avos UBanim) all take too much space!
   {
        $sheet->Columns("B:C")->{ColumnWidth} = 15.29;
        $sheet->Columns("D:D")->{ColumnWidth} = 22.14;
        $sheet->Columns("G:G")->{ColumnWidth} = 25;
   }
   elsif ($sheet->{Name} =~ /2012_4_1/)
   # Pesach can also get crowded!
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 17;
        $sheet->Columns("B:D")->{ColumnWidth} = 15.86;
        $sheet->Columns("E:E")->{ColumnWidth} = 18.29;
        $sheet->Columns("F:F")->{ColumnWidth} = 22.86;
        $sheet->Columns("G:G")->{ColumnWidth} = 27.71;
        $sheet->Rows("5:5")->{RowHeight} = 183;
        $sheet->Rows("6:6")->{RowHeight} = 180;
   }
   elsif ($sheet->{Name} =~ /2013_4_1/)
   # 8th day of Pesach is too crowded!
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 16.57;
        $sheet->Columns("C:C")->{ColumnWidth} = 21;
   }
   elsif ($sheet->{Name} =~ /2013_5_1/)
   # second day of Shavuos is a little too crowded
   {
        $sheet->Columns("E:E")->{ColumnWidth} = 19; # don't have to narrow any column to compensate?
   }
   elsif ($sheet->{Name} =~ /2013_9_1/)
   {
        $sheet->Columns("B:B")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("C:C")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("D:D")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("E:E")->{ColumnWidth} = 19.43;
        $sheet->Columns("G:G")->{ColumnWidth} = 21.43;
        $sheet->Rows("7:7")->{RowHeight} = 168;
   }
   elsif ($sheet->{Name} =~ /2014_3_1/)
   {
        $sheet->Columns("B:B")->{ColumnWidth} = 17;
        $sheet->Columns("C:C")->{ColumnWidth} = 17;
        $sheet->Columns("D:D")->{ColumnWidth} = 17;
        $sheet->Columns("G:G")->{ColumnWidth} = 26.57;
        $sheet->Rows("7:7")->{RowHeight} = 232.5;
   }
   elsif ($sheet->{Name} =~ /2014_4_1/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = $narrow_width;
        $sheet->Columns("D:D")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("E:E")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("F:F")->{ColumnWidth} = $four_times_width;
        $sheet->Columns("G:G")->{ColumnWidth} = 23.86;
   }
   elsif ($sheet->{Name} =~ /2014_6_1/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 17.3;
        $sheet->Columns("B:B")->{ColumnWidth} = 17.4;
        $sheet->Columns("C:C")->{ColumnWidth} = 18;
        $sheet->Columns("D:D")->{ColumnWidth} = 18;
        $sheet->Columns("E:E")->{ColumnWidth} = 20.3;
   }
   elsif ($sheet->{Name} =~ /2014_10_1/)
   {
#        $sheet->Columns("A:A")->{ColumnWidth} = 17.86;
#        $sheet->Columns("B:B")->{ColumnWidth} = $four_times_width;
#        $sheet->Columns("C:C")->{ColumnWidth} = $four_times_width;
#        $sheet->Columns("D:D")->{ColumnWidth} = $four_times_width;
#        $sheet->Columns("G:G")->{ColumnWidth} = 24;
   }
   elsif ($sheet->{Name} =~ /2014_12_1/)
   {
#        $sheet->Columns("A:A")->{ColumnWidth} = 17.6;
#        $sheet->Columns("C:C")->{ColumnWidth} = 17.6;
#        $sheet->Columns("E:E")->{ColumnWidth} = 17.6;
#        $sheet->Columns("F:F")->{ColumnWidth} = 18.1;
   }
   elsif ($sheet->{Name} =~ /2015_3_1/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 16;
        $sheet->Columns("B:B")->{ColumnWidth} = 16;
        $sheet->Columns("C:C")->{ColumnWidth} = 16;
        $sheet->Columns("D:D")->{ColumnWidth} = 24.4;
        $sheet->Columns("E:E")->{ColumnWidth} = 16.3;
        $sheet->Columns("F:F")->{ColumnWidth} = 17.4;
        $sheet->Columns("G:G")->{ColumnWidth} = 24.4;
   }
   elsif ($sheet->{Name} =~ /2015_4_1/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 15;
        $sheet->Columns("B:B")->{ColumnWidth} = 15;
        $sheet->Columns("C:C")->{ColumnWidth} = 15;
        $sheet->Columns("D:D")->{ColumnWidth} =15;
        $sheet->Columns("E:E")->{ColumnWidth} = 15;
        $sheet->Columns("F:F")->{ColumnWidth} = 29;
        $sheet->Columns("G:G")->{ColumnWidth} = 27.7;
   }
#   elsif ($sheet->{Name} =~ /2015_12_1/)
#   {
#        $sheet->Columns("A:A")->{ColumnWidth} = 17.3;
#        $sheet->Columns("B:B")->{ColumnWidth} = 17.3;
#        $sheet->Columns("C:C")->{ColumnWidth} = 17.3;
#        $sheet->Columns("D:D")->{ColumnWidth} =17.3;
#        $sheet->Columns("E:E")->{ColumnWidth} = 17.3;
#        $sheet->Columns("G:G")->{ColumnWidth} = 26.1;
#   }
   elsif ($sheet->{Name} =~ /2016_6_1/)
   {
        $sheet->Columns("B:B")->{ColumnWidth} = 19.7;
        $sheet->Columns("D:D")->{ColumnWidth} =16.7;
        $sheet->Columns("E:E")->{ColumnWidth} = 16.6;
   }
   elsif ($sheet->{Name} =~ /2017_3_2/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 21;
        $sheet->Columns("B:B")->{ColumnWidth} = 15.29;
        $sheet->Columns("C:C")->{ColumnWidth} = 15.29;
        $sheet->Columns("D:D")->{ColumnWidth} = 15.29;
        $sheet->Columns("E:E")->{ColumnWidth} = 15.29;
        $sheet->Columns("F:F")->{ColumnWidth} = 18.86;
        $sheet->Columns("G:G")->{ColumnWidth} = 29.43;
   }
   elsif ($sheet->{Name} =~ /2017_6_1/)
   {
        $sheet->Columns("B:B")->{ColumnWidth} = 16;
        $sheet->Columns("C:C")->{ColumnWidth} = 16;
        $sheet->Columns("D:D")->{ColumnWidth} = 16;
        $sheet->Columns("E:E")->{ColumnWidth} = 20;
   }
   elsif ($sheet->{Name} =~ /2018_3_1/)
   {
        $sheet->Columns("A:A")->{ColumnWidth} = 16.43;
        $sheet->Columns("B:B")->{ColumnWidth} = 16.43;
        $sheet->Columns("C:C")->{ColumnWidth} = 16.43;
        $sheet->Columns("D:D")->{ColumnWidth} = 16.43;
        $sheet->Columns("E:E")->{ColumnWidth} = 22.57;
   }



#   $sheet->Columns("H:H")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("I:I")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("J:J")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("K:K")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("L:L")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("M:M")->{ColumnWidth} = $normal_width;
#   $sheet->Columns("N:N")->{ColumnWidth} = $normal_width;


   my $range = $sheet->Range($sheet->Cells(1,1),
                             $sheet->Cells($last_row,$last_col));

   # This PrintArea was generating a warning and doesn't work,
   # but we aren't relying on it now anyway.
   #$sheet->{PageSetup}->{PrintArea} = $range;

   my $vtfalse =  Variant(VT_BOOL, 0);
   my $vttrue =  Variant(VT_BOOL, 1);
   my $vtpages =  Variant(VT_I4, 1);
   my $orientation = $full_month_per_page ? xlPortrait : xlLandscape;
   with ($sheet->{PageSetup},
            Orientation => $orientation,
            Zoom => $vtfalse,
#            LeftMargin => $Excel->InchesToPoints(0.748031496),
#            RightMargin => $Excel->InchesToPoints(0.748031496),
#            TopMargin => $Excel->InchesToPoints(0.9842519),
#            BottomMargin => $Excel->InchesToPoints(0.9842519),
#            HeaderMargin => $Excel->InchesToPoints(0.511811023622),
#            FooterMargin => $Excel->InchesToPoints(0.511811023622),
#
#           The previous margins were too generous, especially for full
#           month per page, where we need as much space as we can get.
#           However, one of the margins should probably be indented a bit
#           in order to leave room for binding.  This will depend on
#           whether we are in half or full month per page mode.
#           0.17 seems to be the closest to the edge that Excel accepts
            LeftMargin => $Excel->InchesToPoints(0.17),
            RightMargin => $Excel->InchesToPoints(0.17),
            TopMargin => $Excel->InchesToPoints(0.17),
            BottomMargin => $Excel->InchesToPoints(0.17),
            HeaderMargin => $Excel->InchesToPoints(0.17),
            FooterMargin => $Excel->InchesToPoints(0.17),
            CenterHorizontally => $vttrue,
            CenterVertically => $vtfalse, # AMB changed this so that second halves of months wouldn't look odd
            FitToPagesWide => $vtpages,
            FitToPagesTall => $vtpages);
#   $sheet->PageSetup->{Orientation} = xlLandscape;
#   $sheet->PageSetup->{Zoom} = 0;
#   $sheet->PageSetup->{FitToPagesWide} = 1;
#   $sheet->PageSetup->{FitToPagesTall} = 1;
}

sub split_string_maxchars ($$)      # this function is no longer used
{
   # Split a string at its whitespace if it is
   # longer than maxchars.  Use some heuristics to
   # get a reasonable split location.
   my ($string, $maxchars) = @_;
   my $curr_string = $string;

   my @array;

   while (unformatted_length($curr_string) > $maxchars)
   {
      my $split_loc = $maxchars - 1;
      while (substr($curr_string,$split_loc,1) !~ /[\s-]/)
      {
         $split_loc--;
         if ($split_loc <= 0)
         {
            croak "Couldn't split $string.  Need smarter algorithm\n";
         }
      }
      push @array, substr($curr_string,0,$split_loc);
      # Providing no third argument causes split loc to go to
      # the end of the string.
      $curr_string = substr($curr_string, $split_loc+1);
   }

   # Push whatever is left.
   push @array, $curr_string;

   return @array;
}

sub unformatted_length($)   # no longer used
{
   # This is the length of the current string with any special
   # formatting removed.
   # Currently need to ignore START_BOLD and END_BOLD markers.
   my ($string) = @_;
   $string =~ s/$START_BOLD//g;
   $string =~ s/$END_BOLD//g;

   return (length($string));
}

# I'm making this a separate function in case I want to do any
# error checking, or in case the Excel interface ever changes.
#####	GOOD IDEA!!!  Because in Excel 2007, the default font size changed from 10 to 11,
#####	and this is really messing me up.  So change the font size back to 10 any time we insert text.  -AMB
#####	Also the defalut font changed in Excel 2007 from Arial to Calibri,
#####	and for some reason Calibri messes up the printing.
sub insert_in_cell ($$$$)
{
   my ($sheet,$row,$col,$val) = @_;
   $sheet->Cells($row,$col)->Font->{Size} = 10;
   $sheet->Cells($row,$col)->Font->{Name} = "Arial";
   $sheet->Cells($row,$col)->{Value} = $val;
}

# Add bold and/or italics
sub format_cell ($$$$$)     # no longer used?
{
   my ($sheet,$row,$col,$bold,$italic,$size) = @_;
   if ($bold)
   {
      $sheet->Cells($row,$col)->{Font}->{Bold} = $bold;
   }

   if ($italic)
   {
      $sheet->Cells($row,$col)->{Font}->{Italic} = $italic;
   }

   if ($size)
   {
      $sheet->Cells($row,$col)->{Font}->{Size} = $size;
   }
}

sub merge_range ($$$$$)
{
   my ($sheet,$arow,$acol,$brow,$bcol) = @_;
   my $range = $sheet->Range($sheet->Cells($arow,$acol),
                             $sheet->Cells($brow,$bcol));
   $range->Merge;
}

sub wrap_text ($$$$$)
{
   my ($sheet,$arow,$acol,$brow,$bcol) = @_;
   my $range = $sheet->Range($sheet->Cells($arow,$acol),
                             $sheet->Cells($brow,$bcol));
   $range->{WrapText} = 1;
}

sub add_lines_to_region ($$$)
{
   # Adds dotted lines at the top and bottom of the region,
   # and solid vertical lines between each day of the week.
   ### AMB changed them all to solid lines in 2009.
   my ($sheet,$top,$bot) = @_;

   my $range;
   my $col;
   # I need to do each row separately, because
   # of the cell merging messiness.
   for ($col = 1; $col <= 7; $col += 1)
   {
      $range = $sheet->Range($sheet->Cells($top,$col),
                              $sheet->Cells($bot,$col));
      ### For some reason the Color property produces a warning.
      # Presumably the default colour is black anyway.
      #$range->Borders(xlEdgeLeft)->{Color} = "RGB(0,0,0)";
      $range->Borders(xlEdgeLeft)->{Weight} = xlThin;
      if ($col == 7)
      {
         $range = $sheet->Range($sheet->Cells($top,$col),
                              $sheet->Cells($bot,$col));
         #$range->Borders(xlEdgeRight)->{Color} = "RGB(0,0,0)";
         $range->Borders(xlEdgeRight)->{Weight} = xlThin;
      }
      #print "Doing dots at $top to $bot, $col\n";
   }

   # Now top and bottom.
   $range = $sheet->Range($sheet->Cells($top,1),
                             $sheet->Cells($top,7));
      #$range->Borders(xlEdgeTop)->{Color} = "RGB(0,0,0)";
      $range->Borders(xlEdgeTop)->{Weight} = xlThin;
#      $range->Borders(xlEdgeTop)->{LineStyle} = xlDot;
   $range = $sheet->Range($sheet->Cells($bot,1),
                             $sheet->Cells($bot,7));
      #$range->Borders(xlEdgeBottom)->{Color} = "RGB(0,0,0)";
      $range->Borders(xlEdgeBottom)->{Weight} = xlThin;
#      $range->Borders(xlEdgeBottom)->{LineStyle} = xlDot;
}


sub get_hebrew_year_string ($)
{
   my ($day) = @_;
   my $hyear = $day->{Hyear};

   ($hyear < 5800 && $hyear > 5700) or croak ("Need to update years\n");
   $hyear -= 5700;
   my $string;

   $string = "$tav$shin";

   $string = convert_number_to_hebrew($hyear, $string);
   return $string;
}

sub convert_number_to_hebrew($$)
{
   # Convert a number between 1 and 100 into it's
   # normal Hebrew form.  Second argument to function
   # is gematria of hundreds, if applicable.
   # now using $gershayim rather than "\"" and $geresh rather than "\'"
   my ($val, $hundreds) = @_;

   $val > 0 && $val < 100 or croak "I don't handle this value\n";

   my $string;
   if ($val < 10 || $val % 10 == 0)
   {
      # Single letter
      if (defined($hundreds))
      {
        $string = $gematria_end_vals{$val}; # or croak "Bug\n";
         $string = $hundreds . $gershayim . $string;
         if ($val =~ /20|40|50|80|90/)
         {
            warn "For Hebrew year ending in $val, decide whether to use final or non-final letter in Excel or csv output!\n";
         }
      }
      else
      {
        $string = $gematria_vals{$val} or croak "Bug\n";
         ## AMB In this case let's go left-to-right; maybe less buggy
         #### NO!!  We're now replacing "\'" with $geresh, which is a RTL character, so everything should be entered in logical order
         $string = $string . $geresh;
      }
   }
   else
   {
      # Two letters.
      $string = defined($hundreds) ? $hundreds : "";

      if ($val == 15 || $val == 16)
      {
         # Special cases.
         $string = $string . $tet . $gershayim;
         $val -= 9;
         $string = $string . $gematria_vals{$val};
      }
      else
      {
         my $ones_digit = $val % 10;
         my $ones = $gematria_vals{$ones_digit};
         my $tens_digit = ($val - $ones_digit);
         my $tens = $gematria_vals{$tens_digit};
         $string = $string . $tens . $gershayim . $ones;
      }
   }

   return $string;
}

sub compute_sunrise_sunset()
{
   # Compute sunrise and sunset times from scratch.
   # Algorithm from williams.best.vwh.net/sunrise_sunset_algorithm.htm
   # He also works through an example in sunrise_sunset_example.htm


   my $debug = 0;

   # This is the cosine of 90 degrees, 50 minutes.
   # This is "official" zenith.  Other options are
   # 96, 102, and 108 degrees on the website, which
   # are civil, nautical, and astronomical, respectively.
   my $cos_zenith = cos((90+(50/60))*pi/180); #-0.01454;
   for my $day (@list_of_days)
   {
      next if (!defined($day->{Emon}));
      foreach my $type ("Sunrise","Sunset")
      {
      my $time = compute_suntime($day,$cos_zenith,$type);
         if ($type eq "Sunrise")
         {
            $day->{sunrise} = $time;
         }
         else
         {
            $day->{sunset} = $time;
         }
      }
   }
}

sub compute_suntime($$$)
{

    my $debug = 0;
    # Latitude and longitude are from Google Maps, to the level of precision that locates the SSCM building
    # (any more significant digits would require specifying a particular spot within the building)
    my $latitude = 43.712;      # building ranges from 43.712169 to 43.712475
    my $longitude = -79.436;    # building ranges from 79.435471 to 79.435894

   # Latitude and longitude for Toronto.  From Ari.
   # These were the nearest whole-minute coordinates to SSCM, actually on Dell Park between Glen Mount and Dalemount
   # (because the USNO website took only whole-minute coordinates)
#   my $latitude = 43 + (43/60.0);
#   my $longitude = -79 - (26/60.0);
# These are for the example on the website.
#   my $latitude = 40.9;
#   my $longitude = -74.3;
   # I believe that we're 5 hours behind GMT.  Need to adjust for DST
   # somewhere, though.
   my $localOffset = -5;

   my ($day,$cos_zenith,$type) = @_;
   croak if ($type ne "Sunrise" && $type ne "Sunset");

   # Inputs: day, month, year.
   my $day_of_month = $day->{Eday};
   my $month = $day->{Emon};
   my $year = $day->{Eyear};

    # These are for the example on the website.
    #      my $day_of_month = 25;
    #      my $month = 6;
    #      my $year = 1990;

   my $old_sunset = get_sunset($day);
   my $old_sunrise = get_sunrise($day);

   # Step 1.  Calculate day of the year.
   my $N1 = int(275*$month/9);
   my $N2 = int(($month+9)/12);
   my $N3 = (1 + int(($year - 4 * int($year/4) + 2) / 3));
   my $N = $N1 - ($N2*$N3) + $day_of_month - 30;

   print "1) N is $N\n" if $debug;

   # Step 2.  Convert the longitude to hour value,
   # and calculate an approximate time

   my $lngHour = $longitude / 15.0;

   my $t;
   if ($type eq "Sunrise")
   {
     $t = $N + ((6 - $lngHour)/24);
   }
   else
   {
      croak if ($type ne "Sunset");
      $t = $N + ((18 - $lngHour)/24);
   }

   print "2) t is $t\n" if $debug;

   # Step 3.  Calculate the Sun's mean anomaly.
   my $M = (0.9856 * $t) - 3.289;
   print "3) M is $M\n" if $debug;

   # Step 4.  Calculate the Sun's true longitude.
   my $L = $M + (1.916 * sin($M*pi/180)) + (0.020 * sin(2*$M*pi/180)) + 282.634;

    print "4) L is $L\n" if $debug;
   # Renormalize to 0 <= L < 360.
   $L = renorm_angle($L);
   print "4) L is $L\n" if $debug;

   # Step 5a. Calculate the Sun's right ascension.
   my $RA = 180/pi * atan(0.91764*tan($L*pi/180));
   print "5) RA is $RA\n" if $debug;
   $RA = renorm_angle($RA);
   print "5) RA is $RA\n" if $debug;

   # Step 5b. Right ascension value needs to be in the same quadrant as L.
   my $Lquadrant = 90 * int($L/90);
   my $RAquadrant = 90 * int($RA/90);
   $RA = $RA + ($Lquadrant - $RAquadrant);
   print "5) RA is $RA\n" if $debug;

   # Step 5c. Right ascension value needs to be converted into hours.
   $RA /= 15;
   print "5) RA is $RA\n" if $debug;

   # Step 6.  Calculate the Sun's declination.
   my $sinDec = 0.39782 * sin($L*pi/180);
   my $cosDec = cos(asin($sinDec));
   print "6) sinDec,cosDec is $sinDec,$cosDec\n" if $debug;

   # Step 7a. Calculate the Sun's local hour angle.
   my $cosH = ($cos_zenith - ($sinDec * sin($latitude*pi/180))) / ($cosDec * cos($latitude*pi/180));
   print "7) cosH is $cosH,$cosH\n" if $debug;

   # If either of these are true, then the sun never rises/sets
   # at this location/date, but that should never happen for Toronto.
   croak if ($cosH > 1 || $cosH < -1);

   # Step 7b. Calculate H and convert into hours.
   my $H;
   if ($type eq "Sunrise")
   {
      $H = 360 - 180/pi*acos($cosH);
   }
   else
   {
      croak if $type ne "Sunset";
      $H = 180/pi*acos($cosH);
   }

   $H /= 15;
   print "7) is $H\n" if $debug;

   # Step 8.  Calculate local mean time of rising/setting.
   my $T = $H + $RA - (0.06571*$t) - 6.622;

   # Try random correction factor, since my times seem to be
   # coming in the range (-2,1) compared to USNO.
   #$T += 0.5/60;

   # Step 9.  Adjust back to UTC.
   my $UT = $T - $lngHour;
   if ($UT < 0) { $UT += 24 };
   if ($UT >= 24) { $UT -= 24 };

   # Step 10. Convert UT value to local time zone.
   my $localT = $UT + $localOffset;
   if ($localT < 0) { $localT += 24 };
   if ($localT >= 24) { $localT -= 24 };

   my $localHours = int($localT);
    # Add 0.5 minutes in order to round to nearest minute
   my $localMinutes = int(($localT - $localHours)*60 + 0.5);

   # Adjust to 12-hour time.
   if ($localHours == 0) { $localHours = 12 };
   if ($localHours > 12) { $localHours -= 12 };

   # Adjust for DST.
   my $time = "$localHours:$localMinutes";
   if (is_during_DST($day))
   {
      $time = add_minutes($time,60);
   }
   else
   {
      # In very rare cases, the time can show up as e.g. 6:60
      # due to rounding when I add 0.5 minutes above.  I could
      # easily fix it above in a more sensible way, but this
      # seems like the least likely way (I think you meant MOST likely way -AMB)
      # to get it right without having to test.
      $time = add_minutes($time,0);
   }

   # Fix single digit minutes.  Probably not really necessary
   # at this point, but what the hey.
   $time =~ s/:(\d[^\d])/:0$1/g;
   $time =~ s/:(\d)$/:0$1/;

    return $time;

}

sub renorm_angle($)
{
   # Renormalize an angle into the range [0,360).
   my ($L) = @_;
   while ($L < 0) { $L += 360 };
   while ($L >= 360) { $L -= 360 };
   return $L;
}
